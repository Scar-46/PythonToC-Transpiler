Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AS
    BIN_NUMBER
    HEX_NUMBER
    L_CB
    OCT_NUMBER
    R_CB
    WHITESPACE

Grammar

Rule 0     S' -> file
Rule 1     file -> statements ENDMARKER
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> compound_stmt
Rule 5     statement -> simple_stmts
Rule 6     simple_stmts -> simple_stmts SEMICOLON simple_stmt
Rule 7     simple_stmts -> simple_stmt NEWLINE
Rule 8     simple_stmt -> assignment
Rule 9     simple_stmt -> return_stmt
Rule 10    simple_stmt -> PASS
Rule 11    simple_stmt -> del_stmt
Rule 12    simple_stmt -> BREAK
Rule 13    simple_stmt -> CONTINUE
Rule 14    simple_stmt -> global_stmt
Rule 15    compound_stmt -> function_def
Rule 16    compound_stmt -> if_stmt
Rule 17    compound_stmt -> class_def
Rule 18    compound_stmt -> for_stmt
Rule 19    compound_stmt -> while_stmt
Rule 20    assignment -> IDENTIFIER augmentation_assignment expressions
Rule 21    augmentation_assignment -> ASSIGNMENT
Rule 22    augmentation_assignment -> SUM_ASSIGNMENT
Rule 23    augmentation_assignment -> SUBTRACTION_ASSIGNMENT
Rule 24    augmentation_assignment -> PRODUCT_ASSIGNMENT
Rule 25    augmentation_assignment -> DIVISION_ASSIGNMENT
Rule 26    augmentation_assignment -> MODULUS_ASSIGNMENT
Rule 27    augmentation_assignment -> EXPONENTIATION_ASSIGNMENT
Rule 28    augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT
Rule 29    return_stmt -> RETURN expressions
Rule 30    global_stmt -> GLOBAL namelist
Rule 31    del_stmt -> DEL namelist
Rule 32    namelist -> namelist COMMA IDENTIFIER
Rule 33    namelist -> IDENTIFIER
Rule 34    block -> NEWLINE INDENT statements DEDENT
Rule 35    block -> simple_stmts
Rule 36    class_def -> CLASS IDENTIFIER COLON block
Rule 37    class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
Rule 38    class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
Rule 39    function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
Rule 40    function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
Rule 41    parameters -> parameters COMMA IDENTIFIER
Rule 42    parameters -> IDENTIFIER
Rule 43    if_stmt -> IF expression COLON block elif_stmt
Rule 44    if_stmt -> IF expression COLON block else_block
Rule 45    if_stmt -> IF expression COLON block
Rule 46    elif_stmt -> ELIF expression COLON block elif_stmt
Rule 47    elif_stmt -> ELIF expression COLON block else_block
Rule 48    elif_stmt -> ELIF expression COLON block
Rule 49    else_block -> ELSE COLON block
Rule 50    while_stmt -> WHILE expression COLON block else_block
Rule 51    while_stmt -> WHILE expression COLON block
Rule 52    for_stmt -> FOR targets IN expressions COLON else_block
Rule 53    for_stmt -> FOR targets IN expressions COLON block
Rule 54    expressions -> expressions COMMA expression
Rule 55    expressions -> expression
Rule 56    expression -> disjunction
Rule 57    expression -> disjunction IF disjunction ELSE expression
Rule 58    disjunction -> conjunction
Rule 59    disjunction -> conjunction OR disjunction
Rule 60    conjunction -> inversion
Rule 61    conjunction -> inversion AND inversion
Rule 62    inversion -> NOT inversion
Rule 63    inversion -> comparison
Rule 64    comparison -> bitwise_or
Rule 65    comparison -> bitwise_or compare_op_list
Rule 66    compare_op_list -> compare_op
Rule 67    compare_op_list -> compare_op_list compare_op
Rule 68    compare_op -> EQUALITY bitwise_or
Rule 69    compare_op -> INEQUALITY bitwise_or
Rule 70    compare_op -> GREATER_EQUAL bitwise_or
Rule 71    compare_op -> LESSER_EQUAL bitwise_or
Rule 72    compare_op -> GREATER bitwise_or
Rule 73    compare_op -> LESSER bitwise_or
Rule 74    compare_op -> NOT IN bitwise_or
Rule 75    compare_op -> IS NOT bitwise_or
Rule 76    compare_op -> IN bitwise_or
Rule 77    compare_op -> IS bitwise_or
Rule 78    bitwise_or -> bitwise_or BITWISE_OR bitwise_xor
Rule 79    bitwise_or -> bitwise_xor
Rule 80    bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and
Rule 81    bitwise_xor -> bitwise_and
Rule 82    bitwise_and -> bitwise_and BITWISE_AND shift_expr
Rule 83    bitwise_and -> shift_expr
Rule 84    shift_expr -> shift_expr L_SHIFT sum
Rule 85    shift_expr -> shift_expr R_SHIFT sum
Rule 86    shift_expr -> sum
Rule 87    sum -> sum SUM term
Rule 88    sum -> sum SUBTRACTION term
Rule 89    sum -> term
Rule 90    term -> term PRODUCT factor
Rule 91    term -> term DIVISION factor
Rule 92    term -> term INTEGER_DIVISION factor
Rule 93    term -> term MODULUS factor
Rule 94    term -> factor
Rule 95    factor -> SUM factor
Rule 96    factor -> SUBTRACTION factor
Rule 97    factor -> power
Rule 98    power -> primary EXPONENTIATION target
Rule 99    power -> primary
Rule 100   primary -> primary DOT IDENTIFIER
Rule 101   primary -> primary L_PARENTHESIS arguments R_PARENTHESIS
Rule 102   primary -> primary L_SQB slices R_SQB
Rule 103   primary -> atomic
Rule 104   slices -> slice
Rule 105   slices -> COMMA L_PARENTHESIS slice R_PARENTHESIS slices
Rule 106   slice -> expression
Rule 107   atomic -> IDENTIFIER
Rule 108   atomic -> TRUE
Rule 109   atomic -> FALSE
Rule 110   atomic -> NONE
Rule 111   atomic -> strings
Rule 112   atomic -> NUMBER
Rule 113   atomic -> F_NUMBER
Rule 114   arguments -> <empty>
Rule 115   strings -> STRING
Rule 116   strings -> TRIPLE_STRING
Rule 117   targets -> target
Rule 118   targets -> target COMMA targets
Rule 119   target -> empty
Rule 120   empty -> <empty>

Terminals, with rules where they appear

AND                  : 61
AS                   : 
ASSIGNMENT           : 21
BIN_NUMBER           : 
BITWISE_AND          : 82
BITWISE_OR           : 78
BITWISE_XOR          : 80
BREAK                : 12
CLASS                : 36 37 38
COLON                : 36 37 38 39 40 43 44 45 46 47 48 49 50 51 52 53
COMMA                : 32 41 54 105 118
CONTINUE             : 13
DEDENT               : 34
DEF                  : 39 40
DEL                  : 31
DIVISION             : 91
DIVISION_ASSIGNMENT  : 25
DOT                  : 100
ELIF                 : 46 47 48
ELSE                 : 49 57
ENDMARKER            : 1
EQUALITY             : 68
EXPONENTIATION       : 98
EXPONENTIATION_ASSIGNMENT : 27
FALSE                : 109
FOR                  : 52 53
F_NUMBER             : 113
GLOBAL               : 30
GREATER              : 72
GREATER_EQUAL        : 70
HEX_NUMBER           : 
IDENTIFIER           : 20 32 33 36 37 38 39 40 41 42 100 107
IF                   : 43 44 45 57
IN                   : 52 53 74 76
INDENT               : 34
INEQUALITY           : 69
INTEGER_DIVISION     : 92
INTEGER_DIVISION_ASSIGNMENT : 28
IS                   : 75 77
LESSER               : 73
LESSER_EQUAL         : 71
L_CB                 : 
L_PARENTHESIS        : 37 38 39 40 101 105
L_SHIFT              : 84
L_SQB                : 102
MODULUS              : 93
MODULUS_ASSIGNMENT   : 26
NEWLINE              : 7 34
NONE                 : 110
NOT                  : 62 74 75
NUMBER               : 112
OCT_NUMBER           : 
OR                   : 59
PASS                 : 10
PRODUCT              : 90
PRODUCT_ASSIGNMENT   : 24
RETURN               : 29
R_CB                 : 
R_PARENTHESIS        : 37 38 39 40 101 105
R_SHIFT              : 85
R_SQB                : 102
SEMICOLON            : 6
STRING               : 115
SUBTRACTION          : 88 96
SUBTRACTION_ASSIGNMENT : 23
SUM                  : 87 95
SUM_ASSIGNMENT       : 22
TRIPLE_STRING        : 116
TRUE                 : 108
WHILE                : 50 51
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

arguments            : 38 101
assignment           : 8
atomic               : 103
augmentation_assignment : 20
bitwise_and          : 80 81 82
bitwise_or           : 64 65 68 69 70 71 72 73 74 75 76 77 78
bitwise_xor          : 78 79 80
block                : 36 37 38 39 40 43 44 45 46 47 48 49 50 51 53
class_def            : 17
compare_op           : 66 67
compare_op_list      : 65 67
comparison           : 63
compound_stmt        : 4
conjunction          : 58 59
del_stmt             : 11
disjunction          : 56 57 57 59
elif_stmt            : 43 46
else_block           : 44 47 50 52
empty                : 119
expression           : 43 44 45 46 47 48 50 51 54 55 57 106
expressions          : 20 29 52 53 54
factor               : 90 91 92 93 94 95 96
file                 : 0
for_stmt             : 18
function_def         : 15
global_stmt          : 14
if_stmt              : 16
inversion            : 60 61 61 62
namelist             : 30 31 32
parameters           : 39 41
power                : 97
primary              : 98 99 100 101 102
return_stmt          : 9
shift_expr           : 82 83 84 85
simple_stmt          : 6 7
simple_stmts         : 5 6 35
slice                : 104 105
slices               : 102 105
statement            : 2 3
statements           : 1 2 34
strings              : 111
sum                  : 84 85 86 87 88
target               : 98 117 118
targets              : 52 53 118
term                 : 87 88 89 90 91 92 93
while_stmt           : 19

Parsing method: LALR

state 0

    (0) S' -> . file
    (1) file -> . statements ENDMARKER
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF expression COLON block elif_stmt
    (44) if_stmt -> . IF expression COLON block else_block
    (45) if_stmt -> . IF expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (52) for_stmt -> . FOR targets IN expressions COLON else_block
    (53) for_stmt -> . FOR targets IN expressions COLON block
    (50) while_stmt -> . WHILE expression COLON block else_block
    (51) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    file                           shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 1

    (0) S' -> file .



state 2

    (1) file -> statements . ENDMARKER
    (2) statements -> statements . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF expression COLON block elif_stmt
    (44) if_stmt -> . IF expression COLON block else_block
    (45) if_stmt -> . IF expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (52) for_stmt -> . FOR targets IN expressions COLON else_block
    (53) for_stmt -> . FOR targets IN expressions COLON block
    (50) while_stmt -> . WHILE expression COLON block else_block
    (51) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    ENDMARKER       shift and go to state 28
    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    statement                      shift and go to state 29
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 3

    (3) statements -> statement .

    ENDMARKER       reduce using rule 3 (statements -> statement .)
    DEF             reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    CLASS           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)
    PASS            reduce using rule 3 (statements -> statement .)
    BREAK           reduce using rule 3 (statements -> statement .)
    CONTINUE        reduce using rule 3 (statements -> statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    DEL             reduce using rule 3 (statements -> statement .)
    GLOBAL          reduce using rule 3 (statements -> statement .)
    DEDENT          reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> compound_stmt .

    ENDMARKER       reduce using rule 4 (statement -> compound_stmt .)
    DEF             reduce using rule 4 (statement -> compound_stmt .)
    IF              reduce using rule 4 (statement -> compound_stmt .)
    CLASS           reduce using rule 4 (statement -> compound_stmt .)
    FOR             reduce using rule 4 (statement -> compound_stmt .)
    WHILE           reduce using rule 4 (statement -> compound_stmt .)
    PASS            reduce using rule 4 (statement -> compound_stmt .)
    BREAK           reduce using rule 4 (statement -> compound_stmt .)
    CONTINUE        reduce using rule 4 (statement -> compound_stmt .)
    IDENTIFIER      reduce using rule 4 (statement -> compound_stmt .)
    RETURN          reduce using rule 4 (statement -> compound_stmt .)
    DEL             reduce using rule 4 (statement -> compound_stmt .)
    GLOBAL          reduce using rule 4 (statement -> compound_stmt .)
    DEDENT          reduce using rule 4 (statement -> compound_stmt .)


state 5

    (5) statement -> simple_stmts .
    (6) simple_stmts -> simple_stmts . SEMICOLON simple_stmt

    ENDMARKER       reduce using rule 5 (statement -> simple_stmts .)
    DEF             reduce using rule 5 (statement -> simple_stmts .)
    IF              reduce using rule 5 (statement -> simple_stmts .)
    CLASS           reduce using rule 5 (statement -> simple_stmts .)
    FOR             reduce using rule 5 (statement -> simple_stmts .)
    WHILE           reduce using rule 5 (statement -> simple_stmts .)
    PASS            reduce using rule 5 (statement -> simple_stmts .)
    BREAK           reduce using rule 5 (statement -> simple_stmts .)
    CONTINUE        reduce using rule 5 (statement -> simple_stmts .)
    IDENTIFIER      reduce using rule 5 (statement -> simple_stmts .)
    RETURN          reduce using rule 5 (statement -> simple_stmts .)
    DEL             reduce using rule 5 (statement -> simple_stmts .)
    GLOBAL          reduce using rule 5 (statement -> simple_stmts .)
    DEDENT          reduce using rule 5 (statement -> simple_stmts .)
    SEMICOLON       shift and go to state 30


state 6

    (15) compound_stmt -> function_def .

    ENDMARKER       reduce using rule 15 (compound_stmt -> function_def .)
    DEF             reduce using rule 15 (compound_stmt -> function_def .)
    IF              reduce using rule 15 (compound_stmt -> function_def .)
    CLASS           reduce using rule 15 (compound_stmt -> function_def .)
    FOR             reduce using rule 15 (compound_stmt -> function_def .)
    WHILE           reduce using rule 15 (compound_stmt -> function_def .)
    PASS            reduce using rule 15 (compound_stmt -> function_def .)
    BREAK           reduce using rule 15 (compound_stmt -> function_def .)
    CONTINUE        reduce using rule 15 (compound_stmt -> function_def .)
    IDENTIFIER      reduce using rule 15 (compound_stmt -> function_def .)
    RETURN          reduce using rule 15 (compound_stmt -> function_def .)
    DEL             reduce using rule 15 (compound_stmt -> function_def .)
    GLOBAL          reduce using rule 15 (compound_stmt -> function_def .)
    DEDENT          reduce using rule 15 (compound_stmt -> function_def .)


state 7

    (16) compound_stmt -> if_stmt .

    ENDMARKER       reduce using rule 16 (compound_stmt -> if_stmt .)
    DEF             reduce using rule 16 (compound_stmt -> if_stmt .)
    IF              reduce using rule 16 (compound_stmt -> if_stmt .)
    CLASS           reduce using rule 16 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 16 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 16 (compound_stmt -> if_stmt .)
    PASS            reduce using rule 16 (compound_stmt -> if_stmt .)
    BREAK           reduce using rule 16 (compound_stmt -> if_stmt .)
    CONTINUE        reduce using rule 16 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 16 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 16 (compound_stmt -> if_stmt .)
    DEL             reduce using rule 16 (compound_stmt -> if_stmt .)
    GLOBAL          reduce using rule 16 (compound_stmt -> if_stmt .)
    DEDENT          reduce using rule 16 (compound_stmt -> if_stmt .)


state 8

    (17) compound_stmt -> class_def .

    ENDMARKER       reduce using rule 17 (compound_stmt -> class_def .)
    DEF             reduce using rule 17 (compound_stmt -> class_def .)
    IF              reduce using rule 17 (compound_stmt -> class_def .)
    CLASS           reduce using rule 17 (compound_stmt -> class_def .)
    FOR             reduce using rule 17 (compound_stmt -> class_def .)
    WHILE           reduce using rule 17 (compound_stmt -> class_def .)
    PASS            reduce using rule 17 (compound_stmt -> class_def .)
    BREAK           reduce using rule 17 (compound_stmt -> class_def .)
    CONTINUE        reduce using rule 17 (compound_stmt -> class_def .)
    IDENTIFIER      reduce using rule 17 (compound_stmt -> class_def .)
    RETURN          reduce using rule 17 (compound_stmt -> class_def .)
    DEL             reduce using rule 17 (compound_stmt -> class_def .)
    GLOBAL          reduce using rule 17 (compound_stmt -> class_def .)
    DEDENT          reduce using rule 17 (compound_stmt -> class_def .)


state 9

    (18) compound_stmt -> for_stmt .

    ENDMARKER       reduce using rule 18 (compound_stmt -> for_stmt .)
    DEF             reduce using rule 18 (compound_stmt -> for_stmt .)
    IF              reduce using rule 18 (compound_stmt -> for_stmt .)
    CLASS           reduce using rule 18 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 18 (compound_stmt -> for_stmt .)
    WHILE           reduce using rule 18 (compound_stmt -> for_stmt .)
    PASS            reduce using rule 18 (compound_stmt -> for_stmt .)
    BREAK           reduce using rule 18 (compound_stmt -> for_stmt .)
    CONTINUE        reduce using rule 18 (compound_stmt -> for_stmt .)
    IDENTIFIER      reduce using rule 18 (compound_stmt -> for_stmt .)
    RETURN          reduce using rule 18 (compound_stmt -> for_stmt .)
    DEL             reduce using rule 18 (compound_stmt -> for_stmt .)
    GLOBAL          reduce using rule 18 (compound_stmt -> for_stmt .)
    DEDENT          reduce using rule 18 (compound_stmt -> for_stmt .)


state 10

    (19) compound_stmt -> while_stmt .

    ENDMARKER       reduce using rule 19 (compound_stmt -> while_stmt .)
    DEF             reduce using rule 19 (compound_stmt -> while_stmt .)
    IF              reduce using rule 19 (compound_stmt -> while_stmt .)
    CLASS           reduce using rule 19 (compound_stmt -> while_stmt .)
    FOR             reduce using rule 19 (compound_stmt -> while_stmt .)
    WHILE           reduce using rule 19 (compound_stmt -> while_stmt .)
    PASS            reduce using rule 19 (compound_stmt -> while_stmt .)
    BREAK           reduce using rule 19 (compound_stmt -> while_stmt .)
    CONTINUE        reduce using rule 19 (compound_stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 19 (compound_stmt -> while_stmt .)
    RETURN          reduce using rule 19 (compound_stmt -> while_stmt .)
    DEL             reduce using rule 19 (compound_stmt -> while_stmt .)
    GLOBAL          reduce using rule 19 (compound_stmt -> while_stmt .)
    DEDENT          reduce using rule 19 (compound_stmt -> while_stmt .)


state 11

    (7) simple_stmts -> simple_stmt . NEWLINE

    NEWLINE         shift and go to state 31


state 12

    (39) function_def -> DEF . IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> DEF . IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block

    IDENTIFIER      shift and go to state 32


state 13

    (20) assignment -> IDENTIFIER . augmentation_assignment expressions
    (21) augmentation_assignment -> . ASSIGNMENT
    (22) augmentation_assignment -> . SUM_ASSIGNMENT
    (23) augmentation_assignment -> . SUBTRACTION_ASSIGNMENT
    (24) augmentation_assignment -> . PRODUCT_ASSIGNMENT
    (25) augmentation_assignment -> . DIVISION_ASSIGNMENT
    (26) augmentation_assignment -> . MODULUS_ASSIGNMENT
    (27) augmentation_assignment -> . EXPONENTIATION_ASSIGNMENT
    (28) augmentation_assignment -> . INTEGER_DIVISION_ASSIGNMENT

    ASSIGNMENT      shift and go to state 34
    SUM_ASSIGNMENT  shift and go to state 35
    SUBTRACTION_ASSIGNMENT shift and go to state 36
    PRODUCT_ASSIGNMENT shift and go to state 37
    DIVISION_ASSIGNMENT shift and go to state 38
    MODULUS_ASSIGNMENT shift and go to state 39
    EXPONENTIATION_ASSIGNMENT shift and go to state 40
    INTEGER_DIVISION_ASSIGNMENT shift and go to state 41

    augmentation_assignment        shift and go to state 33

state 14

    (43) if_stmt -> IF . expression COLON block elif_stmt
    (44) if_stmt -> IF . expression COLON block else_block
    (45) if_stmt -> IF . expression COLON block
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    expression                     shift and go to state 42
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 15

    (36) class_def -> CLASS . IDENTIFIER COLON block
    (37) class_def -> CLASS . IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> CLASS . IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block

    IDENTIFIER      shift and go to state 69


state 16

    (52) for_stmt -> FOR . targets IN expressions COLON else_block
    (53) for_stmt -> FOR . targets IN expressions COLON block
    (117) targets -> . target
    (118) targets -> . target COMMA targets
    (119) target -> . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    IN              reduce using rule 120 (empty -> .)

    targets                        shift and go to state 70
    target                         shift and go to state 71
    empty                          shift and go to state 72

state 17

    (50) while_stmt -> WHILE . expression COLON block else_block
    (51) while_stmt -> WHILE . expression COLON block
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    expression                     shift and go to state 73
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 18

    (8) simple_stmt -> assignment .

    NEWLINE         reduce using rule 8 (simple_stmt -> assignment .)
    SEMICOLON       reduce using rule 8 (simple_stmt -> assignment .)
    ENDMARKER       reduce using rule 8 (simple_stmt -> assignment .)
    DEF             reduce using rule 8 (simple_stmt -> assignment .)
    IF              reduce using rule 8 (simple_stmt -> assignment .)
    CLASS           reduce using rule 8 (simple_stmt -> assignment .)
    FOR             reduce using rule 8 (simple_stmt -> assignment .)
    WHILE           reduce using rule 8 (simple_stmt -> assignment .)
    PASS            reduce using rule 8 (simple_stmt -> assignment .)
    BREAK           reduce using rule 8 (simple_stmt -> assignment .)
    CONTINUE        reduce using rule 8 (simple_stmt -> assignment .)
    IDENTIFIER      reduce using rule 8 (simple_stmt -> assignment .)
    RETURN          reduce using rule 8 (simple_stmt -> assignment .)
    DEL             reduce using rule 8 (simple_stmt -> assignment .)
    GLOBAL          reduce using rule 8 (simple_stmt -> assignment .)
    ELIF            reduce using rule 8 (simple_stmt -> assignment .)
    ELSE            reduce using rule 8 (simple_stmt -> assignment .)
    DEDENT          reduce using rule 8 (simple_stmt -> assignment .)


state 19

    (9) simple_stmt -> return_stmt .

    NEWLINE         reduce using rule 9 (simple_stmt -> return_stmt .)
    SEMICOLON       reduce using rule 9 (simple_stmt -> return_stmt .)
    ENDMARKER       reduce using rule 9 (simple_stmt -> return_stmt .)
    DEF             reduce using rule 9 (simple_stmt -> return_stmt .)
    IF              reduce using rule 9 (simple_stmt -> return_stmt .)
    CLASS           reduce using rule 9 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 9 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 9 (simple_stmt -> return_stmt .)
    PASS            reduce using rule 9 (simple_stmt -> return_stmt .)
    BREAK           reduce using rule 9 (simple_stmt -> return_stmt .)
    CONTINUE        reduce using rule 9 (simple_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 9 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 9 (simple_stmt -> return_stmt .)
    DEL             reduce using rule 9 (simple_stmt -> return_stmt .)
    GLOBAL          reduce using rule 9 (simple_stmt -> return_stmt .)
    ELIF            reduce using rule 9 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 9 (simple_stmt -> return_stmt .)
    DEDENT          reduce using rule 9 (simple_stmt -> return_stmt .)


state 20

    (10) simple_stmt -> PASS .

    NEWLINE         reduce using rule 10 (simple_stmt -> PASS .)
    SEMICOLON       reduce using rule 10 (simple_stmt -> PASS .)
    ENDMARKER       reduce using rule 10 (simple_stmt -> PASS .)
    DEF             reduce using rule 10 (simple_stmt -> PASS .)
    IF              reduce using rule 10 (simple_stmt -> PASS .)
    CLASS           reduce using rule 10 (simple_stmt -> PASS .)
    FOR             reduce using rule 10 (simple_stmt -> PASS .)
    WHILE           reduce using rule 10 (simple_stmt -> PASS .)
    PASS            reduce using rule 10 (simple_stmt -> PASS .)
    BREAK           reduce using rule 10 (simple_stmt -> PASS .)
    CONTINUE        reduce using rule 10 (simple_stmt -> PASS .)
    IDENTIFIER      reduce using rule 10 (simple_stmt -> PASS .)
    RETURN          reduce using rule 10 (simple_stmt -> PASS .)
    DEL             reduce using rule 10 (simple_stmt -> PASS .)
    GLOBAL          reduce using rule 10 (simple_stmt -> PASS .)
    ELIF            reduce using rule 10 (simple_stmt -> PASS .)
    ELSE            reduce using rule 10 (simple_stmt -> PASS .)
    DEDENT          reduce using rule 10 (simple_stmt -> PASS .)


state 21

    (11) simple_stmt -> del_stmt .

    NEWLINE         reduce using rule 11 (simple_stmt -> del_stmt .)
    SEMICOLON       reduce using rule 11 (simple_stmt -> del_stmt .)
    ENDMARKER       reduce using rule 11 (simple_stmt -> del_stmt .)
    DEF             reduce using rule 11 (simple_stmt -> del_stmt .)
    IF              reduce using rule 11 (simple_stmt -> del_stmt .)
    CLASS           reduce using rule 11 (simple_stmt -> del_stmt .)
    FOR             reduce using rule 11 (simple_stmt -> del_stmt .)
    WHILE           reduce using rule 11 (simple_stmt -> del_stmt .)
    PASS            reduce using rule 11 (simple_stmt -> del_stmt .)
    BREAK           reduce using rule 11 (simple_stmt -> del_stmt .)
    CONTINUE        reduce using rule 11 (simple_stmt -> del_stmt .)
    IDENTIFIER      reduce using rule 11 (simple_stmt -> del_stmt .)
    RETURN          reduce using rule 11 (simple_stmt -> del_stmt .)
    DEL             reduce using rule 11 (simple_stmt -> del_stmt .)
    GLOBAL          reduce using rule 11 (simple_stmt -> del_stmt .)
    ELIF            reduce using rule 11 (simple_stmt -> del_stmt .)
    ELSE            reduce using rule 11 (simple_stmt -> del_stmt .)
    DEDENT          reduce using rule 11 (simple_stmt -> del_stmt .)


state 22

    (12) simple_stmt -> BREAK .

    NEWLINE         reduce using rule 12 (simple_stmt -> BREAK .)
    SEMICOLON       reduce using rule 12 (simple_stmt -> BREAK .)
    ENDMARKER       reduce using rule 12 (simple_stmt -> BREAK .)
    DEF             reduce using rule 12 (simple_stmt -> BREAK .)
    IF              reduce using rule 12 (simple_stmt -> BREAK .)
    CLASS           reduce using rule 12 (simple_stmt -> BREAK .)
    FOR             reduce using rule 12 (simple_stmt -> BREAK .)
    WHILE           reduce using rule 12 (simple_stmt -> BREAK .)
    PASS            reduce using rule 12 (simple_stmt -> BREAK .)
    BREAK           reduce using rule 12 (simple_stmt -> BREAK .)
    CONTINUE        reduce using rule 12 (simple_stmt -> BREAK .)
    IDENTIFIER      reduce using rule 12 (simple_stmt -> BREAK .)
    RETURN          reduce using rule 12 (simple_stmt -> BREAK .)
    DEL             reduce using rule 12 (simple_stmt -> BREAK .)
    GLOBAL          reduce using rule 12 (simple_stmt -> BREAK .)
    ELIF            reduce using rule 12 (simple_stmt -> BREAK .)
    ELSE            reduce using rule 12 (simple_stmt -> BREAK .)
    DEDENT          reduce using rule 12 (simple_stmt -> BREAK .)


state 23

    (13) simple_stmt -> CONTINUE .

    NEWLINE         reduce using rule 13 (simple_stmt -> CONTINUE .)
    SEMICOLON       reduce using rule 13 (simple_stmt -> CONTINUE .)
    ENDMARKER       reduce using rule 13 (simple_stmt -> CONTINUE .)
    DEF             reduce using rule 13 (simple_stmt -> CONTINUE .)
    IF              reduce using rule 13 (simple_stmt -> CONTINUE .)
    CLASS           reduce using rule 13 (simple_stmt -> CONTINUE .)
    FOR             reduce using rule 13 (simple_stmt -> CONTINUE .)
    WHILE           reduce using rule 13 (simple_stmt -> CONTINUE .)
    PASS            reduce using rule 13 (simple_stmt -> CONTINUE .)
    BREAK           reduce using rule 13 (simple_stmt -> CONTINUE .)
    CONTINUE        reduce using rule 13 (simple_stmt -> CONTINUE .)
    IDENTIFIER      reduce using rule 13 (simple_stmt -> CONTINUE .)
    RETURN          reduce using rule 13 (simple_stmt -> CONTINUE .)
    DEL             reduce using rule 13 (simple_stmt -> CONTINUE .)
    GLOBAL          reduce using rule 13 (simple_stmt -> CONTINUE .)
    ELIF            reduce using rule 13 (simple_stmt -> CONTINUE .)
    ELSE            reduce using rule 13 (simple_stmt -> CONTINUE .)
    DEDENT          reduce using rule 13 (simple_stmt -> CONTINUE .)


state 24

    (14) simple_stmt -> global_stmt .

    NEWLINE         reduce using rule 14 (simple_stmt -> global_stmt .)
    SEMICOLON       reduce using rule 14 (simple_stmt -> global_stmt .)
    ENDMARKER       reduce using rule 14 (simple_stmt -> global_stmt .)
    DEF             reduce using rule 14 (simple_stmt -> global_stmt .)
    IF              reduce using rule 14 (simple_stmt -> global_stmt .)
    CLASS           reduce using rule 14 (simple_stmt -> global_stmt .)
    FOR             reduce using rule 14 (simple_stmt -> global_stmt .)
    WHILE           reduce using rule 14 (simple_stmt -> global_stmt .)
    PASS            reduce using rule 14 (simple_stmt -> global_stmt .)
    BREAK           reduce using rule 14 (simple_stmt -> global_stmt .)
    CONTINUE        reduce using rule 14 (simple_stmt -> global_stmt .)
    IDENTIFIER      reduce using rule 14 (simple_stmt -> global_stmt .)
    RETURN          reduce using rule 14 (simple_stmt -> global_stmt .)
    DEL             reduce using rule 14 (simple_stmt -> global_stmt .)
    GLOBAL          reduce using rule 14 (simple_stmt -> global_stmt .)
    ELIF            reduce using rule 14 (simple_stmt -> global_stmt .)
    ELSE            reduce using rule 14 (simple_stmt -> global_stmt .)
    DEDENT          reduce using rule 14 (simple_stmt -> global_stmt .)


state 25

    (29) return_stmt -> RETURN . expressions
    (54) expressions -> . expressions COMMA expression
    (55) expressions -> . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    expressions                    shift and go to state 74
    expression                     shift and go to state 75
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 26

    (31) del_stmt -> DEL . namelist
    (32) namelist -> . namelist COMMA IDENTIFIER
    (33) namelist -> . IDENTIFIER

    IDENTIFIER      shift and go to state 77

    namelist                       shift and go to state 76

state 27

    (30) global_stmt -> GLOBAL . namelist
    (32) namelist -> . namelist COMMA IDENTIFIER
    (33) namelist -> . IDENTIFIER

    IDENTIFIER      shift and go to state 77

    namelist                       shift and go to state 78

state 28

    (1) file -> statements ENDMARKER .

    $end            reduce using rule 1 (file -> statements ENDMARKER .)


state 29

    (2) statements -> statements statement .

    ENDMARKER       reduce using rule 2 (statements -> statements statement .)
    DEF             reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    CLASS           reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    WHILE           reduce using rule 2 (statements -> statements statement .)
    PASS            reduce using rule 2 (statements -> statements statement .)
    BREAK           reduce using rule 2 (statements -> statements statement .)
    CONTINUE        reduce using rule 2 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 2 (statements -> statements statement .)
    RETURN          reduce using rule 2 (statements -> statements statement .)
    DEL             reduce using rule 2 (statements -> statements statement .)
    GLOBAL          reduce using rule 2 (statements -> statements statement .)
    DEDENT          reduce using rule 2 (statements -> statements statement .)


state 30

    (6) simple_stmts -> simple_stmts SEMICOLON . simple_stmt
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    simple_stmt                    shift and go to state 79
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 31

    (7) simple_stmts -> simple_stmt NEWLINE .

    SEMICOLON       reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ENDMARKER       reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEF             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    IF              reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    CLASS           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    FOR             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    WHILE           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    PASS            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    BREAK           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    CONTINUE        reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    IDENTIFIER      reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    RETURN          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEL             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    GLOBAL          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ELIF            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ELSE            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEDENT          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)


state 32

    (39) function_def -> DEF IDENTIFIER . L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> DEF IDENTIFIER . L_PARENTHESIS R_PARENTHESIS COLON block

    L_PARENTHESIS   shift and go to state 80


state 33

    (20) assignment -> IDENTIFIER augmentation_assignment . expressions
    (54) expressions -> . expressions COMMA expression
    (55) expressions -> . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    expressions                    shift and go to state 81
    expression                     shift and go to state 75
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 34

    (21) augmentation_assignment -> ASSIGNMENT .

    NOT             reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    SUM             reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    SUBTRACTION     reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    IDENTIFIER      reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    TRUE            reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    FALSE           reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    NONE            reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    NUMBER          reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    F_NUMBER        reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    STRING          reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 21 (augmentation_assignment -> ASSIGNMENT .)


state 35

    (22) augmentation_assignment -> SUM_ASSIGNMENT .

    NOT             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    SUM             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    TRUE            reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    FALSE           reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    NONE            reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    NUMBER          reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    F_NUMBER        reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    STRING          reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)


state 36

    (23) augmentation_assignment -> SUBTRACTION_ASSIGNMENT .

    NOT             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    SUM             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    TRUE            reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    FALSE           reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    NONE            reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    NUMBER          reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    STRING          reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)


state 37

    (24) augmentation_assignment -> PRODUCT_ASSIGNMENT .

    NOT             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    SUM             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    TRUE            reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    FALSE           reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    NONE            reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    NUMBER          reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    F_NUMBER        reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    STRING          reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)


state 38

    (25) augmentation_assignment -> DIVISION_ASSIGNMENT .

    NOT             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    SUM             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    TRUE            reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    FALSE           reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    NONE            reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    NUMBER          reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    STRING          reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)


state 39

    (26) augmentation_assignment -> MODULUS_ASSIGNMENT .

    NOT             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    SUM             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    TRUE            reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    FALSE           reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    NONE            reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    NUMBER          reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    F_NUMBER        reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    STRING          reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)


state 40

    (27) augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .

    NOT             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    SUM             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    TRUE            reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    FALSE           reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    NONE            reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    NUMBER          reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    STRING          reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)


state 41

    (28) augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .

    NOT             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    SUM             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    TRUE            reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    FALSE           reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    NONE            reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    NUMBER          reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    STRING          reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)


state 42

    (43) if_stmt -> IF expression . COLON block elif_stmt
    (44) if_stmt -> IF expression . COLON block else_block
    (45) if_stmt -> IF expression . COLON block

    COLON           shift and go to state 82


state 43

    (56) expression -> disjunction .
    (57) expression -> disjunction . IF disjunction ELSE expression

  ! shift/reduce conflict for IF resolved as shift
    COLON           reduce using rule 56 (expression -> disjunction .)
    COMMA           reduce using rule 56 (expression -> disjunction .)
    NEWLINE         reduce using rule 56 (expression -> disjunction .)
    SEMICOLON       reduce using rule 56 (expression -> disjunction .)
    ENDMARKER       reduce using rule 56 (expression -> disjunction .)
    DEF             reduce using rule 56 (expression -> disjunction .)
    CLASS           reduce using rule 56 (expression -> disjunction .)
    FOR             reduce using rule 56 (expression -> disjunction .)
    WHILE           reduce using rule 56 (expression -> disjunction .)
    PASS            reduce using rule 56 (expression -> disjunction .)
    BREAK           reduce using rule 56 (expression -> disjunction .)
    CONTINUE        reduce using rule 56 (expression -> disjunction .)
    IDENTIFIER      reduce using rule 56 (expression -> disjunction .)
    RETURN          reduce using rule 56 (expression -> disjunction .)
    DEL             reduce using rule 56 (expression -> disjunction .)
    GLOBAL          reduce using rule 56 (expression -> disjunction .)
    ELIF            reduce using rule 56 (expression -> disjunction .)
    ELSE            reduce using rule 56 (expression -> disjunction .)
    DEDENT          reduce using rule 56 (expression -> disjunction .)
    R_SQB           reduce using rule 56 (expression -> disjunction .)
    R_PARENTHESIS   reduce using rule 56 (expression -> disjunction .)
    IF              shift and go to state 83

  ! IF              [ reduce using rule 56 (expression -> disjunction .) ]


state 44

    (58) disjunction -> conjunction .
    (59) disjunction -> conjunction . OR disjunction

    IF              reduce using rule 58 (disjunction -> conjunction .)
    COLON           reduce using rule 58 (disjunction -> conjunction .)
    COMMA           reduce using rule 58 (disjunction -> conjunction .)
    NEWLINE         reduce using rule 58 (disjunction -> conjunction .)
    SEMICOLON       reduce using rule 58 (disjunction -> conjunction .)
    ENDMARKER       reduce using rule 58 (disjunction -> conjunction .)
    DEF             reduce using rule 58 (disjunction -> conjunction .)
    CLASS           reduce using rule 58 (disjunction -> conjunction .)
    FOR             reduce using rule 58 (disjunction -> conjunction .)
    WHILE           reduce using rule 58 (disjunction -> conjunction .)
    PASS            reduce using rule 58 (disjunction -> conjunction .)
    BREAK           reduce using rule 58 (disjunction -> conjunction .)
    CONTINUE        reduce using rule 58 (disjunction -> conjunction .)
    IDENTIFIER      reduce using rule 58 (disjunction -> conjunction .)
    RETURN          reduce using rule 58 (disjunction -> conjunction .)
    DEL             reduce using rule 58 (disjunction -> conjunction .)
    GLOBAL          reduce using rule 58 (disjunction -> conjunction .)
    ELIF            reduce using rule 58 (disjunction -> conjunction .)
    ELSE            reduce using rule 58 (disjunction -> conjunction .)
    DEDENT          reduce using rule 58 (disjunction -> conjunction .)
    R_SQB           reduce using rule 58 (disjunction -> conjunction .)
    R_PARENTHESIS   reduce using rule 58 (disjunction -> conjunction .)
    OR              shift and go to state 84


state 45

    (60) conjunction -> inversion .
    (61) conjunction -> inversion . AND inversion

    OR              reduce using rule 60 (conjunction -> inversion .)
    IF              reduce using rule 60 (conjunction -> inversion .)
    COLON           reduce using rule 60 (conjunction -> inversion .)
    COMMA           reduce using rule 60 (conjunction -> inversion .)
    NEWLINE         reduce using rule 60 (conjunction -> inversion .)
    SEMICOLON       reduce using rule 60 (conjunction -> inversion .)
    ENDMARKER       reduce using rule 60 (conjunction -> inversion .)
    DEF             reduce using rule 60 (conjunction -> inversion .)
    CLASS           reduce using rule 60 (conjunction -> inversion .)
    FOR             reduce using rule 60 (conjunction -> inversion .)
    WHILE           reduce using rule 60 (conjunction -> inversion .)
    PASS            reduce using rule 60 (conjunction -> inversion .)
    BREAK           reduce using rule 60 (conjunction -> inversion .)
    CONTINUE        reduce using rule 60 (conjunction -> inversion .)
    IDENTIFIER      reduce using rule 60 (conjunction -> inversion .)
    RETURN          reduce using rule 60 (conjunction -> inversion .)
    DEL             reduce using rule 60 (conjunction -> inversion .)
    GLOBAL          reduce using rule 60 (conjunction -> inversion .)
    ELIF            reduce using rule 60 (conjunction -> inversion .)
    ELSE            reduce using rule 60 (conjunction -> inversion .)
    DEDENT          reduce using rule 60 (conjunction -> inversion .)
    R_SQB           reduce using rule 60 (conjunction -> inversion .)
    R_PARENTHESIS   reduce using rule 60 (conjunction -> inversion .)
    AND             shift and go to state 85


state 46

    (62) inversion -> NOT . inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    inversion                      shift and go to state 86
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 47

    (63) inversion -> comparison .

    AND             reduce using rule 63 (inversion -> comparison .)
    OR              reduce using rule 63 (inversion -> comparison .)
    IF              reduce using rule 63 (inversion -> comparison .)
    COLON           reduce using rule 63 (inversion -> comparison .)
    COMMA           reduce using rule 63 (inversion -> comparison .)
    NEWLINE         reduce using rule 63 (inversion -> comparison .)
    SEMICOLON       reduce using rule 63 (inversion -> comparison .)
    ENDMARKER       reduce using rule 63 (inversion -> comparison .)
    DEF             reduce using rule 63 (inversion -> comparison .)
    CLASS           reduce using rule 63 (inversion -> comparison .)
    FOR             reduce using rule 63 (inversion -> comparison .)
    WHILE           reduce using rule 63 (inversion -> comparison .)
    PASS            reduce using rule 63 (inversion -> comparison .)
    BREAK           reduce using rule 63 (inversion -> comparison .)
    CONTINUE        reduce using rule 63 (inversion -> comparison .)
    IDENTIFIER      reduce using rule 63 (inversion -> comparison .)
    RETURN          reduce using rule 63 (inversion -> comparison .)
    DEL             reduce using rule 63 (inversion -> comparison .)
    GLOBAL          reduce using rule 63 (inversion -> comparison .)
    ELIF            reduce using rule 63 (inversion -> comparison .)
    ELSE            reduce using rule 63 (inversion -> comparison .)
    DEDENT          reduce using rule 63 (inversion -> comparison .)
    R_SQB           reduce using rule 63 (inversion -> comparison .)
    R_PARENTHESIS   reduce using rule 63 (inversion -> comparison .)


state 48

    (64) comparison -> bitwise_or .
    (65) comparison -> bitwise_or . compare_op_list
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor
    (66) compare_op_list -> . compare_op
    (67) compare_op_list -> . compare_op_list compare_op
    (68) compare_op -> . EQUALITY bitwise_or
    (69) compare_op -> . INEQUALITY bitwise_or
    (70) compare_op -> . GREATER_EQUAL bitwise_or
    (71) compare_op -> . LESSER_EQUAL bitwise_or
    (72) compare_op -> . GREATER bitwise_or
    (73) compare_op -> . LESSER bitwise_or
    (74) compare_op -> . NOT IN bitwise_or
    (75) compare_op -> . IS NOT bitwise_or
    (76) compare_op -> . IN bitwise_or
    (77) compare_op -> . IS bitwise_or

    AND             reduce using rule 64 (comparison -> bitwise_or .)
    OR              reduce using rule 64 (comparison -> bitwise_or .)
    IF              reduce using rule 64 (comparison -> bitwise_or .)
    COLON           reduce using rule 64 (comparison -> bitwise_or .)
    COMMA           reduce using rule 64 (comparison -> bitwise_or .)
    NEWLINE         reduce using rule 64 (comparison -> bitwise_or .)
    SEMICOLON       reduce using rule 64 (comparison -> bitwise_or .)
    ENDMARKER       reduce using rule 64 (comparison -> bitwise_or .)
    DEF             reduce using rule 64 (comparison -> bitwise_or .)
    CLASS           reduce using rule 64 (comparison -> bitwise_or .)
    FOR             reduce using rule 64 (comparison -> bitwise_or .)
    WHILE           reduce using rule 64 (comparison -> bitwise_or .)
    PASS            reduce using rule 64 (comparison -> bitwise_or .)
    BREAK           reduce using rule 64 (comparison -> bitwise_or .)
    CONTINUE        reduce using rule 64 (comparison -> bitwise_or .)
    IDENTIFIER      reduce using rule 64 (comparison -> bitwise_or .)
    RETURN          reduce using rule 64 (comparison -> bitwise_or .)
    DEL             reduce using rule 64 (comparison -> bitwise_or .)
    GLOBAL          reduce using rule 64 (comparison -> bitwise_or .)
    ELIF            reduce using rule 64 (comparison -> bitwise_or .)
    ELSE            reduce using rule 64 (comparison -> bitwise_or .)
    DEDENT          reduce using rule 64 (comparison -> bitwise_or .)
    R_SQB           reduce using rule 64 (comparison -> bitwise_or .)
    R_PARENTHESIS   reduce using rule 64 (comparison -> bitwise_or .)
    BITWISE_OR      shift and go to state 88
    EQUALITY        shift and go to state 90
    INEQUALITY      shift and go to state 91
    GREATER_EQUAL   shift and go to state 92
    LESSER_EQUAL    shift and go to state 93
    GREATER         shift and go to state 94
    LESSER          shift and go to state 95
    NOT             shift and go to state 96
    IS              shift and go to state 98
    IN              shift and go to state 97

    compare_op_list                shift and go to state 87
    compare_op                     shift and go to state 89

state 49

    (79) bitwise_or -> bitwise_xor .
    (80) bitwise_xor -> bitwise_xor . BITWISE_XOR bitwise_and

    BITWISE_OR      reduce using rule 79 (bitwise_or -> bitwise_xor .)
    EQUALITY        reduce using rule 79 (bitwise_or -> bitwise_xor .)
    INEQUALITY      reduce using rule 79 (bitwise_or -> bitwise_xor .)
    GREATER_EQUAL   reduce using rule 79 (bitwise_or -> bitwise_xor .)
    LESSER_EQUAL    reduce using rule 79 (bitwise_or -> bitwise_xor .)
    GREATER         reduce using rule 79 (bitwise_or -> bitwise_xor .)
    LESSER          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    NOT             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IS              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IN              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    AND             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    OR              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IF              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    COLON           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    COMMA           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    NEWLINE         reduce using rule 79 (bitwise_or -> bitwise_xor .)
    SEMICOLON       reduce using rule 79 (bitwise_or -> bitwise_xor .)
    ENDMARKER       reduce using rule 79 (bitwise_or -> bitwise_xor .)
    DEF             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    CLASS           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    FOR             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    WHILE           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    PASS            reduce using rule 79 (bitwise_or -> bitwise_xor .)
    BREAK           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    CONTINUE        reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IDENTIFIER      reduce using rule 79 (bitwise_or -> bitwise_xor .)
    RETURN          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    DEL             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    GLOBAL          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    ELIF            reduce using rule 79 (bitwise_or -> bitwise_xor .)
    ELSE            reduce using rule 79 (bitwise_or -> bitwise_xor .)
    DEDENT          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    R_SQB           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    R_PARENTHESIS   reduce using rule 79 (bitwise_or -> bitwise_xor .)
    BITWISE_XOR     shift and go to state 99


state 50

    (81) bitwise_xor -> bitwise_and .
    (82) bitwise_and -> bitwise_and . BITWISE_AND shift_expr

    BITWISE_XOR     reduce using rule 81 (bitwise_xor -> bitwise_and .)
    BITWISE_OR      reduce using rule 81 (bitwise_xor -> bitwise_and .)
    EQUALITY        reduce using rule 81 (bitwise_xor -> bitwise_and .)
    INEQUALITY      reduce using rule 81 (bitwise_xor -> bitwise_and .)
    GREATER_EQUAL   reduce using rule 81 (bitwise_xor -> bitwise_and .)
    LESSER_EQUAL    reduce using rule 81 (bitwise_xor -> bitwise_and .)
    GREATER         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    LESSER          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    NOT             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IS              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IN              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    AND             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    OR              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IF              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    COLON           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    COMMA           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    NEWLINE         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    SEMICOLON       reduce using rule 81 (bitwise_xor -> bitwise_and .)
    ENDMARKER       reduce using rule 81 (bitwise_xor -> bitwise_and .)
    DEF             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    CLASS           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    FOR             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    WHILE           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    PASS            reduce using rule 81 (bitwise_xor -> bitwise_and .)
    BREAK           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    CONTINUE        reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IDENTIFIER      reduce using rule 81 (bitwise_xor -> bitwise_and .)
    RETURN          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    DEL             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    GLOBAL          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    ELIF            reduce using rule 81 (bitwise_xor -> bitwise_and .)
    ELSE            reduce using rule 81 (bitwise_xor -> bitwise_and .)
    DEDENT          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    R_SQB           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    R_PARENTHESIS   reduce using rule 81 (bitwise_xor -> bitwise_and .)
    BITWISE_AND     shift and go to state 100


state 51

    (83) bitwise_and -> shift_expr .
    (84) shift_expr -> shift_expr . L_SHIFT sum
    (85) shift_expr -> shift_expr . R_SHIFT sum

    BITWISE_AND     reduce using rule 83 (bitwise_and -> shift_expr .)
    BITWISE_XOR     reduce using rule 83 (bitwise_and -> shift_expr .)
    BITWISE_OR      reduce using rule 83 (bitwise_and -> shift_expr .)
    EQUALITY        reduce using rule 83 (bitwise_and -> shift_expr .)
    INEQUALITY      reduce using rule 83 (bitwise_and -> shift_expr .)
    GREATER_EQUAL   reduce using rule 83 (bitwise_and -> shift_expr .)
    LESSER_EQUAL    reduce using rule 83 (bitwise_and -> shift_expr .)
    GREATER         reduce using rule 83 (bitwise_and -> shift_expr .)
    LESSER          reduce using rule 83 (bitwise_and -> shift_expr .)
    NOT             reduce using rule 83 (bitwise_and -> shift_expr .)
    IS              reduce using rule 83 (bitwise_and -> shift_expr .)
    IN              reduce using rule 83 (bitwise_and -> shift_expr .)
    AND             reduce using rule 83 (bitwise_and -> shift_expr .)
    OR              reduce using rule 83 (bitwise_and -> shift_expr .)
    IF              reduce using rule 83 (bitwise_and -> shift_expr .)
    COLON           reduce using rule 83 (bitwise_and -> shift_expr .)
    COMMA           reduce using rule 83 (bitwise_and -> shift_expr .)
    NEWLINE         reduce using rule 83 (bitwise_and -> shift_expr .)
    SEMICOLON       reduce using rule 83 (bitwise_and -> shift_expr .)
    ENDMARKER       reduce using rule 83 (bitwise_and -> shift_expr .)
    DEF             reduce using rule 83 (bitwise_and -> shift_expr .)
    CLASS           reduce using rule 83 (bitwise_and -> shift_expr .)
    FOR             reduce using rule 83 (bitwise_and -> shift_expr .)
    WHILE           reduce using rule 83 (bitwise_and -> shift_expr .)
    PASS            reduce using rule 83 (bitwise_and -> shift_expr .)
    BREAK           reduce using rule 83 (bitwise_and -> shift_expr .)
    CONTINUE        reduce using rule 83 (bitwise_and -> shift_expr .)
    IDENTIFIER      reduce using rule 83 (bitwise_and -> shift_expr .)
    RETURN          reduce using rule 83 (bitwise_and -> shift_expr .)
    DEL             reduce using rule 83 (bitwise_and -> shift_expr .)
    GLOBAL          reduce using rule 83 (bitwise_and -> shift_expr .)
    ELIF            reduce using rule 83 (bitwise_and -> shift_expr .)
    ELSE            reduce using rule 83 (bitwise_and -> shift_expr .)
    DEDENT          reduce using rule 83 (bitwise_and -> shift_expr .)
    R_SQB           reduce using rule 83 (bitwise_and -> shift_expr .)
    R_PARENTHESIS   reduce using rule 83 (bitwise_and -> shift_expr .)
    L_SHIFT         shift and go to state 101
    R_SHIFT         shift and go to state 102


state 52

    (86) shift_expr -> sum .
    (87) sum -> sum . SUM term
    (88) sum -> sum . SUBTRACTION term

    L_SHIFT         reduce using rule 86 (shift_expr -> sum .)
    R_SHIFT         reduce using rule 86 (shift_expr -> sum .)
    BITWISE_AND     reduce using rule 86 (shift_expr -> sum .)
    BITWISE_XOR     reduce using rule 86 (shift_expr -> sum .)
    BITWISE_OR      reduce using rule 86 (shift_expr -> sum .)
    EQUALITY        reduce using rule 86 (shift_expr -> sum .)
    INEQUALITY      reduce using rule 86 (shift_expr -> sum .)
    GREATER_EQUAL   reduce using rule 86 (shift_expr -> sum .)
    LESSER_EQUAL    reduce using rule 86 (shift_expr -> sum .)
    GREATER         reduce using rule 86 (shift_expr -> sum .)
    LESSER          reduce using rule 86 (shift_expr -> sum .)
    NOT             reduce using rule 86 (shift_expr -> sum .)
    IS              reduce using rule 86 (shift_expr -> sum .)
    IN              reduce using rule 86 (shift_expr -> sum .)
    AND             reduce using rule 86 (shift_expr -> sum .)
    OR              reduce using rule 86 (shift_expr -> sum .)
    IF              reduce using rule 86 (shift_expr -> sum .)
    COLON           reduce using rule 86 (shift_expr -> sum .)
    COMMA           reduce using rule 86 (shift_expr -> sum .)
    NEWLINE         reduce using rule 86 (shift_expr -> sum .)
    SEMICOLON       reduce using rule 86 (shift_expr -> sum .)
    ENDMARKER       reduce using rule 86 (shift_expr -> sum .)
    DEF             reduce using rule 86 (shift_expr -> sum .)
    CLASS           reduce using rule 86 (shift_expr -> sum .)
    FOR             reduce using rule 86 (shift_expr -> sum .)
    WHILE           reduce using rule 86 (shift_expr -> sum .)
    PASS            reduce using rule 86 (shift_expr -> sum .)
    BREAK           reduce using rule 86 (shift_expr -> sum .)
    CONTINUE        reduce using rule 86 (shift_expr -> sum .)
    IDENTIFIER      reduce using rule 86 (shift_expr -> sum .)
    RETURN          reduce using rule 86 (shift_expr -> sum .)
    DEL             reduce using rule 86 (shift_expr -> sum .)
    GLOBAL          reduce using rule 86 (shift_expr -> sum .)
    ELIF            reduce using rule 86 (shift_expr -> sum .)
    ELSE            reduce using rule 86 (shift_expr -> sum .)
    DEDENT          reduce using rule 86 (shift_expr -> sum .)
    R_SQB           reduce using rule 86 (shift_expr -> sum .)
    R_PARENTHESIS   reduce using rule 86 (shift_expr -> sum .)
    SUM             shift and go to state 103
    SUBTRACTION     shift and go to state 104


state 53

    (95) factor -> SUM . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    factor                         shift and go to state 105
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 54

    (89) sum -> term .
    (90) term -> term . PRODUCT factor
    (91) term -> term . DIVISION factor
    (92) term -> term . INTEGER_DIVISION factor
    (93) term -> term . MODULUS factor

    SUM             reduce using rule 89 (sum -> term .)
    SUBTRACTION     reduce using rule 89 (sum -> term .)
    L_SHIFT         reduce using rule 89 (sum -> term .)
    R_SHIFT         reduce using rule 89 (sum -> term .)
    BITWISE_AND     reduce using rule 89 (sum -> term .)
    BITWISE_XOR     reduce using rule 89 (sum -> term .)
    BITWISE_OR      reduce using rule 89 (sum -> term .)
    EQUALITY        reduce using rule 89 (sum -> term .)
    INEQUALITY      reduce using rule 89 (sum -> term .)
    GREATER_EQUAL   reduce using rule 89 (sum -> term .)
    LESSER_EQUAL    reduce using rule 89 (sum -> term .)
    GREATER         reduce using rule 89 (sum -> term .)
    LESSER          reduce using rule 89 (sum -> term .)
    NOT             reduce using rule 89 (sum -> term .)
    IS              reduce using rule 89 (sum -> term .)
    IN              reduce using rule 89 (sum -> term .)
    AND             reduce using rule 89 (sum -> term .)
    OR              reduce using rule 89 (sum -> term .)
    IF              reduce using rule 89 (sum -> term .)
    COLON           reduce using rule 89 (sum -> term .)
    COMMA           reduce using rule 89 (sum -> term .)
    NEWLINE         reduce using rule 89 (sum -> term .)
    SEMICOLON       reduce using rule 89 (sum -> term .)
    ENDMARKER       reduce using rule 89 (sum -> term .)
    DEF             reduce using rule 89 (sum -> term .)
    CLASS           reduce using rule 89 (sum -> term .)
    FOR             reduce using rule 89 (sum -> term .)
    WHILE           reduce using rule 89 (sum -> term .)
    PASS            reduce using rule 89 (sum -> term .)
    BREAK           reduce using rule 89 (sum -> term .)
    CONTINUE        reduce using rule 89 (sum -> term .)
    IDENTIFIER      reduce using rule 89 (sum -> term .)
    RETURN          reduce using rule 89 (sum -> term .)
    DEL             reduce using rule 89 (sum -> term .)
    GLOBAL          reduce using rule 89 (sum -> term .)
    ELIF            reduce using rule 89 (sum -> term .)
    ELSE            reduce using rule 89 (sum -> term .)
    DEDENT          reduce using rule 89 (sum -> term .)
    R_SQB           reduce using rule 89 (sum -> term .)
    R_PARENTHESIS   reduce using rule 89 (sum -> term .)
    PRODUCT         shift and go to state 106
    DIVISION        shift and go to state 107
    INTEGER_DIVISION shift and go to state 108
    MODULUS         shift and go to state 109


state 55

    (96) factor -> SUBTRACTION . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    factor                         shift and go to state 110
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 56

    (94) term -> factor .

    PRODUCT         reduce using rule 94 (term -> factor .)
    DIVISION        reduce using rule 94 (term -> factor .)
    INTEGER_DIVISION reduce using rule 94 (term -> factor .)
    MODULUS         reduce using rule 94 (term -> factor .)
    SUM             reduce using rule 94 (term -> factor .)
    SUBTRACTION     reduce using rule 94 (term -> factor .)
    L_SHIFT         reduce using rule 94 (term -> factor .)
    R_SHIFT         reduce using rule 94 (term -> factor .)
    BITWISE_AND     reduce using rule 94 (term -> factor .)
    BITWISE_XOR     reduce using rule 94 (term -> factor .)
    BITWISE_OR      reduce using rule 94 (term -> factor .)
    EQUALITY        reduce using rule 94 (term -> factor .)
    INEQUALITY      reduce using rule 94 (term -> factor .)
    GREATER_EQUAL   reduce using rule 94 (term -> factor .)
    LESSER_EQUAL    reduce using rule 94 (term -> factor .)
    GREATER         reduce using rule 94 (term -> factor .)
    LESSER          reduce using rule 94 (term -> factor .)
    NOT             reduce using rule 94 (term -> factor .)
    IS              reduce using rule 94 (term -> factor .)
    IN              reduce using rule 94 (term -> factor .)
    AND             reduce using rule 94 (term -> factor .)
    OR              reduce using rule 94 (term -> factor .)
    IF              reduce using rule 94 (term -> factor .)
    COLON           reduce using rule 94 (term -> factor .)
    COMMA           reduce using rule 94 (term -> factor .)
    NEWLINE         reduce using rule 94 (term -> factor .)
    SEMICOLON       reduce using rule 94 (term -> factor .)
    ENDMARKER       reduce using rule 94 (term -> factor .)
    DEF             reduce using rule 94 (term -> factor .)
    CLASS           reduce using rule 94 (term -> factor .)
    FOR             reduce using rule 94 (term -> factor .)
    WHILE           reduce using rule 94 (term -> factor .)
    PASS            reduce using rule 94 (term -> factor .)
    BREAK           reduce using rule 94 (term -> factor .)
    CONTINUE        reduce using rule 94 (term -> factor .)
    IDENTIFIER      reduce using rule 94 (term -> factor .)
    RETURN          reduce using rule 94 (term -> factor .)
    DEL             reduce using rule 94 (term -> factor .)
    GLOBAL          reduce using rule 94 (term -> factor .)
    ELIF            reduce using rule 94 (term -> factor .)
    ELSE            reduce using rule 94 (term -> factor .)
    DEDENT          reduce using rule 94 (term -> factor .)
    R_SQB           reduce using rule 94 (term -> factor .)
    R_PARENTHESIS   reduce using rule 94 (term -> factor .)


state 57

    (97) factor -> power .

    PRODUCT         reduce using rule 97 (factor -> power .)
    DIVISION        reduce using rule 97 (factor -> power .)
    INTEGER_DIVISION reduce using rule 97 (factor -> power .)
    MODULUS         reduce using rule 97 (factor -> power .)
    SUM             reduce using rule 97 (factor -> power .)
    SUBTRACTION     reduce using rule 97 (factor -> power .)
    L_SHIFT         reduce using rule 97 (factor -> power .)
    R_SHIFT         reduce using rule 97 (factor -> power .)
    BITWISE_AND     reduce using rule 97 (factor -> power .)
    BITWISE_XOR     reduce using rule 97 (factor -> power .)
    BITWISE_OR      reduce using rule 97 (factor -> power .)
    EQUALITY        reduce using rule 97 (factor -> power .)
    INEQUALITY      reduce using rule 97 (factor -> power .)
    GREATER_EQUAL   reduce using rule 97 (factor -> power .)
    LESSER_EQUAL    reduce using rule 97 (factor -> power .)
    GREATER         reduce using rule 97 (factor -> power .)
    LESSER          reduce using rule 97 (factor -> power .)
    NOT             reduce using rule 97 (factor -> power .)
    IS              reduce using rule 97 (factor -> power .)
    IN              reduce using rule 97 (factor -> power .)
    AND             reduce using rule 97 (factor -> power .)
    OR              reduce using rule 97 (factor -> power .)
    IF              reduce using rule 97 (factor -> power .)
    COLON           reduce using rule 97 (factor -> power .)
    COMMA           reduce using rule 97 (factor -> power .)
    NEWLINE         reduce using rule 97 (factor -> power .)
    SEMICOLON       reduce using rule 97 (factor -> power .)
    ENDMARKER       reduce using rule 97 (factor -> power .)
    DEF             reduce using rule 97 (factor -> power .)
    CLASS           reduce using rule 97 (factor -> power .)
    FOR             reduce using rule 97 (factor -> power .)
    WHILE           reduce using rule 97 (factor -> power .)
    PASS            reduce using rule 97 (factor -> power .)
    BREAK           reduce using rule 97 (factor -> power .)
    CONTINUE        reduce using rule 97 (factor -> power .)
    IDENTIFIER      reduce using rule 97 (factor -> power .)
    RETURN          reduce using rule 97 (factor -> power .)
    DEL             reduce using rule 97 (factor -> power .)
    GLOBAL          reduce using rule 97 (factor -> power .)
    ELIF            reduce using rule 97 (factor -> power .)
    ELSE            reduce using rule 97 (factor -> power .)
    DEDENT          reduce using rule 97 (factor -> power .)
    R_SQB           reduce using rule 97 (factor -> power .)
    R_PARENTHESIS   reduce using rule 97 (factor -> power .)


state 58

    (98) power -> primary . EXPONENTIATION target
    (99) power -> primary .
    (100) primary -> primary . DOT IDENTIFIER
    (101) primary -> primary . L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> primary . L_SQB slices R_SQB

    EXPONENTIATION  shift and go to state 111
    PRODUCT         reduce using rule 99 (power -> primary .)
    DIVISION        reduce using rule 99 (power -> primary .)
    INTEGER_DIVISION reduce using rule 99 (power -> primary .)
    MODULUS         reduce using rule 99 (power -> primary .)
    SUM             reduce using rule 99 (power -> primary .)
    SUBTRACTION     reduce using rule 99 (power -> primary .)
    L_SHIFT         reduce using rule 99 (power -> primary .)
    R_SHIFT         reduce using rule 99 (power -> primary .)
    BITWISE_AND     reduce using rule 99 (power -> primary .)
    BITWISE_XOR     reduce using rule 99 (power -> primary .)
    BITWISE_OR      reduce using rule 99 (power -> primary .)
    EQUALITY        reduce using rule 99 (power -> primary .)
    INEQUALITY      reduce using rule 99 (power -> primary .)
    GREATER_EQUAL   reduce using rule 99 (power -> primary .)
    LESSER_EQUAL    reduce using rule 99 (power -> primary .)
    GREATER         reduce using rule 99 (power -> primary .)
    LESSER          reduce using rule 99 (power -> primary .)
    NOT             reduce using rule 99 (power -> primary .)
    IS              reduce using rule 99 (power -> primary .)
    IN              reduce using rule 99 (power -> primary .)
    AND             reduce using rule 99 (power -> primary .)
    OR              reduce using rule 99 (power -> primary .)
    IF              reduce using rule 99 (power -> primary .)
    COLON           reduce using rule 99 (power -> primary .)
    COMMA           reduce using rule 99 (power -> primary .)
    NEWLINE         reduce using rule 99 (power -> primary .)
    SEMICOLON       reduce using rule 99 (power -> primary .)
    ENDMARKER       reduce using rule 99 (power -> primary .)
    DEF             reduce using rule 99 (power -> primary .)
    CLASS           reduce using rule 99 (power -> primary .)
    FOR             reduce using rule 99 (power -> primary .)
    WHILE           reduce using rule 99 (power -> primary .)
    PASS            reduce using rule 99 (power -> primary .)
    BREAK           reduce using rule 99 (power -> primary .)
    CONTINUE        reduce using rule 99 (power -> primary .)
    IDENTIFIER      reduce using rule 99 (power -> primary .)
    RETURN          reduce using rule 99 (power -> primary .)
    DEL             reduce using rule 99 (power -> primary .)
    GLOBAL          reduce using rule 99 (power -> primary .)
    ELIF            reduce using rule 99 (power -> primary .)
    ELSE            reduce using rule 99 (power -> primary .)
    DEDENT          reduce using rule 99 (power -> primary .)
    R_SQB           reduce using rule 99 (power -> primary .)
    R_PARENTHESIS   reduce using rule 99 (power -> primary .)
    DOT             shift and go to state 112
    L_PARENTHESIS   shift and go to state 113
    L_SQB           shift and go to state 114


state 59

    (107) atomic -> IDENTIFIER .

    EXPONENTIATION  reduce using rule 107 (atomic -> IDENTIFIER .)
    DOT             reduce using rule 107 (atomic -> IDENTIFIER .)
    L_PARENTHESIS   reduce using rule 107 (atomic -> IDENTIFIER .)
    L_SQB           reduce using rule 107 (atomic -> IDENTIFIER .)
    PRODUCT         reduce using rule 107 (atomic -> IDENTIFIER .)
    DIVISION        reduce using rule 107 (atomic -> IDENTIFIER .)
    INTEGER_DIVISION reduce using rule 107 (atomic -> IDENTIFIER .)
    MODULUS         reduce using rule 107 (atomic -> IDENTIFIER .)
    SUM             reduce using rule 107 (atomic -> IDENTIFIER .)
    SUBTRACTION     reduce using rule 107 (atomic -> IDENTIFIER .)
    L_SHIFT         reduce using rule 107 (atomic -> IDENTIFIER .)
    R_SHIFT         reduce using rule 107 (atomic -> IDENTIFIER .)
    BITWISE_AND     reduce using rule 107 (atomic -> IDENTIFIER .)
    BITWISE_XOR     reduce using rule 107 (atomic -> IDENTIFIER .)
    BITWISE_OR      reduce using rule 107 (atomic -> IDENTIFIER .)
    EQUALITY        reduce using rule 107 (atomic -> IDENTIFIER .)
    INEQUALITY      reduce using rule 107 (atomic -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 107 (atomic -> IDENTIFIER .)
    LESSER_EQUAL    reduce using rule 107 (atomic -> IDENTIFIER .)
    GREATER         reduce using rule 107 (atomic -> IDENTIFIER .)
    LESSER          reduce using rule 107 (atomic -> IDENTIFIER .)
    NOT             reduce using rule 107 (atomic -> IDENTIFIER .)
    IS              reduce using rule 107 (atomic -> IDENTIFIER .)
    IN              reduce using rule 107 (atomic -> IDENTIFIER .)
    AND             reduce using rule 107 (atomic -> IDENTIFIER .)
    OR              reduce using rule 107 (atomic -> IDENTIFIER .)
    IF              reduce using rule 107 (atomic -> IDENTIFIER .)
    COLON           reduce using rule 107 (atomic -> IDENTIFIER .)
    COMMA           reduce using rule 107 (atomic -> IDENTIFIER .)
    NEWLINE         reduce using rule 107 (atomic -> IDENTIFIER .)
    SEMICOLON       reduce using rule 107 (atomic -> IDENTIFIER .)
    ENDMARKER       reduce using rule 107 (atomic -> IDENTIFIER .)
    DEF             reduce using rule 107 (atomic -> IDENTIFIER .)
    CLASS           reduce using rule 107 (atomic -> IDENTIFIER .)
    FOR             reduce using rule 107 (atomic -> IDENTIFIER .)
    WHILE           reduce using rule 107 (atomic -> IDENTIFIER .)
    PASS            reduce using rule 107 (atomic -> IDENTIFIER .)
    BREAK           reduce using rule 107 (atomic -> IDENTIFIER .)
    CONTINUE        reduce using rule 107 (atomic -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 107 (atomic -> IDENTIFIER .)
    RETURN          reduce using rule 107 (atomic -> IDENTIFIER .)
    DEL             reduce using rule 107 (atomic -> IDENTIFIER .)
    GLOBAL          reduce using rule 107 (atomic -> IDENTIFIER .)
    ELIF            reduce using rule 107 (atomic -> IDENTIFIER .)
    ELSE            reduce using rule 107 (atomic -> IDENTIFIER .)
    DEDENT          reduce using rule 107 (atomic -> IDENTIFIER .)
    R_SQB           reduce using rule 107 (atomic -> IDENTIFIER .)
    R_PARENTHESIS   reduce using rule 107 (atomic -> IDENTIFIER .)


state 60

    (103) primary -> atomic .

    EXPONENTIATION  reduce using rule 103 (primary -> atomic .)
    DOT             reduce using rule 103 (primary -> atomic .)
    L_PARENTHESIS   reduce using rule 103 (primary -> atomic .)
    L_SQB           reduce using rule 103 (primary -> atomic .)
    PRODUCT         reduce using rule 103 (primary -> atomic .)
    DIVISION        reduce using rule 103 (primary -> atomic .)
    INTEGER_DIVISION reduce using rule 103 (primary -> atomic .)
    MODULUS         reduce using rule 103 (primary -> atomic .)
    SUM             reduce using rule 103 (primary -> atomic .)
    SUBTRACTION     reduce using rule 103 (primary -> atomic .)
    L_SHIFT         reduce using rule 103 (primary -> atomic .)
    R_SHIFT         reduce using rule 103 (primary -> atomic .)
    BITWISE_AND     reduce using rule 103 (primary -> atomic .)
    BITWISE_XOR     reduce using rule 103 (primary -> atomic .)
    BITWISE_OR      reduce using rule 103 (primary -> atomic .)
    EQUALITY        reduce using rule 103 (primary -> atomic .)
    INEQUALITY      reduce using rule 103 (primary -> atomic .)
    GREATER_EQUAL   reduce using rule 103 (primary -> atomic .)
    LESSER_EQUAL    reduce using rule 103 (primary -> atomic .)
    GREATER         reduce using rule 103 (primary -> atomic .)
    LESSER          reduce using rule 103 (primary -> atomic .)
    NOT             reduce using rule 103 (primary -> atomic .)
    IS              reduce using rule 103 (primary -> atomic .)
    IN              reduce using rule 103 (primary -> atomic .)
    AND             reduce using rule 103 (primary -> atomic .)
    OR              reduce using rule 103 (primary -> atomic .)
    IF              reduce using rule 103 (primary -> atomic .)
    COLON           reduce using rule 103 (primary -> atomic .)
    COMMA           reduce using rule 103 (primary -> atomic .)
    NEWLINE         reduce using rule 103 (primary -> atomic .)
    SEMICOLON       reduce using rule 103 (primary -> atomic .)
    ENDMARKER       reduce using rule 103 (primary -> atomic .)
    DEF             reduce using rule 103 (primary -> atomic .)
    CLASS           reduce using rule 103 (primary -> atomic .)
    FOR             reduce using rule 103 (primary -> atomic .)
    WHILE           reduce using rule 103 (primary -> atomic .)
    PASS            reduce using rule 103 (primary -> atomic .)
    BREAK           reduce using rule 103 (primary -> atomic .)
    CONTINUE        reduce using rule 103 (primary -> atomic .)
    IDENTIFIER      reduce using rule 103 (primary -> atomic .)
    RETURN          reduce using rule 103 (primary -> atomic .)
    DEL             reduce using rule 103 (primary -> atomic .)
    GLOBAL          reduce using rule 103 (primary -> atomic .)
    ELIF            reduce using rule 103 (primary -> atomic .)
    ELSE            reduce using rule 103 (primary -> atomic .)
    DEDENT          reduce using rule 103 (primary -> atomic .)
    R_SQB           reduce using rule 103 (primary -> atomic .)
    R_PARENTHESIS   reduce using rule 103 (primary -> atomic .)


state 61

    (108) atomic -> TRUE .

    EXPONENTIATION  reduce using rule 108 (atomic -> TRUE .)
    DOT             reduce using rule 108 (atomic -> TRUE .)
    L_PARENTHESIS   reduce using rule 108 (atomic -> TRUE .)
    L_SQB           reduce using rule 108 (atomic -> TRUE .)
    PRODUCT         reduce using rule 108 (atomic -> TRUE .)
    DIVISION        reduce using rule 108 (atomic -> TRUE .)
    INTEGER_DIVISION reduce using rule 108 (atomic -> TRUE .)
    MODULUS         reduce using rule 108 (atomic -> TRUE .)
    SUM             reduce using rule 108 (atomic -> TRUE .)
    SUBTRACTION     reduce using rule 108 (atomic -> TRUE .)
    L_SHIFT         reduce using rule 108 (atomic -> TRUE .)
    R_SHIFT         reduce using rule 108 (atomic -> TRUE .)
    BITWISE_AND     reduce using rule 108 (atomic -> TRUE .)
    BITWISE_XOR     reduce using rule 108 (atomic -> TRUE .)
    BITWISE_OR      reduce using rule 108 (atomic -> TRUE .)
    EQUALITY        reduce using rule 108 (atomic -> TRUE .)
    INEQUALITY      reduce using rule 108 (atomic -> TRUE .)
    GREATER_EQUAL   reduce using rule 108 (atomic -> TRUE .)
    LESSER_EQUAL    reduce using rule 108 (atomic -> TRUE .)
    GREATER         reduce using rule 108 (atomic -> TRUE .)
    LESSER          reduce using rule 108 (atomic -> TRUE .)
    NOT             reduce using rule 108 (atomic -> TRUE .)
    IS              reduce using rule 108 (atomic -> TRUE .)
    IN              reduce using rule 108 (atomic -> TRUE .)
    AND             reduce using rule 108 (atomic -> TRUE .)
    OR              reduce using rule 108 (atomic -> TRUE .)
    IF              reduce using rule 108 (atomic -> TRUE .)
    COLON           reduce using rule 108 (atomic -> TRUE .)
    COMMA           reduce using rule 108 (atomic -> TRUE .)
    NEWLINE         reduce using rule 108 (atomic -> TRUE .)
    SEMICOLON       reduce using rule 108 (atomic -> TRUE .)
    ENDMARKER       reduce using rule 108 (atomic -> TRUE .)
    DEF             reduce using rule 108 (atomic -> TRUE .)
    CLASS           reduce using rule 108 (atomic -> TRUE .)
    FOR             reduce using rule 108 (atomic -> TRUE .)
    WHILE           reduce using rule 108 (atomic -> TRUE .)
    PASS            reduce using rule 108 (atomic -> TRUE .)
    BREAK           reduce using rule 108 (atomic -> TRUE .)
    CONTINUE        reduce using rule 108 (atomic -> TRUE .)
    IDENTIFIER      reduce using rule 108 (atomic -> TRUE .)
    RETURN          reduce using rule 108 (atomic -> TRUE .)
    DEL             reduce using rule 108 (atomic -> TRUE .)
    GLOBAL          reduce using rule 108 (atomic -> TRUE .)
    ELIF            reduce using rule 108 (atomic -> TRUE .)
    ELSE            reduce using rule 108 (atomic -> TRUE .)
    DEDENT          reduce using rule 108 (atomic -> TRUE .)
    R_SQB           reduce using rule 108 (atomic -> TRUE .)
    R_PARENTHESIS   reduce using rule 108 (atomic -> TRUE .)


state 62

    (109) atomic -> FALSE .

    EXPONENTIATION  reduce using rule 109 (atomic -> FALSE .)
    DOT             reduce using rule 109 (atomic -> FALSE .)
    L_PARENTHESIS   reduce using rule 109 (atomic -> FALSE .)
    L_SQB           reduce using rule 109 (atomic -> FALSE .)
    PRODUCT         reduce using rule 109 (atomic -> FALSE .)
    DIVISION        reduce using rule 109 (atomic -> FALSE .)
    INTEGER_DIVISION reduce using rule 109 (atomic -> FALSE .)
    MODULUS         reduce using rule 109 (atomic -> FALSE .)
    SUM             reduce using rule 109 (atomic -> FALSE .)
    SUBTRACTION     reduce using rule 109 (atomic -> FALSE .)
    L_SHIFT         reduce using rule 109 (atomic -> FALSE .)
    R_SHIFT         reduce using rule 109 (atomic -> FALSE .)
    BITWISE_AND     reduce using rule 109 (atomic -> FALSE .)
    BITWISE_XOR     reduce using rule 109 (atomic -> FALSE .)
    BITWISE_OR      reduce using rule 109 (atomic -> FALSE .)
    EQUALITY        reduce using rule 109 (atomic -> FALSE .)
    INEQUALITY      reduce using rule 109 (atomic -> FALSE .)
    GREATER_EQUAL   reduce using rule 109 (atomic -> FALSE .)
    LESSER_EQUAL    reduce using rule 109 (atomic -> FALSE .)
    GREATER         reduce using rule 109 (atomic -> FALSE .)
    LESSER          reduce using rule 109 (atomic -> FALSE .)
    NOT             reduce using rule 109 (atomic -> FALSE .)
    IS              reduce using rule 109 (atomic -> FALSE .)
    IN              reduce using rule 109 (atomic -> FALSE .)
    AND             reduce using rule 109 (atomic -> FALSE .)
    OR              reduce using rule 109 (atomic -> FALSE .)
    IF              reduce using rule 109 (atomic -> FALSE .)
    COLON           reduce using rule 109 (atomic -> FALSE .)
    COMMA           reduce using rule 109 (atomic -> FALSE .)
    NEWLINE         reduce using rule 109 (atomic -> FALSE .)
    SEMICOLON       reduce using rule 109 (atomic -> FALSE .)
    ENDMARKER       reduce using rule 109 (atomic -> FALSE .)
    DEF             reduce using rule 109 (atomic -> FALSE .)
    CLASS           reduce using rule 109 (atomic -> FALSE .)
    FOR             reduce using rule 109 (atomic -> FALSE .)
    WHILE           reduce using rule 109 (atomic -> FALSE .)
    PASS            reduce using rule 109 (atomic -> FALSE .)
    BREAK           reduce using rule 109 (atomic -> FALSE .)
    CONTINUE        reduce using rule 109 (atomic -> FALSE .)
    IDENTIFIER      reduce using rule 109 (atomic -> FALSE .)
    RETURN          reduce using rule 109 (atomic -> FALSE .)
    DEL             reduce using rule 109 (atomic -> FALSE .)
    GLOBAL          reduce using rule 109 (atomic -> FALSE .)
    ELIF            reduce using rule 109 (atomic -> FALSE .)
    ELSE            reduce using rule 109 (atomic -> FALSE .)
    DEDENT          reduce using rule 109 (atomic -> FALSE .)
    R_SQB           reduce using rule 109 (atomic -> FALSE .)
    R_PARENTHESIS   reduce using rule 109 (atomic -> FALSE .)


state 63

    (110) atomic -> NONE .

    EXPONENTIATION  reduce using rule 110 (atomic -> NONE .)
    DOT             reduce using rule 110 (atomic -> NONE .)
    L_PARENTHESIS   reduce using rule 110 (atomic -> NONE .)
    L_SQB           reduce using rule 110 (atomic -> NONE .)
    PRODUCT         reduce using rule 110 (atomic -> NONE .)
    DIVISION        reduce using rule 110 (atomic -> NONE .)
    INTEGER_DIVISION reduce using rule 110 (atomic -> NONE .)
    MODULUS         reduce using rule 110 (atomic -> NONE .)
    SUM             reduce using rule 110 (atomic -> NONE .)
    SUBTRACTION     reduce using rule 110 (atomic -> NONE .)
    L_SHIFT         reduce using rule 110 (atomic -> NONE .)
    R_SHIFT         reduce using rule 110 (atomic -> NONE .)
    BITWISE_AND     reduce using rule 110 (atomic -> NONE .)
    BITWISE_XOR     reduce using rule 110 (atomic -> NONE .)
    BITWISE_OR      reduce using rule 110 (atomic -> NONE .)
    EQUALITY        reduce using rule 110 (atomic -> NONE .)
    INEQUALITY      reduce using rule 110 (atomic -> NONE .)
    GREATER_EQUAL   reduce using rule 110 (atomic -> NONE .)
    LESSER_EQUAL    reduce using rule 110 (atomic -> NONE .)
    GREATER         reduce using rule 110 (atomic -> NONE .)
    LESSER          reduce using rule 110 (atomic -> NONE .)
    NOT             reduce using rule 110 (atomic -> NONE .)
    IS              reduce using rule 110 (atomic -> NONE .)
    IN              reduce using rule 110 (atomic -> NONE .)
    AND             reduce using rule 110 (atomic -> NONE .)
    OR              reduce using rule 110 (atomic -> NONE .)
    IF              reduce using rule 110 (atomic -> NONE .)
    COLON           reduce using rule 110 (atomic -> NONE .)
    COMMA           reduce using rule 110 (atomic -> NONE .)
    NEWLINE         reduce using rule 110 (atomic -> NONE .)
    SEMICOLON       reduce using rule 110 (atomic -> NONE .)
    ENDMARKER       reduce using rule 110 (atomic -> NONE .)
    DEF             reduce using rule 110 (atomic -> NONE .)
    CLASS           reduce using rule 110 (atomic -> NONE .)
    FOR             reduce using rule 110 (atomic -> NONE .)
    WHILE           reduce using rule 110 (atomic -> NONE .)
    PASS            reduce using rule 110 (atomic -> NONE .)
    BREAK           reduce using rule 110 (atomic -> NONE .)
    CONTINUE        reduce using rule 110 (atomic -> NONE .)
    IDENTIFIER      reduce using rule 110 (atomic -> NONE .)
    RETURN          reduce using rule 110 (atomic -> NONE .)
    DEL             reduce using rule 110 (atomic -> NONE .)
    GLOBAL          reduce using rule 110 (atomic -> NONE .)
    ELIF            reduce using rule 110 (atomic -> NONE .)
    ELSE            reduce using rule 110 (atomic -> NONE .)
    DEDENT          reduce using rule 110 (atomic -> NONE .)
    R_SQB           reduce using rule 110 (atomic -> NONE .)
    R_PARENTHESIS   reduce using rule 110 (atomic -> NONE .)


state 64

    (111) atomic -> strings .

    EXPONENTIATION  reduce using rule 111 (atomic -> strings .)
    DOT             reduce using rule 111 (atomic -> strings .)
    L_PARENTHESIS   reduce using rule 111 (atomic -> strings .)
    L_SQB           reduce using rule 111 (atomic -> strings .)
    PRODUCT         reduce using rule 111 (atomic -> strings .)
    DIVISION        reduce using rule 111 (atomic -> strings .)
    INTEGER_DIVISION reduce using rule 111 (atomic -> strings .)
    MODULUS         reduce using rule 111 (atomic -> strings .)
    SUM             reduce using rule 111 (atomic -> strings .)
    SUBTRACTION     reduce using rule 111 (atomic -> strings .)
    L_SHIFT         reduce using rule 111 (atomic -> strings .)
    R_SHIFT         reduce using rule 111 (atomic -> strings .)
    BITWISE_AND     reduce using rule 111 (atomic -> strings .)
    BITWISE_XOR     reduce using rule 111 (atomic -> strings .)
    BITWISE_OR      reduce using rule 111 (atomic -> strings .)
    EQUALITY        reduce using rule 111 (atomic -> strings .)
    INEQUALITY      reduce using rule 111 (atomic -> strings .)
    GREATER_EQUAL   reduce using rule 111 (atomic -> strings .)
    LESSER_EQUAL    reduce using rule 111 (atomic -> strings .)
    GREATER         reduce using rule 111 (atomic -> strings .)
    LESSER          reduce using rule 111 (atomic -> strings .)
    NOT             reduce using rule 111 (atomic -> strings .)
    IS              reduce using rule 111 (atomic -> strings .)
    IN              reduce using rule 111 (atomic -> strings .)
    AND             reduce using rule 111 (atomic -> strings .)
    OR              reduce using rule 111 (atomic -> strings .)
    IF              reduce using rule 111 (atomic -> strings .)
    COLON           reduce using rule 111 (atomic -> strings .)
    COMMA           reduce using rule 111 (atomic -> strings .)
    NEWLINE         reduce using rule 111 (atomic -> strings .)
    SEMICOLON       reduce using rule 111 (atomic -> strings .)
    ENDMARKER       reduce using rule 111 (atomic -> strings .)
    DEF             reduce using rule 111 (atomic -> strings .)
    CLASS           reduce using rule 111 (atomic -> strings .)
    FOR             reduce using rule 111 (atomic -> strings .)
    WHILE           reduce using rule 111 (atomic -> strings .)
    PASS            reduce using rule 111 (atomic -> strings .)
    BREAK           reduce using rule 111 (atomic -> strings .)
    CONTINUE        reduce using rule 111 (atomic -> strings .)
    IDENTIFIER      reduce using rule 111 (atomic -> strings .)
    RETURN          reduce using rule 111 (atomic -> strings .)
    DEL             reduce using rule 111 (atomic -> strings .)
    GLOBAL          reduce using rule 111 (atomic -> strings .)
    ELIF            reduce using rule 111 (atomic -> strings .)
    ELSE            reduce using rule 111 (atomic -> strings .)
    DEDENT          reduce using rule 111 (atomic -> strings .)
    R_SQB           reduce using rule 111 (atomic -> strings .)
    R_PARENTHESIS   reduce using rule 111 (atomic -> strings .)


state 65

    (112) atomic -> NUMBER .

    EXPONENTIATION  reduce using rule 112 (atomic -> NUMBER .)
    DOT             reduce using rule 112 (atomic -> NUMBER .)
    L_PARENTHESIS   reduce using rule 112 (atomic -> NUMBER .)
    L_SQB           reduce using rule 112 (atomic -> NUMBER .)
    PRODUCT         reduce using rule 112 (atomic -> NUMBER .)
    DIVISION        reduce using rule 112 (atomic -> NUMBER .)
    INTEGER_DIVISION reduce using rule 112 (atomic -> NUMBER .)
    MODULUS         reduce using rule 112 (atomic -> NUMBER .)
    SUM             reduce using rule 112 (atomic -> NUMBER .)
    SUBTRACTION     reduce using rule 112 (atomic -> NUMBER .)
    L_SHIFT         reduce using rule 112 (atomic -> NUMBER .)
    R_SHIFT         reduce using rule 112 (atomic -> NUMBER .)
    BITWISE_AND     reduce using rule 112 (atomic -> NUMBER .)
    BITWISE_XOR     reduce using rule 112 (atomic -> NUMBER .)
    BITWISE_OR      reduce using rule 112 (atomic -> NUMBER .)
    EQUALITY        reduce using rule 112 (atomic -> NUMBER .)
    INEQUALITY      reduce using rule 112 (atomic -> NUMBER .)
    GREATER_EQUAL   reduce using rule 112 (atomic -> NUMBER .)
    LESSER_EQUAL    reduce using rule 112 (atomic -> NUMBER .)
    GREATER         reduce using rule 112 (atomic -> NUMBER .)
    LESSER          reduce using rule 112 (atomic -> NUMBER .)
    NOT             reduce using rule 112 (atomic -> NUMBER .)
    IS              reduce using rule 112 (atomic -> NUMBER .)
    IN              reduce using rule 112 (atomic -> NUMBER .)
    AND             reduce using rule 112 (atomic -> NUMBER .)
    OR              reduce using rule 112 (atomic -> NUMBER .)
    IF              reduce using rule 112 (atomic -> NUMBER .)
    COLON           reduce using rule 112 (atomic -> NUMBER .)
    COMMA           reduce using rule 112 (atomic -> NUMBER .)
    NEWLINE         reduce using rule 112 (atomic -> NUMBER .)
    SEMICOLON       reduce using rule 112 (atomic -> NUMBER .)
    ENDMARKER       reduce using rule 112 (atomic -> NUMBER .)
    DEF             reduce using rule 112 (atomic -> NUMBER .)
    CLASS           reduce using rule 112 (atomic -> NUMBER .)
    FOR             reduce using rule 112 (atomic -> NUMBER .)
    WHILE           reduce using rule 112 (atomic -> NUMBER .)
    PASS            reduce using rule 112 (atomic -> NUMBER .)
    BREAK           reduce using rule 112 (atomic -> NUMBER .)
    CONTINUE        reduce using rule 112 (atomic -> NUMBER .)
    IDENTIFIER      reduce using rule 112 (atomic -> NUMBER .)
    RETURN          reduce using rule 112 (atomic -> NUMBER .)
    DEL             reduce using rule 112 (atomic -> NUMBER .)
    GLOBAL          reduce using rule 112 (atomic -> NUMBER .)
    ELIF            reduce using rule 112 (atomic -> NUMBER .)
    ELSE            reduce using rule 112 (atomic -> NUMBER .)
    DEDENT          reduce using rule 112 (atomic -> NUMBER .)
    R_SQB           reduce using rule 112 (atomic -> NUMBER .)
    R_PARENTHESIS   reduce using rule 112 (atomic -> NUMBER .)


state 66

    (113) atomic -> F_NUMBER .

    EXPONENTIATION  reduce using rule 113 (atomic -> F_NUMBER .)
    DOT             reduce using rule 113 (atomic -> F_NUMBER .)
    L_PARENTHESIS   reduce using rule 113 (atomic -> F_NUMBER .)
    L_SQB           reduce using rule 113 (atomic -> F_NUMBER .)
    PRODUCT         reduce using rule 113 (atomic -> F_NUMBER .)
    DIVISION        reduce using rule 113 (atomic -> F_NUMBER .)
    INTEGER_DIVISION reduce using rule 113 (atomic -> F_NUMBER .)
    MODULUS         reduce using rule 113 (atomic -> F_NUMBER .)
    SUM             reduce using rule 113 (atomic -> F_NUMBER .)
    SUBTRACTION     reduce using rule 113 (atomic -> F_NUMBER .)
    L_SHIFT         reduce using rule 113 (atomic -> F_NUMBER .)
    R_SHIFT         reduce using rule 113 (atomic -> F_NUMBER .)
    BITWISE_AND     reduce using rule 113 (atomic -> F_NUMBER .)
    BITWISE_XOR     reduce using rule 113 (atomic -> F_NUMBER .)
    BITWISE_OR      reduce using rule 113 (atomic -> F_NUMBER .)
    EQUALITY        reduce using rule 113 (atomic -> F_NUMBER .)
    INEQUALITY      reduce using rule 113 (atomic -> F_NUMBER .)
    GREATER_EQUAL   reduce using rule 113 (atomic -> F_NUMBER .)
    LESSER_EQUAL    reduce using rule 113 (atomic -> F_NUMBER .)
    GREATER         reduce using rule 113 (atomic -> F_NUMBER .)
    LESSER          reduce using rule 113 (atomic -> F_NUMBER .)
    NOT             reduce using rule 113 (atomic -> F_NUMBER .)
    IS              reduce using rule 113 (atomic -> F_NUMBER .)
    IN              reduce using rule 113 (atomic -> F_NUMBER .)
    AND             reduce using rule 113 (atomic -> F_NUMBER .)
    OR              reduce using rule 113 (atomic -> F_NUMBER .)
    IF              reduce using rule 113 (atomic -> F_NUMBER .)
    COLON           reduce using rule 113 (atomic -> F_NUMBER .)
    COMMA           reduce using rule 113 (atomic -> F_NUMBER .)
    NEWLINE         reduce using rule 113 (atomic -> F_NUMBER .)
    SEMICOLON       reduce using rule 113 (atomic -> F_NUMBER .)
    ENDMARKER       reduce using rule 113 (atomic -> F_NUMBER .)
    DEF             reduce using rule 113 (atomic -> F_NUMBER .)
    CLASS           reduce using rule 113 (atomic -> F_NUMBER .)
    FOR             reduce using rule 113 (atomic -> F_NUMBER .)
    WHILE           reduce using rule 113 (atomic -> F_NUMBER .)
    PASS            reduce using rule 113 (atomic -> F_NUMBER .)
    BREAK           reduce using rule 113 (atomic -> F_NUMBER .)
    CONTINUE        reduce using rule 113 (atomic -> F_NUMBER .)
    IDENTIFIER      reduce using rule 113 (atomic -> F_NUMBER .)
    RETURN          reduce using rule 113 (atomic -> F_NUMBER .)
    DEL             reduce using rule 113 (atomic -> F_NUMBER .)
    GLOBAL          reduce using rule 113 (atomic -> F_NUMBER .)
    ELIF            reduce using rule 113 (atomic -> F_NUMBER .)
    ELSE            reduce using rule 113 (atomic -> F_NUMBER .)
    DEDENT          reduce using rule 113 (atomic -> F_NUMBER .)
    R_SQB           reduce using rule 113 (atomic -> F_NUMBER .)
    R_PARENTHESIS   reduce using rule 113 (atomic -> F_NUMBER .)


state 67

    (115) strings -> STRING .

    EXPONENTIATION  reduce using rule 115 (strings -> STRING .)
    DOT             reduce using rule 115 (strings -> STRING .)
    L_PARENTHESIS   reduce using rule 115 (strings -> STRING .)
    L_SQB           reduce using rule 115 (strings -> STRING .)
    PRODUCT         reduce using rule 115 (strings -> STRING .)
    DIVISION        reduce using rule 115 (strings -> STRING .)
    INTEGER_DIVISION reduce using rule 115 (strings -> STRING .)
    MODULUS         reduce using rule 115 (strings -> STRING .)
    SUM             reduce using rule 115 (strings -> STRING .)
    SUBTRACTION     reduce using rule 115 (strings -> STRING .)
    L_SHIFT         reduce using rule 115 (strings -> STRING .)
    R_SHIFT         reduce using rule 115 (strings -> STRING .)
    BITWISE_AND     reduce using rule 115 (strings -> STRING .)
    BITWISE_XOR     reduce using rule 115 (strings -> STRING .)
    BITWISE_OR      reduce using rule 115 (strings -> STRING .)
    EQUALITY        reduce using rule 115 (strings -> STRING .)
    INEQUALITY      reduce using rule 115 (strings -> STRING .)
    GREATER_EQUAL   reduce using rule 115 (strings -> STRING .)
    LESSER_EQUAL    reduce using rule 115 (strings -> STRING .)
    GREATER         reduce using rule 115 (strings -> STRING .)
    LESSER          reduce using rule 115 (strings -> STRING .)
    NOT             reduce using rule 115 (strings -> STRING .)
    IS              reduce using rule 115 (strings -> STRING .)
    IN              reduce using rule 115 (strings -> STRING .)
    AND             reduce using rule 115 (strings -> STRING .)
    OR              reduce using rule 115 (strings -> STRING .)
    IF              reduce using rule 115 (strings -> STRING .)
    COLON           reduce using rule 115 (strings -> STRING .)
    COMMA           reduce using rule 115 (strings -> STRING .)
    NEWLINE         reduce using rule 115 (strings -> STRING .)
    SEMICOLON       reduce using rule 115 (strings -> STRING .)
    ENDMARKER       reduce using rule 115 (strings -> STRING .)
    DEF             reduce using rule 115 (strings -> STRING .)
    CLASS           reduce using rule 115 (strings -> STRING .)
    FOR             reduce using rule 115 (strings -> STRING .)
    WHILE           reduce using rule 115 (strings -> STRING .)
    PASS            reduce using rule 115 (strings -> STRING .)
    BREAK           reduce using rule 115 (strings -> STRING .)
    CONTINUE        reduce using rule 115 (strings -> STRING .)
    IDENTIFIER      reduce using rule 115 (strings -> STRING .)
    RETURN          reduce using rule 115 (strings -> STRING .)
    DEL             reduce using rule 115 (strings -> STRING .)
    GLOBAL          reduce using rule 115 (strings -> STRING .)
    ELIF            reduce using rule 115 (strings -> STRING .)
    ELSE            reduce using rule 115 (strings -> STRING .)
    DEDENT          reduce using rule 115 (strings -> STRING .)
    R_SQB           reduce using rule 115 (strings -> STRING .)
    R_PARENTHESIS   reduce using rule 115 (strings -> STRING .)


state 68

    (116) strings -> TRIPLE_STRING .

    EXPONENTIATION  reduce using rule 116 (strings -> TRIPLE_STRING .)
    DOT             reduce using rule 116 (strings -> TRIPLE_STRING .)
    L_PARENTHESIS   reduce using rule 116 (strings -> TRIPLE_STRING .)
    L_SQB           reduce using rule 116 (strings -> TRIPLE_STRING .)
    PRODUCT         reduce using rule 116 (strings -> TRIPLE_STRING .)
    DIVISION        reduce using rule 116 (strings -> TRIPLE_STRING .)
    INTEGER_DIVISION reduce using rule 116 (strings -> TRIPLE_STRING .)
    MODULUS         reduce using rule 116 (strings -> TRIPLE_STRING .)
    SUM             reduce using rule 116 (strings -> TRIPLE_STRING .)
    SUBTRACTION     reduce using rule 116 (strings -> TRIPLE_STRING .)
    L_SHIFT         reduce using rule 116 (strings -> TRIPLE_STRING .)
    R_SHIFT         reduce using rule 116 (strings -> TRIPLE_STRING .)
    BITWISE_AND     reduce using rule 116 (strings -> TRIPLE_STRING .)
    BITWISE_XOR     reduce using rule 116 (strings -> TRIPLE_STRING .)
    BITWISE_OR      reduce using rule 116 (strings -> TRIPLE_STRING .)
    EQUALITY        reduce using rule 116 (strings -> TRIPLE_STRING .)
    INEQUALITY      reduce using rule 116 (strings -> TRIPLE_STRING .)
    GREATER_EQUAL   reduce using rule 116 (strings -> TRIPLE_STRING .)
    LESSER_EQUAL    reduce using rule 116 (strings -> TRIPLE_STRING .)
    GREATER         reduce using rule 116 (strings -> TRIPLE_STRING .)
    LESSER          reduce using rule 116 (strings -> TRIPLE_STRING .)
    NOT             reduce using rule 116 (strings -> TRIPLE_STRING .)
    IS              reduce using rule 116 (strings -> TRIPLE_STRING .)
    IN              reduce using rule 116 (strings -> TRIPLE_STRING .)
    AND             reduce using rule 116 (strings -> TRIPLE_STRING .)
    OR              reduce using rule 116 (strings -> TRIPLE_STRING .)
    IF              reduce using rule 116 (strings -> TRIPLE_STRING .)
    COLON           reduce using rule 116 (strings -> TRIPLE_STRING .)
    COMMA           reduce using rule 116 (strings -> TRIPLE_STRING .)
    NEWLINE         reduce using rule 116 (strings -> TRIPLE_STRING .)
    SEMICOLON       reduce using rule 116 (strings -> TRIPLE_STRING .)
    ENDMARKER       reduce using rule 116 (strings -> TRIPLE_STRING .)
    DEF             reduce using rule 116 (strings -> TRIPLE_STRING .)
    CLASS           reduce using rule 116 (strings -> TRIPLE_STRING .)
    FOR             reduce using rule 116 (strings -> TRIPLE_STRING .)
    WHILE           reduce using rule 116 (strings -> TRIPLE_STRING .)
    PASS            reduce using rule 116 (strings -> TRIPLE_STRING .)
    BREAK           reduce using rule 116 (strings -> TRIPLE_STRING .)
    CONTINUE        reduce using rule 116 (strings -> TRIPLE_STRING .)
    IDENTIFIER      reduce using rule 116 (strings -> TRIPLE_STRING .)
    RETURN          reduce using rule 116 (strings -> TRIPLE_STRING .)
    DEL             reduce using rule 116 (strings -> TRIPLE_STRING .)
    GLOBAL          reduce using rule 116 (strings -> TRIPLE_STRING .)
    ELIF            reduce using rule 116 (strings -> TRIPLE_STRING .)
    ELSE            reduce using rule 116 (strings -> TRIPLE_STRING .)
    DEDENT          reduce using rule 116 (strings -> TRIPLE_STRING .)
    R_SQB           reduce using rule 116 (strings -> TRIPLE_STRING .)
    R_PARENTHESIS   reduce using rule 116 (strings -> TRIPLE_STRING .)


state 69

    (36) class_def -> CLASS IDENTIFIER . COLON block
    (37) class_def -> CLASS IDENTIFIER . L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> CLASS IDENTIFIER . L_PARENTHESIS arguments R_PARENTHESIS COLON block

    COLON           shift and go to state 115
    L_PARENTHESIS   shift and go to state 116


state 70

    (52) for_stmt -> FOR targets . IN expressions COLON else_block
    (53) for_stmt -> FOR targets . IN expressions COLON block

    IN              shift and go to state 117


state 71

    (117) targets -> target .
    (118) targets -> target . COMMA targets

    IN              reduce using rule 117 (targets -> target .)
    COMMA           shift and go to state 118


state 72

    (119) target -> empty .

    COMMA           reduce using rule 119 (target -> empty .)
    IN              reduce using rule 119 (target -> empty .)
    PRODUCT         reduce using rule 119 (target -> empty .)
    DIVISION        reduce using rule 119 (target -> empty .)
    INTEGER_DIVISION reduce using rule 119 (target -> empty .)
    MODULUS         reduce using rule 119 (target -> empty .)
    SUM             reduce using rule 119 (target -> empty .)
    SUBTRACTION     reduce using rule 119 (target -> empty .)
    L_SHIFT         reduce using rule 119 (target -> empty .)
    R_SHIFT         reduce using rule 119 (target -> empty .)
    BITWISE_AND     reduce using rule 119 (target -> empty .)
    BITWISE_XOR     reduce using rule 119 (target -> empty .)
    BITWISE_OR      reduce using rule 119 (target -> empty .)
    EQUALITY        reduce using rule 119 (target -> empty .)
    INEQUALITY      reduce using rule 119 (target -> empty .)
    GREATER_EQUAL   reduce using rule 119 (target -> empty .)
    LESSER_EQUAL    reduce using rule 119 (target -> empty .)
    GREATER         reduce using rule 119 (target -> empty .)
    LESSER          reduce using rule 119 (target -> empty .)
    NOT             reduce using rule 119 (target -> empty .)
    IS              reduce using rule 119 (target -> empty .)
    AND             reduce using rule 119 (target -> empty .)
    OR              reduce using rule 119 (target -> empty .)
    IF              reduce using rule 119 (target -> empty .)
    COLON           reduce using rule 119 (target -> empty .)
    NEWLINE         reduce using rule 119 (target -> empty .)
    SEMICOLON       reduce using rule 119 (target -> empty .)
    ENDMARKER       reduce using rule 119 (target -> empty .)
    DEF             reduce using rule 119 (target -> empty .)
    CLASS           reduce using rule 119 (target -> empty .)
    FOR             reduce using rule 119 (target -> empty .)
    WHILE           reduce using rule 119 (target -> empty .)
    PASS            reduce using rule 119 (target -> empty .)
    BREAK           reduce using rule 119 (target -> empty .)
    CONTINUE        reduce using rule 119 (target -> empty .)
    IDENTIFIER      reduce using rule 119 (target -> empty .)
    RETURN          reduce using rule 119 (target -> empty .)
    DEL             reduce using rule 119 (target -> empty .)
    GLOBAL          reduce using rule 119 (target -> empty .)
    ELIF            reduce using rule 119 (target -> empty .)
    ELSE            reduce using rule 119 (target -> empty .)
    DEDENT          reduce using rule 119 (target -> empty .)
    R_SQB           reduce using rule 119 (target -> empty .)
    R_PARENTHESIS   reduce using rule 119 (target -> empty .)


state 73

    (50) while_stmt -> WHILE expression . COLON block else_block
    (51) while_stmt -> WHILE expression . COLON block

    COLON           shift and go to state 119


state 74

    (29) return_stmt -> RETURN expressions .
    (54) expressions -> expressions . COMMA expression

    NEWLINE         reduce using rule 29 (return_stmt -> RETURN expressions .)
    SEMICOLON       reduce using rule 29 (return_stmt -> RETURN expressions .)
    ENDMARKER       reduce using rule 29 (return_stmt -> RETURN expressions .)
    DEF             reduce using rule 29 (return_stmt -> RETURN expressions .)
    IF              reduce using rule 29 (return_stmt -> RETURN expressions .)
    CLASS           reduce using rule 29 (return_stmt -> RETURN expressions .)
    FOR             reduce using rule 29 (return_stmt -> RETURN expressions .)
    WHILE           reduce using rule 29 (return_stmt -> RETURN expressions .)
    PASS            reduce using rule 29 (return_stmt -> RETURN expressions .)
    BREAK           reduce using rule 29 (return_stmt -> RETURN expressions .)
    CONTINUE        reduce using rule 29 (return_stmt -> RETURN expressions .)
    IDENTIFIER      reduce using rule 29 (return_stmt -> RETURN expressions .)
    RETURN          reduce using rule 29 (return_stmt -> RETURN expressions .)
    DEL             reduce using rule 29 (return_stmt -> RETURN expressions .)
    GLOBAL          reduce using rule 29 (return_stmt -> RETURN expressions .)
    ELIF            reduce using rule 29 (return_stmt -> RETURN expressions .)
    ELSE            reduce using rule 29 (return_stmt -> RETURN expressions .)
    DEDENT          reduce using rule 29 (return_stmt -> RETURN expressions .)
    COMMA           shift and go to state 120


state 75

    (55) expressions -> expression .

    COMMA           reduce using rule 55 (expressions -> expression .)
    NEWLINE         reduce using rule 55 (expressions -> expression .)
    SEMICOLON       reduce using rule 55 (expressions -> expression .)
    ENDMARKER       reduce using rule 55 (expressions -> expression .)
    DEF             reduce using rule 55 (expressions -> expression .)
    IF              reduce using rule 55 (expressions -> expression .)
    CLASS           reduce using rule 55 (expressions -> expression .)
    FOR             reduce using rule 55 (expressions -> expression .)
    WHILE           reduce using rule 55 (expressions -> expression .)
    PASS            reduce using rule 55 (expressions -> expression .)
    BREAK           reduce using rule 55 (expressions -> expression .)
    CONTINUE        reduce using rule 55 (expressions -> expression .)
    IDENTIFIER      reduce using rule 55 (expressions -> expression .)
    RETURN          reduce using rule 55 (expressions -> expression .)
    DEL             reduce using rule 55 (expressions -> expression .)
    GLOBAL          reduce using rule 55 (expressions -> expression .)
    ELIF            reduce using rule 55 (expressions -> expression .)
    ELSE            reduce using rule 55 (expressions -> expression .)
    DEDENT          reduce using rule 55 (expressions -> expression .)
    COLON           reduce using rule 55 (expressions -> expression .)


state 76

    (31) del_stmt -> DEL namelist .
    (32) namelist -> namelist . COMMA IDENTIFIER

    NEWLINE         reduce using rule 31 (del_stmt -> DEL namelist .)
    SEMICOLON       reduce using rule 31 (del_stmt -> DEL namelist .)
    ENDMARKER       reduce using rule 31 (del_stmt -> DEL namelist .)
    DEF             reduce using rule 31 (del_stmt -> DEL namelist .)
    IF              reduce using rule 31 (del_stmt -> DEL namelist .)
    CLASS           reduce using rule 31 (del_stmt -> DEL namelist .)
    FOR             reduce using rule 31 (del_stmt -> DEL namelist .)
    WHILE           reduce using rule 31 (del_stmt -> DEL namelist .)
    PASS            reduce using rule 31 (del_stmt -> DEL namelist .)
    BREAK           reduce using rule 31 (del_stmt -> DEL namelist .)
    CONTINUE        reduce using rule 31 (del_stmt -> DEL namelist .)
    IDENTIFIER      reduce using rule 31 (del_stmt -> DEL namelist .)
    RETURN          reduce using rule 31 (del_stmt -> DEL namelist .)
    DEL             reduce using rule 31 (del_stmt -> DEL namelist .)
    GLOBAL          reduce using rule 31 (del_stmt -> DEL namelist .)
    ELIF            reduce using rule 31 (del_stmt -> DEL namelist .)
    ELSE            reduce using rule 31 (del_stmt -> DEL namelist .)
    DEDENT          reduce using rule 31 (del_stmt -> DEL namelist .)
    COMMA           shift and go to state 121


state 77

    (33) namelist -> IDENTIFIER .

    COMMA           reduce using rule 33 (namelist -> IDENTIFIER .)
    NEWLINE         reduce using rule 33 (namelist -> IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (namelist -> IDENTIFIER .)
    ENDMARKER       reduce using rule 33 (namelist -> IDENTIFIER .)
    DEF             reduce using rule 33 (namelist -> IDENTIFIER .)
    IF              reduce using rule 33 (namelist -> IDENTIFIER .)
    CLASS           reduce using rule 33 (namelist -> IDENTIFIER .)
    FOR             reduce using rule 33 (namelist -> IDENTIFIER .)
    WHILE           reduce using rule 33 (namelist -> IDENTIFIER .)
    PASS            reduce using rule 33 (namelist -> IDENTIFIER .)
    BREAK           reduce using rule 33 (namelist -> IDENTIFIER .)
    CONTINUE        reduce using rule 33 (namelist -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 33 (namelist -> IDENTIFIER .)
    RETURN          reduce using rule 33 (namelist -> IDENTIFIER .)
    DEL             reduce using rule 33 (namelist -> IDENTIFIER .)
    GLOBAL          reduce using rule 33 (namelist -> IDENTIFIER .)
    ELIF            reduce using rule 33 (namelist -> IDENTIFIER .)
    ELSE            reduce using rule 33 (namelist -> IDENTIFIER .)
    DEDENT          reduce using rule 33 (namelist -> IDENTIFIER .)


state 78

    (30) global_stmt -> GLOBAL namelist .
    (32) namelist -> namelist . COMMA IDENTIFIER

    NEWLINE         reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    SEMICOLON       reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    ENDMARKER       reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    DEF             reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    IF              reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    CLASS           reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    FOR             reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    WHILE           reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    PASS            reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    BREAK           reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    CONTINUE        reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    IDENTIFIER      reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    RETURN          reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    DEL             reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    GLOBAL          reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    ELIF            reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    ELSE            reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    DEDENT          reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    COMMA           shift and go to state 121


state 79

    (6) simple_stmts -> simple_stmts SEMICOLON simple_stmt .

    SEMICOLON       reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ENDMARKER       reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEF             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    IF              reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    CLASS           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    FOR             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    WHILE           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    PASS            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    BREAK           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    CONTINUE        reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    IDENTIFIER      reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    RETURN          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEL             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    GLOBAL          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ELIF            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ELSE            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEDENT          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)


state 80

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS . parameters R_PARENTHESIS COLON block
    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS . R_PARENTHESIS COLON block
    (41) parameters -> . parameters COMMA IDENTIFIER
    (42) parameters -> . IDENTIFIER

    R_PARENTHESIS   shift and go to state 124
    IDENTIFIER      shift and go to state 122

    parameters                     shift and go to state 123

state 81

    (20) assignment -> IDENTIFIER augmentation_assignment expressions .
    (54) expressions -> expressions . COMMA expression

    NEWLINE         reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    SEMICOLON       reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ENDMARKER       reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEF             reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    IF              reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    CLASS           reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    FOR             reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    WHILE           reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    PASS            reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    BREAK           reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    CONTINUE        reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    IDENTIFIER      reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    RETURN          reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEL             reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    GLOBAL          reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ELIF            reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ELSE            reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEDENT          reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    COMMA           shift and go to state 120


state 82

    (43) if_stmt -> IF expression COLON . block elif_stmt
    (44) if_stmt -> IF expression COLON . block else_block
    (45) if_stmt -> IF expression COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 125
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 83

    (57) expression -> disjunction IF . disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    disjunction                    shift and go to state 128
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 84

    (59) disjunction -> conjunction OR . disjunction
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    conjunction                    shift and go to state 44
    disjunction                    shift and go to state 129
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 85

    (61) conjunction -> inversion AND . inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    inversion                      shift and go to state 130
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 86

    (62) inversion -> NOT inversion .

    AND             reduce using rule 62 (inversion -> NOT inversion .)
    OR              reduce using rule 62 (inversion -> NOT inversion .)
    IF              reduce using rule 62 (inversion -> NOT inversion .)
    COLON           reduce using rule 62 (inversion -> NOT inversion .)
    COMMA           reduce using rule 62 (inversion -> NOT inversion .)
    NEWLINE         reduce using rule 62 (inversion -> NOT inversion .)
    SEMICOLON       reduce using rule 62 (inversion -> NOT inversion .)
    ENDMARKER       reduce using rule 62 (inversion -> NOT inversion .)
    DEF             reduce using rule 62 (inversion -> NOT inversion .)
    CLASS           reduce using rule 62 (inversion -> NOT inversion .)
    FOR             reduce using rule 62 (inversion -> NOT inversion .)
    WHILE           reduce using rule 62 (inversion -> NOT inversion .)
    PASS            reduce using rule 62 (inversion -> NOT inversion .)
    BREAK           reduce using rule 62 (inversion -> NOT inversion .)
    CONTINUE        reduce using rule 62 (inversion -> NOT inversion .)
    IDENTIFIER      reduce using rule 62 (inversion -> NOT inversion .)
    RETURN          reduce using rule 62 (inversion -> NOT inversion .)
    DEL             reduce using rule 62 (inversion -> NOT inversion .)
    GLOBAL          reduce using rule 62 (inversion -> NOT inversion .)
    ELIF            reduce using rule 62 (inversion -> NOT inversion .)
    ELSE            reduce using rule 62 (inversion -> NOT inversion .)
    DEDENT          reduce using rule 62 (inversion -> NOT inversion .)
    R_SQB           reduce using rule 62 (inversion -> NOT inversion .)
    R_PARENTHESIS   reduce using rule 62 (inversion -> NOT inversion .)


state 87

    (65) comparison -> bitwise_or compare_op_list .
    (67) compare_op_list -> compare_op_list . compare_op
    (68) compare_op -> . EQUALITY bitwise_or
    (69) compare_op -> . INEQUALITY bitwise_or
    (70) compare_op -> . GREATER_EQUAL bitwise_or
    (71) compare_op -> . LESSER_EQUAL bitwise_or
    (72) compare_op -> . GREATER bitwise_or
    (73) compare_op -> . LESSER bitwise_or
    (74) compare_op -> . NOT IN bitwise_or
    (75) compare_op -> . IS NOT bitwise_or
    (76) compare_op -> . IN bitwise_or
    (77) compare_op -> . IS bitwise_or

    AND             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    OR              reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    IF              reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    COLON           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    COMMA           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    NEWLINE         reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    SEMICOLON       reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ENDMARKER       reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEF             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    CLASS           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    FOR             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    WHILE           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    PASS            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    BREAK           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    CONTINUE        reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    IDENTIFIER      reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    RETURN          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEL             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    GLOBAL          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ELIF            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ELSE            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEDENT          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    R_SQB           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    R_PARENTHESIS   reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    EQUALITY        shift and go to state 90
    INEQUALITY      shift and go to state 91
    GREATER_EQUAL   shift and go to state 92
    LESSER_EQUAL    shift and go to state 93
    GREATER         shift and go to state 94
    LESSER          shift and go to state 95
    NOT             shift and go to state 96
    IS              shift and go to state 98
    IN              shift and go to state 97

    compare_op                     shift and go to state 131

state 88

    (78) bitwise_or -> bitwise_or BITWISE_OR . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_xor                    shift and go to state 132
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 89

    (66) compare_op_list -> compare_op .

    EQUALITY        reduce using rule 66 (compare_op_list -> compare_op .)
    INEQUALITY      reduce using rule 66 (compare_op_list -> compare_op .)
    GREATER_EQUAL   reduce using rule 66 (compare_op_list -> compare_op .)
    LESSER_EQUAL    reduce using rule 66 (compare_op_list -> compare_op .)
    GREATER         reduce using rule 66 (compare_op_list -> compare_op .)
    LESSER          reduce using rule 66 (compare_op_list -> compare_op .)
    NOT             reduce using rule 66 (compare_op_list -> compare_op .)
    IS              reduce using rule 66 (compare_op_list -> compare_op .)
    IN              reduce using rule 66 (compare_op_list -> compare_op .)
    AND             reduce using rule 66 (compare_op_list -> compare_op .)
    OR              reduce using rule 66 (compare_op_list -> compare_op .)
    IF              reduce using rule 66 (compare_op_list -> compare_op .)
    COLON           reduce using rule 66 (compare_op_list -> compare_op .)
    COMMA           reduce using rule 66 (compare_op_list -> compare_op .)
    NEWLINE         reduce using rule 66 (compare_op_list -> compare_op .)
    SEMICOLON       reduce using rule 66 (compare_op_list -> compare_op .)
    ENDMARKER       reduce using rule 66 (compare_op_list -> compare_op .)
    DEF             reduce using rule 66 (compare_op_list -> compare_op .)
    CLASS           reduce using rule 66 (compare_op_list -> compare_op .)
    FOR             reduce using rule 66 (compare_op_list -> compare_op .)
    WHILE           reduce using rule 66 (compare_op_list -> compare_op .)
    PASS            reduce using rule 66 (compare_op_list -> compare_op .)
    BREAK           reduce using rule 66 (compare_op_list -> compare_op .)
    CONTINUE        reduce using rule 66 (compare_op_list -> compare_op .)
    IDENTIFIER      reduce using rule 66 (compare_op_list -> compare_op .)
    RETURN          reduce using rule 66 (compare_op_list -> compare_op .)
    DEL             reduce using rule 66 (compare_op_list -> compare_op .)
    GLOBAL          reduce using rule 66 (compare_op_list -> compare_op .)
    ELIF            reduce using rule 66 (compare_op_list -> compare_op .)
    ELSE            reduce using rule 66 (compare_op_list -> compare_op .)
    DEDENT          reduce using rule 66 (compare_op_list -> compare_op .)
    R_SQB           reduce using rule 66 (compare_op_list -> compare_op .)
    R_PARENTHESIS   reduce using rule 66 (compare_op_list -> compare_op .)


state 90

    (68) compare_op -> EQUALITY . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 133
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 91

    (69) compare_op -> INEQUALITY . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 134
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 92

    (70) compare_op -> GREATER_EQUAL . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 135
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 93

    (71) compare_op -> LESSER_EQUAL . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 136
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 94

    (72) compare_op -> GREATER . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 137
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 95

    (73) compare_op -> LESSER . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 138
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 96

    (74) compare_op -> NOT . IN bitwise_or

    IN              shift and go to state 139


state 97

    (76) compare_op -> IN . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 140
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 98

    (75) compare_op -> IS . NOT bitwise_or
    (77) compare_op -> IS . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 141
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 142
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 99

    (80) bitwise_xor -> bitwise_xor BITWISE_XOR . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_and                    shift and go to state 143
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 100

    (82) bitwise_and -> bitwise_and BITWISE_AND . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    shift_expr                     shift and go to state 144
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 101

    (84) shift_expr -> shift_expr L_SHIFT . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    sum                            shift and go to state 145
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 102

    (85) shift_expr -> shift_expr R_SHIFT . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    sum                            shift and go to state 146
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 103

    (87) sum -> sum SUM . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    term                           shift and go to state 147
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 104

    (88) sum -> sum SUBTRACTION . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    term                           shift and go to state 148
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 105

    (95) factor -> SUM factor .

    PRODUCT         reduce using rule 95 (factor -> SUM factor .)
    DIVISION        reduce using rule 95 (factor -> SUM factor .)
    INTEGER_DIVISION reduce using rule 95 (factor -> SUM factor .)
    MODULUS         reduce using rule 95 (factor -> SUM factor .)
    SUM             reduce using rule 95 (factor -> SUM factor .)
    SUBTRACTION     reduce using rule 95 (factor -> SUM factor .)
    L_SHIFT         reduce using rule 95 (factor -> SUM factor .)
    R_SHIFT         reduce using rule 95 (factor -> SUM factor .)
    BITWISE_AND     reduce using rule 95 (factor -> SUM factor .)
    BITWISE_XOR     reduce using rule 95 (factor -> SUM factor .)
    BITWISE_OR      reduce using rule 95 (factor -> SUM factor .)
    EQUALITY        reduce using rule 95 (factor -> SUM factor .)
    INEQUALITY      reduce using rule 95 (factor -> SUM factor .)
    GREATER_EQUAL   reduce using rule 95 (factor -> SUM factor .)
    LESSER_EQUAL    reduce using rule 95 (factor -> SUM factor .)
    GREATER         reduce using rule 95 (factor -> SUM factor .)
    LESSER          reduce using rule 95 (factor -> SUM factor .)
    NOT             reduce using rule 95 (factor -> SUM factor .)
    IS              reduce using rule 95 (factor -> SUM factor .)
    IN              reduce using rule 95 (factor -> SUM factor .)
    AND             reduce using rule 95 (factor -> SUM factor .)
    OR              reduce using rule 95 (factor -> SUM factor .)
    IF              reduce using rule 95 (factor -> SUM factor .)
    COLON           reduce using rule 95 (factor -> SUM factor .)
    COMMA           reduce using rule 95 (factor -> SUM factor .)
    NEWLINE         reduce using rule 95 (factor -> SUM factor .)
    SEMICOLON       reduce using rule 95 (factor -> SUM factor .)
    ENDMARKER       reduce using rule 95 (factor -> SUM factor .)
    DEF             reduce using rule 95 (factor -> SUM factor .)
    CLASS           reduce using rule 95 (factor -> SUM factor .)
    FOR             reduce using rule 95 (factor -> SUM factor .)
    WHILE           reduce using rule 95 (factor -> SUM factor .)
    PASS            reduce using rule 95 (factor -> SUM factor .)
    BREAK           reduce using rule 95 (factor -> SUM factor .)
    CONTINUE        reduce using rule 95 (factor -> SUM factor .)
    IDENTIFIER      reduce using rule 95 (factor -> SUM factor .)
    RETURN          reduce using rule 95 (factor -> SUM factor .)
    DEL             reduce using rule 95 (factor -> SUM factor .)
    GLOBAL          reduce using rule 95 (factor -> SUM factor .)
    ELIF            reduce using rule 95 (factor -> SUM factor .)
    ELSE            reduce using rule 95 (factor -> SUM factor .)
    DEDENT          reduce using rule 95 (factor -> SUM factor .)
    R_SQB           reduce using rule 95 (factor -> SUM factor .)
    R_PARENTHESIS   reduce using rule 95 (factor -> SUM factor .)


state 106

    (90) term -> term PRODUCT . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    factor                         shift and go to state 149
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 107

    (91) term -> term DIVISION . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    factor                         shift and go to state 150
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 108

    (92) term -> term INTEGER_DIVISION . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    factor                         shift and go to state 151
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 109

    (93) term -> term MODULUS . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    factor                         shift and go to state 152
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 110

    (96) factor -> SUBTRACTION factor .

    PRODUCT         reduce using rule 96 (factor -> SUBTRACTION factor .)
    DIVISION        reduce using rule 96 (factor -> SUBTRACTION factor .)
    INTEGER_DIVISION reduce using rule 96 (factor -> SUBTRACTION factor .)
    MODULUS         reduce using rule 96 (factor -> SUBTRACTION factor .)
    SUM             reduce using rule 96 (factor -> SUBTRACTION factor .)
    SUBTRACTION     reduce using rule 96 (factor -> SUBTRACTION factor .)
    L_SHIFT         reduce using rule 96 (factor -> SUBTRACTION factor .)
    R_SHIFT         reduce using rule 96 (factor -> SUBTRACTION factor .)
    BITWISE_AND     reduce using rule 96 (factor -> SUBTRACTION factor .)
    BITWISE_XOR     reduce using rule 96 (factor -> SUBTRACTION factor .)
    BITWISE_OR      reduce using rule 96 (factor -> SUBTRACTION factor .)
    EQUALITY        reduce using rule 96 (factor -> SUBTRACTION factor .)
    INEQUALITY      reduce using rule 96 (factor -> SUBTRACTION factor .)
    GREATER_EQUAL   reduce using rule 96 (factor -> SUBTRACTION factor .)
    LESSER_EQUAL    reduce using rule 96 (factor -> SUBTRACTION factor .)
    GREATER         reduce using rule 96 (factor -> SUBTRACTION factor .)
    LESSER          reduce using rule 96 (factor -> SUBTRACTION factor .)
    NOT             reduce using rule 96 (factor -> SUBTRACTION factor .)
    IS              reduce using rule 96 (factor -> SUBTRACTION factor .)
    IN              reduce using rule 96 (factor -> SUBTRACTION factor .)
    AND             reduce using rule 96 (factor -> SUBTRACTION factor .)
    OR              reduce using rule 96 (factor -> SUBTRACTION factor .)
    IF              reduce using rule 96 (factor -> SUBTRACTION factor .)
    COLON           reduce using rule 96 (factor -> SUBTRACTION factor .)
    COMMA           reduce using rule 96 (factor -> SUBTRACTION factor .)
    NEWLINE         reduce using rule 96 (factor -> SUBTRACTION factor .)
    SEMICOLON       reduce using rule 96 (factor -> SUBTRACTION factor .)
    ENDMARKER       reduce using rule 96 (factor -> SUBTRACTION factor .)
    DEF             reduce using rule 96 (factor -> SUBTRACTION factor .)
    CLASS           reduce using rule 96 (factor -> SUBTRACTION factor .)
    FOR             reduce using rule 96 (factor -> SUBTRACTION factor .)
    WHILE           reduce using rule 96 (factor -> SUBTRACTION factor .)
    PASS            reduce using rule 96 (factor -> SUBTRACTION factor .)
    BREAK           reduce using rule 96 (factor -> SUBTRACTION factor .)
    CONTINUE        reduce using rule 96 (factor -> SUBTRACTION factor .)
    IDENTIFIER      reduce using rule 96 (factor -> SUBTRACTION factor .)
    RETURN          reduce using rule 96 (factor -> SUBTRACTION factor .)
    DEL             reduce using rule 96 (factor -> SUBTRACTION factor .)
    GLOBAL          reduce using rule 96 (factor -> SUBTRACTION factor .)
    ELIF            reduce using rule 96 (factor -> SUBTRACTION factor .)
    ELSE            reduce using rule 96 (factor -> SUBTRACTION factor .)
    DEDENT          reduce using rule 96 (factor -> SUBTRACTION factor .)
    R_SQB           reduce using rule 96 (factor -> SUBTRACTION factor .)
    R_PARENTHESIS   reduce using rule 96 (factor -> SUBTRACTION factor .)


state 111

    (98) power -> primary EXPONENTIATION . target
    (119) target -> . empty
    (120) empty -> .

    PRODUCT         reduce using rule 120 (empty -> .)
    DIVISION        reduce using rule 120 (empty -> .)
    INTEGER_DIVISION reduce using rule 120 (empty -> .)
    MODULUS         reduce using rule 120 (empty -> .)
    SUM             reduce using rule 120 (empty -> .)
    SUBTRACTION     reduce using rule 120 (empty -> .)
    L_SHIFT         reduce using rule 120 (empty -> .)
    R_SHIFT         reduce using rule 120 (empty -> .)
    BITWISE_AND     reduce using rule 120 (empty -> .)
    BITWISE_XOR     reduce using rule 120 (empty -> .)
    BITWISE_OR      reduce using rule 120 (empty -> .)
    EQUALITY        reduce using rule 120 (empty -> .)
    INEQUALITY      reduce using rule 120 (empty -> .)
    GREATER_EQUAL   reduce using rule 120 (empty -> .)
    LESSER_EQUAL    reduce using rule 120 (empty -> .)
    GREATER         reduce using rule 120 (empty -> .)
    LESSER          reduce using rule 120 (empty -> .)
    NOT             reduce using rule 120 (empty -> .)
    IS              reduce using rule 120 (empty -> .)
    IN              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    COLON           reduce using rule 120 (empty -> .)
    COMMA           reduce using rule 120 (empty -> .)
    NEWLINE         reduce using rule 120 (empty -> .)
    SEMICOLON       reduce using rule 120 (empty -> .)
    ENDMARKER       reduce using rule 120 (empty -> .)
    DEF             reduce using rule 120 (empty -> .)
    CLASS           reduce using rule 120 (empty -> .)
    FOR             reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    PASS            reduce using rule 120 (empty -> .)
    BREAK           reduce using rule 120 (empty -> .)
    CONTINUE        reduce using rule 120 (empty -> .)
    IDENTIFIER      reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    DEL             reduce using rule 120 (empty -> .)
    GLOBAL          reduce using rule 120 (empty -> .)
    ELIF            reduce using rule 120 (empty -> .)
    ELSE            reduce using rule 120 (empty -> .)
    DEDENT          reduce using rule 120 (empty -> .)
    R_SQB           reduce using rule 120 (empty -> .)
    R_PARENTHESIS   reduce using rule 120 (empty -> .)

    target                         shift and go to state 153
    empty                          shift and go to state 72

state 112

    (100) primary -> primary DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 154


state 113

    (101) primary -> primary L_PARENTHESIS . arguments R_PARENTHESIS
    (114) arguments -> .

    R_PARENTHESIS   reduce using rule 114 (arguments -> .)

    arguments                      shift and go to state 155

state 114

    (102) primary -> primary L_SQB . slices R_SQB
    (104) slices -> . slice
    (105) slices -> . COMMA L_PARENTHESIS slice R_PARENTHESIS slices
    (106) slice -> . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    COMMA           shift and go to state 158
    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    primary                        shift and go to state 58
    slices                         shift and go to state 156
    slice                          shift and go to state 157
    expression                     shift and go to state 159
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 115

    (36) class_def -> CLASS IDENTIFIER COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 160
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 116

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS . R_PARENTHESIS COLON block
    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS . arguments R_PARENTHESIS COLON block
    (114) arguments -> .

  ! shift/reduce conflict for R_PARENTHESIS resolved as shift
    R_PARENTHESIS   shift and go to state 161

  ! R_PARENTHESIS   [ reduce using rule 114 (arguments -> .) ]

    arguments                      shift and go to state 162

state 117

    (52) for_stmt -> FOR targets IN . expressions COLON else_block
    (53) for_stmt -> FOR targets IN . expressions COLON block
    (54) expressions -> . expressions COMMA expression
    (55) expressions -> . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    expressions                    shift and go to state 163
    expression                     shift and go to state 75
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 118

    (118) targets -> target COMMA . targets
    (117) targets -> . target
    (118) targets -> . target COMMA targets
    (119) target -> . empty
    (120) empty -> .

    COMMA           reduce using rule 120 (empty -> .)
    IN              reduce using rule 120 (empty -> .)

    target                         shift and go to state 71
    targets                        shift and go to state 164
    empty                          shift and go to state 72

state 119

    (50) while_stmt -> WHILE expression COLON . block else_block
    (51) while_stmt -> WHILE expression COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 165
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 120

    (54) expressions -> expressions COMMA . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    expression                     shift and go to state 166
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 121

    (32) namelist -> namelist COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 167


state 122

    (42) parameters -> IDENTIFIER .

    R_PARENTHESIS   reduce using rule 42 (parameters -> IDENTIFIER .)
    COMMA           reduce using rule 42 (parameters -> IDENTIFIER .)


state 123

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters . R_PARENTHESIS COLON block
    (41) parameters -> parameters . COMMA IDENTIFIER

    R_PARENTHESIS   shift and go to state 168
    COMMA           shift and go to state 169


state 124

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS . COLON block

    COLON           shift and go to state 170


state 125

    (43) if_stmt -> IF expression COLON block . elif_stmt
    (44) if_stmt -> IF expression COLON block . else_block
    (45) if_stmt -> IF expression COLON block .
    (46) elif_stmt -> . ELIF expression COLON block elif_stmt
    (47) elif_stmt -> . ELIF expression COLON block else_block
    (48) elif_stmt -> . ELIF expression COLON block
    (49) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 45 (if_stmt -> IF expression COLON block .)
    DEF             reduce using rule 45 (if_stmt -> IF expression COLON block .)
    IF              reduce using rule 45 (if_stmt -> IF expression COLON block .)
    CLASS           reduce using rule 45 (if_stmt -> IF expression COLON block .)
    FOR             reduce using rule 45 (if_stmt -> IF expression COLON block .)
    WHILE           reduce using rule 45 (if_stmt -> IF expression COLON block .)
    PASS            reduce using rule 45 (if_stmt -> IF expression COLON block .)
    BREAK           reduce using rule 45 (if_stmt -> IF expression COLON block .)
    CONTINUE        reduce using rule 45 (if_stmt -> IF expression COLON block .)
    IDENTIFIER      reduce using rule 45 (if_stmt -> IF expression COLON block .)
    RETURN          reduce using rule 45 (if_stmt -> IF expression COLON block .)
    DEL             reduce using rule 45 (if_stmt -> IF expression COLON block .)
    GLOBAL          reduce using rule 45 (if_stmt -> IF expression COLON block .)
    DEDENT          reduce using rule 45 (if_stmt -> IF expression COLON block .)
    ELIF            shift and go to state 173
    ELSE            shift and go to state 174

    elif_stmt                      shift and go to state 171
    else_block                     shift and go to state 172

state 126

    (34) block -> NEWLINE . INDENT statements DEDENT

    INDENT          shift and go to state 175


state 127

    (35) block -> simple_stmts .
    (6) simple_stmts -> simple_stmts . SEMICOLON simple_stmt

    ELIF            reduce using rule 35 (block -> simple_stmts .)
    ELSE            reduce using rule 35 (block -> simple_stmts .)
    ENDMARKER       reduce using rule 35 (block -> simple_stmts .)
    DEF             reduce using rule 35 (block -> simple_stmts .)
    IF              reduce using rule 35 (block -> simple_stmts .)
    CLASS           reduce using rule 35 (block -> simple_stmts .)
    FOR             reduce using rule 35 (block -> simple_stmts .)
    WHILE           reduce using rule 35 (block -> simple_stmts .)
    PASS            reduce using rule 35 (block -> simple_stmts .)
    BREAK           reduce using rule 35 (block -> simple_stmts .)
    CONTINUE        reduce using rule 35 (block -> simple_stmts .)
    IDENTIFIER      reduce using rule 35 (block -> simple_stmts .)
    RETURN          reduce using rule 35 (block -> simple_stmts .)
    DEL             reduce using rule 35 (block -> simple_stmts .)
    GLOBAL          reduce using rule 35 (block -> simple_stmts .)
    DEDENT          reduce using rule 35 (block -> simple_stmts .)
    SEMICOLON       shift and go to state 30


state 128

    (57) expression -> disjunction IF disjunction . ELSE expression

    ELSE            shift and go to state 176


state 129

    (59) disjunction -> conjunction OR disjunction .

    IF              reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    COLON           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    COMMA           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    NEWLINE         reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    SEMICOLON       reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    ENDMARKER       reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    DEF             reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    CLASS           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    FOR             reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    WHILE           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    PASS            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    BREAK           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    CONTINUE        reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    IDENTIFIER      reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    RETURN          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    DEL             reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    GLOBAL          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    ELIF            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    ELSE            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    DEDENT          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    R_SQB           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    R_PARENTHESIS   reduce using rule 59 (disjunction -> conjunction OR disjunction .)


state 130

    (61) conjunction -> inversion AND inversion .

    OR              reduce using rule 61 (conjunction -> inversion AND inversion .)
    IF              reduce using rule 61 (conjunction -> inversion AND inversion .)
    COLON           reduce using rule 61 (conjunction -> inversion AND inversion .)
    COMMA           reduce using rule 61 (conjunction -> inversion AND inversion .)
    NEWLINE         reduce using rule 61 (conjunction -> inversion AND inversion .)
    SEMICOLON       reduce using rule 61 (conjunction -> inversion AND inversion .)
    ENDMARKER       reduce using rule 61 (conjunction -> inversion AND inversion .)
    DEF             reduce using rule 61 (conjunction -> inversion AND inversion .)
    CLASS           reduce using rule 61 (conjunction -> inversion AND inversion .)
    FOR             reduce using rule 61 (conjunction -> inversion AND inversion .)
    WHILE           reduce using rule 61 (conjunction -> inversion AND inversion .)
    PASS            reduce using rule 61 (conjunction -> inversion AND inversion .)
    BREAK           reduce using rule 61 (conjunction -> inversion AND inversion .)
    CONTINUE        reduce using rule 61 (conjunction -> inversion AND inversion .)
    IDENTIFIER      reduce using rule 61 (conjunction -> inversion AND inversion .)
    RETURN          reduce using rule 61 (conjunction -> inversion AND inversion .)
    DEL             reduce using rule 61 (conjunction -> inversion AND inversion .)
    GLOBAL          reduce using rule 61 (conjunction -> inversion AND inversion .)
    ELIF            reduce using rule 61 (conjunction -> inversion AND inversion .)
    ELSE            reduce using rule 61 (conjunction -> inversion AND inversion .)
    DEDENT          reduce using rule 61 (conjunction -> inversion AND inversion .)
    R_SQB           reduce using rule 61 (conjunction -> inversion AND inversion .)
    R_PARENTHESIS   reduce using rule 61 (conjunction -> inversion AND inversion .)


state 131

    (67) compare_op_list -> compare_op_list compare_op .

    EQUALITY        reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    INEQUALITY      reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GREATER_EQUAL   reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    LESSER_EQUAL    reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GREATER         reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    LESSER          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NOT             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IS              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IN              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    AND             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    OR              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IF              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    COLON           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    COMMA           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NEWLINE         reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    SEMICOLON       reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ENDMARKER       reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEF             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    CLASS           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    FOR             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    WHILE           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    PASS            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    BREAK           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    CONTINUE        reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IDENTIFIER      reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    RETURN          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEL             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GLOBAL          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ELIF            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ELSE            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEDENT          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    R_SQB           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    R_PARENTHESIS   reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)


state 132

    (78) bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .
    (80) bitwise_xor -> bitwise_xor . BITWISE_XOR bitwise_and

    BITWISE_OR      reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    EQUALITY        reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    INEQUALITY      reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GREATER_EQUAL   reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    LESSER_EQUAL    reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GREATER         reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    LESSER          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NOT             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IS              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IN              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    AND             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    OR              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IF              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    COLON           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    COMMA           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NEWLINE         reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    SEMICOLON       reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ENDMARKER       reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEF             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    CLASS           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    FOR             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    WHILE           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    PASS            reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    BREAK           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    CONTINUE        reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IDENTIFIER      reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    RETURN          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEL             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GLOBAL          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ELIF            reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ELSE            reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEDENT          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    R_SQB           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    R_PARENTHESIS   reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    BITWISE_XOR     shift and go to state 99


state 133

    (68) compare_op -> EQUALITY bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    INEQUALITY      reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    GREATER_EQUAL   reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    LESSER_EQUAL    reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    GREATER         reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    LESSER          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    NOT             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IS              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IN              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    AND             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    OR              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IF              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    COLON           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    COMMA           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    NEWLINE         reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    SEMICOLON       reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    ENDMARKER       reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    DEF             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    CLASS           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    FOR             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    WHILE           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    PASS            reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    BREAK           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    CONTINUE        reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IDENTIFIER      reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    RETURN          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    DEL             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    GLOBAL          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    ELIF            reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    ELSE            reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    DEDENT          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    R_SQB           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    R_PARENTHESIS   reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 134

    (69) compare_op -> INEQUALITY bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    INEQUALITY      reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    GREATER_EQUAL   reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    LESSER_EQUAL    reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    GREATER         reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    LESSER          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    NOT             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IS              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IN              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    AND             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    OR              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IF              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    COLON           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    COMMA           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    NEWLINE         reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    SEMICOLON       reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    ENDMARKER       reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    DEF             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    CLASS           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    FOR             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    WHILE           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    PASS            reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    BREAK           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    CONTINUE        reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IDENTIFIER      reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    RETURN          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    DEL             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    GLOBAL          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    ELIF            reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    ELSE            reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    DEDENT          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    R_SQB           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    R_PARENTHESIS   reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 135

    (70) compare_op -> GREATER_EQUAL bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    INEQUALITY      reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    GREATER_EQUAL   reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    LESSER_EQUAL    reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    GREATER         reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    LESSER          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    NOT             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IS              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IN              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    AND             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    OR              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IF              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    COLON           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    COMMA           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    NEWLINE         reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    SEMICOLON       reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    ENDMARKER       reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEF             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    CLASS           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    FOR             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    WHILE           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    PASS            reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    BREAK           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    CONTINUE        reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IDENTIFIER      reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    RETURN          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEL             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    GLOBAL          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    ELIF            reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    ELSE            reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEDENT          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    R_SQB           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    R_PARENTHESIS   reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 136

    (71) compare_op -> LESSER_EQUAL bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    INEQUALITY      reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    GREATER_EQUAL   reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    LESSER_EQUAL    reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    GREATER         reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    LESSER          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    NOT             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IS              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IN              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    AND             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    OR              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IF              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    COLON           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    COMMA           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    NEWLINE         reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    SEMICOLON       reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    ENDMARKER       reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEF             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    CLASS           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    FOR             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    WHILE           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    PASS            reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    BREAK           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    CONTINUE        reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IDENTIFIER      reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    RETURN          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEL             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    GLOBAL          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    ELIF            reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    ELSE            reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEDENT          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    R_SQB           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    R_PARENTHESIS   reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 137

    (72) compare_op -> GREATER bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    INEQUALITY      reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    GREATER_EQUAL   reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    LESSER_EQUAL    reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    GREATER         reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    LESSER          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    NOT             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IS              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IN              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    AND             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    OR              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IF              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    COLON           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    COMMA           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    NEWLINE         reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    SEMICOLON       reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    ENDMARKER       reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    DEF             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    CLASS           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    FOR             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    WHILE           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    PASS            reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    BREAK           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    CONTINUE        reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IDENTIFIER      reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    RETURN          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    DEL             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    GLOBAL          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    ELIF            reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    ELSE            reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    DEDENT          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    R_SQB           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    R_PARENTHESIS   reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 138

    (73) compare_op -> LESSER bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    INEQUALITY      reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    GREATER_EQUAL   reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    LESSER_EQUAL    reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    GREATER         reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    LESSER          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    NOT             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IS              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IN              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    AND             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    OR              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IF              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    COLON           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    COMMA           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    NEWLINE         reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    SEMICOLON       reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    ENDMARKER       reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    DEF             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    CLASS           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    FOR             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    WHILE           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    PASS            reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    BREAK           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    CONTINUE        reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IDENTIFIER      reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    RETURN          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    DEL             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    GLOBAL          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    ELIF            reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    ELSE            reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    DEDENT          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    R_SQB           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    R_PARENTHESIS   reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 139

    (74) compare_op -> NOT IN . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 177
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 140

    (76) compare_op -> IN bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 76 (compare_op -> IN bitwise_or .)
    INEQUALITY      reduce using rule 76 (compare_op -> IN bitwise_or .)
    GREATER_EQUAL   reduce using rule 76 (compare_op -> IN bitwise_or .)
    LESSER_EQUAL    reduce using rule 76 (compare_op -> IN bitwise_or .)
    GREATER         reduce using rule 76 (compare_op -> IN bitwise_or .)
    LESSER          reduce using rule 76 (compare_op -> IN bitwise_or .)
    NOT             reduce using rule 76 (compare_op -> IN bitwise_or .)
    IS              reduce using rule 76 (compare_op -> IN bitwise_or .)
    IN              reduce using rule 76 (compare_op -> IN bitwise_or .)
    AND             reduce using rule 76 (compare_op -> IN bitwise_or .)
    OR              reduce using rule 76 (compare_op -> IN bitwise_or .)
    IF              reduce using rule 76 (compare_op -> IN bitwise_or .)
    COLON           reduce using rule 76 (compare_op -> IN bitwise_or .)
    COMMA           reduce using rule 76 (compare_op -> IN bitwise_or .)
    NEWLINE         reduce using rule 76 (compare_op -> IN bitwise_or .)
    SEMICOLON       reduce using rule 76 (compare_op -> IN bitwise_or .)
    ENDMARKER       reduce using rule 76 (compare_op -> IN bitwise_or .)
    DEF             reduce using rule 76 (compare_op -> IN bitwise_or .)
    CLASS           reduce using rule 76 (compare_op -> IN bitwise_or .)
    FOR             reduce using rule 76 (compare_op -> IN bitwise_or .)
    WHILE           reduce using rule 76 (compare_op -> IN bitwise_or .)
    PASS            reduce using rule 76 (compare_op -> IN bitwise_or .)
    BREAK           reduce using rule 76 (compare_op -> IN bitwise_or .)
    CONTINUE        reduce using rule 76 (compare_op -> IN bitwise_or .)
    IDENTIFIER      reduce using rule 76 (compare_op -> IN bitwise_or .)
    RETURN          reduce using rule 76 (compare_op -> IN bitwise_or .)
    DEL             reduce using rule 76 (compare_op -> IN bitwise_or .)
    GLOBAL          reduce using rule 76 (compare_op -> IN bitwise_or .)
    ELIF            reduce using rule 76 (compare_op -> IN bitwise_or .)
    ELSE            reduce using rule 76 (compare_op -> IN bitwise_or .)
    DEDENT          reduce using rule 76 (compare_op -> IN bitwise_or .)
    R_SQB           reduce using rule 76 (compare_op -> IN bitwise_or .)
    R_PARENTHESIS   reduce using rule 76 (compare_op -> IN bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 141

    (75) compare_op -> IS NOT . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    bitwise_or                     shift and go to state 178
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 142

    (77) compare_op -> IS bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 77 (compare_op -> IS bitwise_or .)
    INEQUALITY      reduce using rule 77 (compare_op -> IS bitwise_or .)
    GREATER_EQUAL   reduce using rule 77 (compare_op -> IS bitwise_or .)
    LESSER_EQUAL    reduce using rule 77 (compare_op -> IS bitwise_or .)
    GREATER         reduce using rule 77 (compare_op -> IS bitwise_or .)
    LESSER          reduce using rule 77 (compare_op -> IS bitwise_or .)
    NOT             reduce using rule 77 (compare_op -> IS bitwise_or .)
    IS              reduce using rule 77 (compare_op -> IS bitwise_or .)
    IN              reduce using rule 77 (compare_op -> IS bitwise_or .)
    AND             reduce using rule 77 (compare_op -> IS bitwise_or .)
    OR              reduce using rule 77 (compare_op -> IS bitwise_or .)
    IF              reduce using rule 77 (compare_op -> IS bitwise_or .)
    COLON           reduce using rule 77 (compare_op -> IS bitwise_or .)
    COMMA           reduce using rule 77 (compare_op -> IS bitwise_or .)
    NEWLINE         reduce using rule 77 (compare_op -> IS bitwise_or .)
    SEMICOLON       reduce using rule 77 (compare_op -> IS bitwise_or .)
    ENDMARKER       reduce using rule 77 (compare_op -> IS bitwise_or .)
    DEF             reduce using rule 77 (compare_op -> IS bitwise_or .)
    CLASS           reduce using rule 77 (compare_op -> IS bitwise_or .)
    FOR             reduce using rule 77 (compare_op -> IS bitwise_or .)
    WHILE           reduce using rule 77 (compare_op -> IS bitwise_or .)
    PASS            reduce using rule 77 (compare_op -> IS bitwise_or .)
    BREAK           reduce using rule 77 (compare_op -> IS bitwise_or .)
    CONTINUE        reduce using rule 77 (compare_op -> IS bitwise_or .)
    IDENTIFIER      reduce using rule 77 (compare_op -> IS bitwise_or .)
    RETURN          reduce using rule 77 (compare_op -> IS bitwise_or .)
    DEL             reduce using rule 77 (compare_op -> IS bitwise_or .)
    GLOBAL          reduce using rule 77 (compare_op -> IS bitwise_or .)
    ELIF            reduce using rule 77 (compare_op -> IS bitwise_or .)
    ELSE            reduce using rule 77 (compare_op -> IS bitwise_or .)
    DEDENT          reduce using rule 77 (compare_op -> IS bitwise_or .)
    R_SQB           reduce using rule 77 (compare_op -> IS bitwise_or .)
    R_PARENTHESIS   reduce using rule 77 (compare_op -> IS bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 143

    (80) bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .
    (82) bitwise_and -> bitwise_and . BITWISE_AND shift_expr

    BITWISE_XOR     reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    BITWISE_OR      reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    EQUALITY        reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    INEQUALITY      reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    GREATER_EQUAL   reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    LESSER_EQUAL    reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    GREATER         reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    LESSER          reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    NOT             reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IS              reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IN              reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    AND             reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    OR              reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IF              reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    COLON           reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    COMMA           reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    NEWLINE         reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    SEMICOLON       reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    ENDMARKER       reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    DEF             reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    CLASS           reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    FOR             reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    WHILE           reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    PASS            reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    BREAK           reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    CONTINUE        reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IDENTIFIER      reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    RETURN          reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    DEL             reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    GLOBAL          reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    ELIF            reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    ELSE            reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    DEDENT          reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    R_SQB           reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    R_PARENTHESIS   reduce using rule 80 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    BITWISE_AND     shift and go to state 100


state 144

    (82) bitwise_and -> bitwise_and BITWISE_AND shift_expr .
    (84) shift_expr -> shift_expr . L_SHIFT sum
    (85) shift_expr -> shift_expr . R_SHIFT sum

    BITWISE_AND     reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BITWISE_XOR     reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BITWISE_OR      reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    EQUALITY        reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    INEQUALITY      reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GREATER_EQUAL   reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    LESSER_EQUAL    reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GREATER         reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    LESSER          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NOT             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IS              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IN              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    AND             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    OR              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IF              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    COLON           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    COMMA           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NEWLINE         reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    SEMICOLON       reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ENDMARKER       reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEF             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    CLASS           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    FOR             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    WHILE           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    PASS            reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BREAK           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    CONTINUE        reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IDENTIFIER      reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    RETURN          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEL             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GLOBAL          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ELIF            reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ELSE            reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEDENT          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    R_SQB           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    R_PARENTHESIS   reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    L_SHIFT         shift and go to state 101
    R_SHIFT         shift and go to state 102


state 145

    (84) shift_expr -> shift_expr L_SHIFT sum .
    (87) sum -> sum . SUM term
    (88) sum -> sum . SUBTRACTION term

    L_SHIFT         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    R_SHIFT         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_AND     reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_XOR     reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_OR      reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    EQUALITY        reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    INEQUALITY      reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    GREATER_EQUAL   reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    LESSER_EQUAL    reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    GREATER         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    LESSER          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    NOT             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IS              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IN              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    AND             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    OR              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IF              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    COLON           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    COMMA           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    NEWLINE         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    SEMICOLON       reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    ENDMARKER       reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    DEF             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    CLASS           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    FOR             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    WHILE           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    PASS            reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    BREAK           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    CONTINUE        reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IDENTIFIER      reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    RETURN          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    DEL             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    GLOBAL          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    ELIF            reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    ELSE            reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    DEDENT          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    R_SQB           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    R_PARENTHESIS   reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    SUM             shift and go to state 103
    SUBTRACTION     shift and go to state 104


state 146

    (85) shift_expr -> shift_expr R_SHIFT sum .
    (87) sum -> sum . SUM term
    (88) sum -> sum . SUBTRACTION term

    L_SHIFT         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    R_SHIFT         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_AND     reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_XOR     reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_OR      reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    EQUALITY        reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    INEQUALITY      reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    GREATER_EQUAL   reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    LESSER_EQUAL    reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    GREATER         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    LESSER          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    NOT             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IS              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IN              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    AND             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    OR              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IF              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    COLON           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    COMMA           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    NEWLINE         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    SEMICOLON       reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    ENDMARKER       reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    DEF             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    CLASS           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    FOR             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    WHILE           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    PASS            reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    BREAK           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    CONTINUE        reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IDENTIFIER      reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    RETURN          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    DEL             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    GLOBAL          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    ELIF            reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    ELSE            reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    DEDENT          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    R_SQB           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    R_PARENTHESIS   reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    SUM             shift and go to state 103
    SUBTRACTION     shift and go to state 104


state 147

    (87) sum -> sum SUM term .
    (90) term -> term . PRODUCT factor
    (91) term -> term . DIVISION factor
    (92) term -> term . INTEGER_DIVISION factor
    (93) term -> term . MODULUS factor

    SUM             reduce using rule 87 (sum -> sum SUM term .)
    SUBTRACTION     reduce using rule 87 (sum -> sum SUM term .)
    L_SHIFT         reduce using rule 87 (sum -> sum SUM term .)
    R_SHIFT         reduce using rule 87 (sum -> sum SUM term .)
    BITWISE_AND     reduce using rule 87 (sum -> sum SUM term .)
    BITWISE_XOR     reduce using rule 87 (sum -> sum SUM term .)
    BITWISE_OR      reduce using rule 87 (sum -> sum SUM term .)
    EQUALITY        reduce using rule 87 (sum -> sum SUM term .)
    INEQUALITY      reduce using rule 87 (sum -> sum SUM term .)
    GREATER_EQUAL   reduce using rule 87 (sum -> sum SUM term .)
    LESSER_EQUAL    reduce using rule 87 (sum -> sum SUM term .)
    GREATER         reduce using rule 87 (sum -> sum SUM term .)
    LESSER          reduce using rule 87 (sum -> sum SUM term .)
    NOT             reduce using rule 87 (sum -> sum SUM term .)
    IS              reduce using rule 87 (sum -> sum SUM term .)
    IN              reduce using rule 87 (sum -> sum SUM term .)
    AND             reduce using rule 87 (sum -> sum SUM term .)
    OR              reduce using rule 87 (sum -> sum SUM term .)
    IF              reduce using rule 87 (sum -> sum SUM term .)
    COLON           reduce using rule 87 (sum -> sum SUM term .)
    COMMA           reduce using rule 87 (sum -> sum SUM term .)
    NEWLINE         reduce using rule 87 (sum -> sum SUM term .)
    SEMICOLON       reduce using rule 87 (sum -> sum SUM term .)
    ENDMARKER       reduce using rule 87 (sum -> sum SUM term .)
    DEF             reduce using rule 87 (sum -> sum SUM term .)
    CLASS           reduce using rule 87 (sum -> sum SUM term .)
    FOR             reduce using rule 87 (sum -> sum SUM term .)
    WHILE           reduce using rule 87 (sum -> sum SUM term .)
    PASS            reduce using rule 87 (sum -> sum SUM term .)
    BREAK           reduce using rule 87 (sum -> sum SUM term .)
    CONTINUE        reduce using rule 87 (sum -> sum SUM term .)
    IDENTIFIER      reduce using rule 87 (sum -> sum SUM term .)
    RETURN          reduce using rule 87 (sum -> sum SUM term .)
    DEL             reduce using rule 87 (sum -> sum SUM term .)
    GLOBAL          reduce using rule 87 (sum -> sum SUM term .)
    ELIF            reduce using rule 87 (sum -> sum SUM term .)
    ELSE            reduce using rule 87 (sum -> sum SUM term .)
    DEDENT          reduce using rule 87 (sum -> sum SUM term .)
    R_SQB           reduce using rule 87 (sum -> sum SUM term .)
    R_PARENTHESIS   reduce using rule 87 (sum -> sum SUM term .)
    PRODUCT         shift and go to state 106
    DIVISION        shift and go to state 107
    INTEGER_DIVISION shift and go to state 108
    MODULUS         shift and go to state 109


state 148

    (88) sum -> sum SUBTRACTION term .
    (90) term -> term . PRODUCT factor
    (91) term -> term . DIVISION factor
    (92) term -> term . INTEGER_DIVISION factor
    (93) term -> term . MODULUS factor

    SUM             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    SUBTRACTION     reduce using rule 88 (sum -> sum SUBTRACTION term .)
    L_SHIFT         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    R_SHIFT         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    BITWISE_AND     reduce using rule 88 (sum -> sum SUBTRACTION term .)
    BITWISE_XOR     reduce using rule 88 (sum -> sum SUBTRACTION term .)
    BITWISE_OR      reduce using rule 88 (sum -> sum SUBTRACTION term .)
    EQUALITY        reduce using rule 88 (sum -> sum SUBTRACTION term .)
    INEQUALITY      reduce using rule 88 (sum -> sum SUBTRACTION term .)
    GREATER_EQUAL   reduce using rule 88 (sum -> sum SUBTRACTION term .)
    LESSER_EQUAL    reduce using rule 88 (sum -> sum SUBTRACTION term .)
    GREATER         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    LESSER          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    NOT             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IS              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IN              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    AND             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    OR              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IF              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    COLON           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    COMMA           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    NEWLINE         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    SEMICOLON       reduce using rule 88 (sum -> sum SUBTRACTION term .)
    ENDMARKER       reduce using rule 88 (sum -> sum SUBTRACTION term .)
    DEF             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    CLASS           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    FOR             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    WHILE           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    PASS            reduce using rule 88 (sum -> sum SUBTRACTION term .)
    BREAK           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    CONTINUE        reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IDENTIFIER      reduce using rule 88 (sum -> sum SUBTRACTION term .)
    RETURN          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    DEL             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    GLOBAL          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    ELIF            reduce using rule 88 (sum -> sum SUBTRACTION term .)
    ELSE            reduce using rule 88 (sum -> sum SUBTRACTION term .)
    DEDENT          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    R_SQB           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    R_PARENTHESIS   reduce using rule 88 (sum -> sum SUBTRACTION term .)
    PRODUCT         shift and go to state 106
    DIVISION        shift and go to state 107
    INTEGER_DIVISION shift and go to state 108
    MODULUS         shift and go to state 109


state 149

    (90) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 90 (term -> term PRODUCT factor .)
    DIVISION        reduce using rule 90 (term -> term PRODUCT factor .)
    INTEGER_DIVISION reduce using rule 90 (term -> term PRODUCT factor .)
    MODULUS         reduce using rule 90 (term -> term PRODUCT factor .)
    SUM             reduce using rule 90 (term -> term PRODUCT factor .)
    SUBTRACTION     reduce using rule 90 (term -> term PRODUCT factor .)
    L_SHIFT         reduce using rule 90 (term -> term PRODUCT factor .)
    R_SHIFT         reduce using rule 90 (term -> term PRODUCT factor .)
    BITWISE_AND     reduce using rule 90 (term -> term PRODUCT factor .)
    BITWISE_XOR     reduce using rule 90 (term -> term PRODUCT factor .)
    BITWISE_OR      reduce using rule 90 (term -> term PRODUCT factor .)
    EQUALITY        reduce using rule 90 (term -> term PRODUCT factor .)
    INEQUALITY      reduce using rule 90 (term -> term PRODUCT factor .)
    GREATER_EQUAL   reduce using rule 90 (term -> term PRODUCT factor .)
    LESSER_EQUAL    reduce using rule 90 (term -> term PRODUCT factor .)
    GREATER         reduce using rule 90 (term -> term PRODUCT factor .)
    LESSER          reduce using rule 90 (term -> term PRODUCT factor .)
    NOT             reduce using rule 90 (term -> term PRODUCT factor .)
    IS              reduce using rule 90 (term -> term PRODUCT factor .)
    IN              reduce using rule 90 (term -> term PRODUCT factor .)
    AND             reduce using rule 90 (term -> term PRODUCT factor .)
    OR              reduce using rule 90 (term -> term PRODUCT factor .)
    IF              reduce using rule 90 (term -> term PRODUCT factor .)
    COLON           reduce using rule 90 (term -> term PRODUCT factor .)
    COMMA           reduce using rule 90 (term -> term PRODUCT factor .)
    NEWLINE         reduce using rule 90 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 90 (term -> term PRODUCT factor .)
    ENDMARKER       reduce using rule 90 (term -> term PRODUCT factor .)
    DEF             reduce using rule 90 (term -> term PRODUCT factor .)
    CLASS           reduce using rule 90 (term -> term PRODUCT factor .)
    FOR             reduce using rule 90 (term -> term PRODUCT factor .)
    WHILE           reduce using rule 90 (term -> term PRODUCT factor .)
    PASS            reduce using rule 90 (term -> term PRODUCT factor .)
    BREAK           reduce using rule 90 (term -> term PRODUCT factor .)
    CONTINUE        reduce using rule 90 (term -> term PRODUCT factor .)
    IDENTIFIER      reduce using rule 90 (term -> term PRODUCT factor .)
    RETURN          reduce using rule 90 (term -> term PRODUCT factor .)
    DEL             reduce using rule 90 (term -> term PRODUCT factor .)
    GLOBAL          reduce using rule 90 (term -> term PRODUCT factor .)
    ELIF            reduce using rule 90 (term -> term PRODUCT factor .)
    ELSE            reduce using rule 90 (term -> term PRODUCT factor .)
    DEDENT          reduce using rule 90 (term -> term PRODUCT factor .)
    R_SQB           reduce using rule 90 (term -> term PRODUCT factor .)
    R_PARENTHESIS   reduce using rule 90 (term -> term PRODUCT factor .)


state 150

    (91) term -> term DIVISION factor .

    PRODUCT         reduce using rule 91 (term -> term DIVISION factor .)
    DIVISION        reduce using rule 91 (term -> term DIVISION factor .)
    INTEGER_DIVISION reduce using rule 91 (term -> term DIVISION factor .)
    MODULUS         reduce using rule 91 (term -> term DIVISION factor .)
    SUM             reduce using rule 91 (term -> term DIVISION factor .)
    SUBTRACTION     reduce using rule 91 (term -> term DIVISION factor .)
    L_SHIFT         reduce using rule 91 (term -> term DIVISION factor .)
    R_SHIFT         reduce using rule 91 (term -> term DIVISION factor .)
    BITWISE_AND     reduce using rule 91 (term -> term DIVISION factor .)
    BITWISE_XOR     reduce using rule 91 (term -> term DIVISION factor .)
    BITWISE_OR      reduce using rule 91 (term -> term DIVISION factor .)
    EQUALITY        reduce using rule 91 (term -> term DIVISION factor .)
    INEQUALITY      reduce using rule 91 (term -> term DIVISION factor .)
    GREATER_EQUAL   reduce using rule 91 (term -> term DIVISION factor .)
    LESSER_EQUAL    reduce using rule 91 (term -> term DIVISION factor .)
    GREATER         reduce using rule 91 (term -> term DIVISION factor .)
    LESSER          reduce using rule 91 (term -> term DIVISION factor .)
    NOT             reduce using rule 91 (term -> term DIVISION factor .)
    IS              reduce using rule 91 (term -> term DIVISION factor .)
    IN              reduce using rule 91 (term -> term DIVISION factor .)
    AND             reduce using rule 91 (term -> term DIVISION factor .)
    OR              reduce using rule 91 (term -> term DIVISION factor .)
    IF              reduce using rule 91 (term -> term DIVISION factor .)
    COLON           reduce using rule 91 (term -> term DIVISION factor .)
    COMMA           reduce using rule 91 (term -> term DIVISION factor .)
    NEWLINE         reduce using rule 91 (term -> term DIVISION factor .)
    SEMICOLON       reduce using rule 91 (term -> term DIVISION factor .)
    ENDMARKER       reduce using rule 91 (term -> term DIVISION factor .)
    DEF             reduce using rule 91 (term -> term DIVISION factor .)
    CLASS           reduce using rule 91 (term -> term DIVISION factor .)
    FOR             reduce using rule 91 (term -> term DIVISION factor .)
    WHILE           reduce using rule 91 (term -> term DIVISION factor .)
    PASS            reduce using rule 91 (term -> term DIVISION factor .)
    BREAK           reduce using rule 91 (term -> term DIVISION factor .)
    CONTINUE        reduce using rule 91 (term -> term DIVISION factor .)
    IDENTIFIER      reduce using rule 91 (term -> term DIVISION factor .)
    RETURN          reduce using rule 91 (term -> term DIVISION factor .)
    DEL             reduce using rule 91 (term -> term DIVISION factor .)
    GLOBAL          reduce using rule 91 (term -> term DIVISION factor .)
    ELIF            reduce using rule 91 (term -> term DIVISION factor .)
    ELSE            reduce using rule 91 (term -> term DIVISION factor .)
    DEDENT          reduce using rule 91 (term -> term DIVISION factor .)
    R_SQB           reduce using rule 91 (term -> term DIVISION factor .)
    R_PARENTHESIS   reduce using rule 91 (term -> term DIVISION factor .)


state 151

    (92) term -> term INTEGER_DIVISION factor .

    PRODUCT         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DIVISION        reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    INTEGER_DIVISION reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    MODULUS         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    SUM             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    SUBTRACTION     reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    L_SHIFT         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    R_SHIFT         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    BITWISE_AND     reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    BITWISE_XOR     reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    BITWISE_OR      reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    EQUALITY        reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    INEQUALITY      reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    GREATER_EQUAL   reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    LESSER_EQUAL    reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    GREATER         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    LESSER          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    NOT             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IS              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IN              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    AND             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    OR              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IF              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    COLON           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    COMMA           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    NEWLINE         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    SEMICOLON       reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    ENDMARKER       reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DEF             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    CLASS           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    FOR             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    WHILE           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    PASS            reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    BREAK           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    CONTINUE        reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IDENTIFIER      reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    RETURN          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DEL             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    GLOBAL          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    ELIF            reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    ELSE            reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DEDENT          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    R_SQB           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    R_PARENTHESIS   reduce using rule 92 (term -> term INTEGER_DIVISION factor .)


state 152

    (93) term -> term MODULUS factor .

    PRODUCT         reduce using rule 93 (term -> term MODULUS factor .)
    DIVISION        reduce using rule 93 (term -> term MODULUS factor .)
    INTEGER_DIVISION reduce using rule 93 (term -> term MODULUS factor .)
    MODULUS         reduce using rule 93 (term -> term MODULUS factor .)
    SUM             reduce using rule 93 (term -> term MODULUS factor .)
    SUBTRACTION     reduce using rule 93 (term -> term MODULUS factor .)
    L_SHIFT         reduce using rule 93 (term -> term MODULUS factor .)
    R_SHIFT         reduce using rule 93 (term -> term MODULUS factor .)
    BITWISE_AND     reduce using rule 93 (term -> term MODULUS factor .)
    BITWISE_XOR     reduce using rule 93 (term -> term MODULUS factor .)
    BITWISE_OR      reduce using rule 93 (term -> term MODULUS factor .)
    EQUALITY        reduce using rule 93 (term -> term MODULUS factor .)
    INEQUALITY      reduce using rule 93 (term -> term MODULUS factor .)
    GREATER_EQUAL   reduce using rule 93 (term -> term MODULUS factor .)
    LESSER_EQUAL    reduce using rule 93 (term -> term MODULUS factor .)
    GREATER         reduce using rule 93 (term -> term MODULUS factor .)
    LESSER          reduce using rule 93 (term -> term MODULUS factor .)
    NOT             reduce using rule 93 (term -> term MODULUS factor .)
    IS              reduce using rule 93 (term -> term MODULUS factor .)
    IN              reduce using rule 93 (term -> term MODULUS factor .)
    AND             reduce using rule 93 (term -> term MODULUS factor .)
    OR              reduce using rule 93 (term -> term MODULUS factor .)
    IF              reduce using rule 93 (term -> term MODULUS factor .)
    COLON           reduce using rule 93 (term -> term MODULUS factor .)
    COMMA           reduce using rule 93 (term -> term MODULUS factor .)
    NEWLINE         reduce using rule 93 (term -> term MODULUS factor .)
    SEMICOLON       reduce using rule 93 (term -> term MODULUS factor .)
    ENDMARKER       reduce using rule 93 (term -> term MODULUS factor .)
    DEF             reduce using rule 93 (term -> term MODULUS factor .)
    CLASS           reduce using rule 93 (term -> term MODULUS factor .)
    FOR             reduce using rule 93 (term -> term MODULUS factor .)
    WHILE           reduce using rule 93 (term -> term MODULUS factor .)
    PASS            reduce using rule 93 (term -> term MODULUS factor .)
    BREAK           reduce using rule 93 (term -> term MODULUS factor .)
    CONTINUE        reduce using rule 93 (term -> term MODULUS factor .)
    IDENTIFIER      reduce using rule 93 (term -> term MODULUS factor .)
    RETURN          reduce using rule 93 (term -> term MODULUS factor .)
    DEL             reduce using rule 93 (term -> term MODULUS factor .)
    GLOBAL          reduce using rule 93 (term -> term MODULUS factor .)
    ELIF            reduce using rule 93 (term -> term MODULUS factor .)
    ELSE            reduce using rule 93 (term -> term MODULUS factor .)
    DEDENT          reduce using rule 93 (term -> term MODULUS factor .)
    R_SQB           reduce using rule 93 (term -> term MODULUS factor .)
    R_PARENTHESIS   reduce using rule 93 (term -> term MODULUS factor .)


state 153

    (98) power -> primary EXPONENTIATION target .

    PRODUCT         reduce using rule 98 (power -> primary EXPONENTIATION target .)
    DIVISION        reduce using rule 98 (power -> primary EXPONENTIATION target .)
    INTEGER_DIVISION reduce using rule 98 (power -> primary EXPONENTIATION target .)
    MODULUS         reduce using rule 98 (power -> primary EXPONENTIATION target .)
    SUM             reduce using rule 98 (power -> primary EXPONENTIATION target .)
    SUBTRACTION     reduce using rule 98 (power -> primary EXPONENTIATION target .)
    L_SHIFT         reduce using rule 98 (power -> primary EXPONENTIATION target .)
    R_SHIFT         reduce using rule 98 (power -> primary EXPONENTIATION target .)
    BITWISE_AND     reduce using rule 98 (power -> primary EXPONENTIATION target .)
    BITWISE_XOR     reduce using rule 98 (power -> primary EXPONENTIATION target .)
    BITWISE_OR      reduce using rule 98 (power -> primary EXPONENTIATION target .)
    EQUALITY        reduce using rule 98 (power -> primary EXPONENTIATION target .)
    INEQUALITY      reduce using rule 98 (power -> primary EXPONENTIATION target .)
    GREATER_EQUAL   reduce using rule 98 (power -> primary EXPONENTIATION target .)
    LESSER_EQUAL    reduce using rule 98 (power -> primary EXPONENTIATION target .)
    GREATER         reduce using rule 98 (power -> primary EXPONENTIATION target .)
    LESSER          reduce using rule 98 (power -> primary EXPONENTIATION target .)
    NOT             reduce using rule 98 (power -> primary EXPONENTIATION target .)
    IS              reduce using rule 98 (power -> primary EXPONENTIATION target .)
    IN              reduce using rule 98 (power -> primary EXPONENTIATION target .)
    AND             reduce using rule 98 (power -> primary EXPONENTIATION target .)
    OR              reduce using rule 98 (power -> primary EXPONENTIATION target .)
    IF              reduce using rule 98 (power -> primary EXPONENTIATION target .)
    COLON           reduce using rule 98 (power -> primary EXPONENTIATION target .)
    COMMA           reduce using rule 98 (power -> primary EXPONENTIATION target .)
    NEWLINE         reduce using rule 98 (power -> primary EXPONENTIATION target .)
    SEMICOLON       reduce using rule 98 (power -> primary EXPONENTIATION target .)
    ENDMARKER       reduce using rule 98 (power -> primary EXPONENTIATION target .)
    DEF             reduce using rule 98 (power -> primary EXPONENTIATION target .)
    CLASS           reduce using rule 98 (power -> primary EXPONENTIATION target .)
    FOR             reduce using rule 98 (power -> primary EXPONENTIATION target .)
    WHILE           reduce using rule 98 (power -> primary EXPONENTIATION target .)
    PASS            reduce using rule 98 (power -> primary EXPONENTIATION target .)
    BREAK           reduce using rule 98 (power -> primary EXPONENTIATION target .)
    CONTINUE        reduce using rule 98 (power -> primary EXPONENTIATION target .)
    IDENTIFIER      reduce using rule 98 (power -> primary EXPONENTIATION target .)
    RETURN          reduce using rule 98 (power -> primary EXPONENTIATION target .)
    DEL             reduce using rule 98 (power -> primary EXPONENTIATION target .)
    GLOBAL          reduce using rule 98 (power -> primary EXPONENTIATION target .)
    ELIF            reduce using rule 98 (power -> primary EXPONENTIATION target .)
    ELSE            reduce using rule 98 (power -> primary EXPONENTIATION target .)
    DEDENT          reduce using rule 98 (power -> primary EXPONENTIATION target .)
    R_SQB           reduce using rule 98 (power -> primary EXPONENTIATION target .)
    R_PARENTHESIS   reduce using rule 98 (power -> primary EXPONENTIATION target .)


state 154

    (100) primary -> primary DOT IDENTIFIER .

    EXPONENTIATION  reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    DOT             reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    L_PARENTHESIS   reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    L_SQB           reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    PRODUCT         reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    DIVISION        reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    INTEGER_DIVISION reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    MODULUS         reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    SUM             reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    SUBTRACTION     reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    L_SHIFT         reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    R_SHIFT         reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    BITWISE_AND     reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    BITWISE_XOR     reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    BITWISE_OR      reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    EQUALITY        reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    INEQUALITY      reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    LESSER_EQUAL    reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    GREATER         reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    LESSER          reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    NOT             reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    IS              reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    IN              reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    AND             reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    OR              reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    IF              reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    COLON           reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    COMMA           reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    NEWLINE         reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    ENDMARKER       reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    DEF             reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    CLASS           reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    FOR             reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    WHILE           reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    PASS            reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    BREAK           reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    CONTINUE        reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    RETURN          reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    DEL             reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    GLOBAL          reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    ELIF            reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    ELSE            reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    DEDENT          reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    R_SQB           reduce using rule 100 (primary -> primary DOT IDENTIFIER .)
    R_PARENTHESIS   reduce using rule 100 (primary -> primary DOT IDENTIFIER .)


state 155

    (101) primary -> primary L_PARENTHESIS arguments . R_PARENTHESIS

    R_PARENTHESIS   shift and go to state 179


state 156

    (102) primary -> primary L_SQB slices . R_SQB

    R_SQB           shift and go to state 180


state 157

    (104) slices -> slice .

    R_SQB           reduce using rule 104 (slices -> slice .)


state 158

    (105) slices -> COMMA . L_PARENTHESIS slice R_PARENTHESIS slices

    L_PARENTHESIS   shift and go to state 181


state 159

    (106) slice -> expression .

    R_SQB           reduce using rule 106 (slice -> expression .)
    R_PARENTHESIS   reduce using rule 106 (slice -> expression .)


state 160

    (36) class_def -> CLASS IDENTIFIER COLON block .

    ENDMARKER       reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    DEF             reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    IF              reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    CLASS           reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    FOR             reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    WHILE           reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    PASS            reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    BREAK           reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    CONTINUE        reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    IDENTIFIER      reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    RETURN          reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    DEL             reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    GLOBAL          reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    DEDENT          reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)


state 161

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS . COLON block

    COLON           shift and go to state 182


state 162

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments . R_PARENTHESIS COLON block

    R_PARENTHESIS   shift and go to state 183


state 163

    (52) for_stmt -> FOR targets IN expressions . COLON else_block
    (53) for_stmt -> FOR targets IN expressions . COLON block
    (54) expressions -> expressions . COMMA expression

    COLON           shift and go to state 184
    COMMA           shift and go to state 120


state 164

    (118) targets -> target COMMA targets .

    IN              reduce using rule 118 (targets -> target COMMA targets .)


state 165

    (50) while_stmt -> WHILE expression COLON block . else_block
    (51) while_stmt -> WHILE expression COLON block .
    (49) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    DEF             reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    IF              reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    CLASS           reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    FOR             reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    WHILE           reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    PASS            reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    BREAK           reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    CONTINUE        reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    IDENTIFIER      reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    RETURN          reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    DEL             reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    GLOBAL          reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    DEDENT          reduce using rule 51 (while_stmt -> WHILE expression COLON block .)
    ELSE            shift and go to state 174

    else_block                     shift and go to state 185

state 166

    (54) expressions -> expressions COMMA expression .

    COMMA           reduce using rule 54 (expressions -> expressions COMMA expression .)
    NEWLINE         reduce using rule 54 (expressions -> expressions COMMA expression .)
    SEMICOLON       reduce using rule 54 (expressions -> expressions COMMA expression .)
    ENDMARKER       reduce using rule 54 (expressions -> expressions COMMA expression .)
    DEF             reduce using rule 54 (expressions -> expressions COMMA expression .)
    IF              reduce using rule 54 (expressions -> expressions COMMA expression .)
    CLASS           reduce using rule 54 (expressions -> expressions COMMA expression .)
    FOR             reduce using rule 54 (expressions -> expressions COMMA expression .)
    WHILE           reduce using rule 54 (expressions -> expressions COMMA expression .)
    PASS            reduce using rule 54 (expressions -> expressions COMMA expression .)
    BREAK           reduce using rule 54 (expressions -> expressions COMMA expression .)
    CONTINUE        reduce using rule 54 (expressions -> expressions COMMA expression .)
    IDENTIFIER      reduce using rule 54 (expressions -> expressions COMMA expression .)
    RETURN          reduce using rule 54 (expressions -> expressions COMMA expression .)
    DEL             reduce using rule 54 (expressions -> expressions COMMA expression .)
    GLOBAL          reduce using rule 54 (expressions -> expressions COMMA expression .)
    ELIF            reduce using rule 54 (expressions -> expressions COMMA expression .)
    ELSE            reduce using rule 54 (expressions -> expressions COMMA expression .)
    DEDENT          reduce using rule 54 (expressions -> expressions COMMA expression .)
    COLON           reduce using rule 54 (expressions -> expressions COMMA expression .)


state 167

    (32) namelist -> namelist COMMA IDENTIFIER .

    COMMA           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    NEWLINE         reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    SEMICOLON       reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    ENDMARKER       reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    DEF             reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    IF              reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    CLASS           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    FOR             reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    WHILE           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    PASS            reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    BREAK           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    CONTINUE        reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    IDENTIFIER      reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    RETURN          reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    DEL             reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    GLOBAL          reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    ELIF            reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    ELSE            reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    DEDENT          reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)


state 168

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS . COLON block

    COLON           shift and go to state 186


state 169

    (41) parameters -> parameters COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 187


state 170

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 188
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 171

    (43) if_stmt -> IF expression COLON block elif_stmt .

    ENDMARKER       reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    DEF             reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    IF              reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    CLASS           reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    FOR             reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    WHILE           reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    PASS            reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    BREAK           reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    CONTINUE        reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    IDENTIFIER      reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    RETURN          reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    DEL             reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    GLOBAL          reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)
    DEDENT          reduce using rule 43 (if_stmt -> IF expression COLON block elif_stmt .)


state 172

    (44) if_stmt -> IF expression COLON block else_block .

    ENDMARKER       reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    DEF             reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    IF              reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    CLASS           reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    FOR             reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    WHILE           reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    PASS            reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    BREAK           reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    CONTINUE        reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    IDENTIFIER      reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    RETURN          reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    DEL             reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    GLOBAL          reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)
    DEDENT          reduce using rule 44 (if_stmt -> IF expression COLON block else_block .)


state 173

    (46) elif_stmt -> ELIF . expression COLON block elif_stmt
    (47) elif_stmt -> ELIF . expression COLON block else_block
    (48) elif_stmt -> ELIF . expression COLON block
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    expression                     shift and go to state 189
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 174

    (49) else_block -> ELSE . COLON block

    COLON           shift and go to state 190


state 175

    (34) block -> NEWLINE INDENT . statements DEDENT
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF expression COLON block elif_stmt
    (44) if_stmt -> . IF expression COLON block else_block
    (45) if_stmt -> . IF expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (52) for_stmt -> . FOR targets IN expressions COLON else_block
    (53) for_stmt -> . FOR targets IN expressions COLON block
    (50) while_stmt -> . WHILE expression COLON block else_block
    (51) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    statements                     shift and go to state 191
    statement                      shift and go to state 3
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 176

    (57) expression -> disjunction IF disjunction ELSE . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    disjunction                    shift and go to state 43
    expression                     shift and go to state 192
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 177

    (74) compare_op -> NOT IN bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    INEQUALITY      reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    GREATER_EQUAL   reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    LESSER_EQUAL    reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    GREATER         reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    LESSER          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    NOT             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IS              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IN              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    AND             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    OR              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IF              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    COLON           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    COMMA           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    NEWLINE         reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    SEMICOLON       reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    ENDMARKER       reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    DEF             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    CLASS           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    FOR             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    WHILE           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    PASS            reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    BREAK           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    CONTINUE        reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IDENTIFIER      reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    RETURN          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    DEL             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    GLOBAL          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    ELIF            reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    ELSE            reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    DEDENT          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    R_SQB           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    R_PARENTHESIS   reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 178

    (75) compare_op -> IS NOT bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    INEQUALITY      reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    GREATER_EQUAL   reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    LESSER_EQUAL    reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    GREATER         reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    LESSER          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    NOT             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IS              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IN              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    AND             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    OR              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IF              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    COLON           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    COMMA           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    NEWLINE         reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    SEMICOLON       reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    ENDMARKER       reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    DEF             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    CLASS           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    FOR             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    WHILE           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    PASS            reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    BREAK           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    CONTINUE        reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IDENTIFIER      reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    RETURN          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    DEL             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    GLOBAL          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    ELIF            reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    ELSE            reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    DEDENT          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    R_SQB           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    R_PARENTHESIS   reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    BITWISE_OR      shift and go to state 88


state 179

    (101) primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .

    EXPONENTIATION  reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DOT             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    L_PARENTHESIS   reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    L_SQB           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    PRODUCT         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DIVISION        reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    INTEGER_DIVISION reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    MODULUS         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    SUM             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    SUBTRACTION     reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    L_SHIFT         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    R_SHIFT         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BITWISE_AND     reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BITWISE_XOR     reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BITWISE_OR      reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    EQUALITY        reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    INEQUALITY      reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    GREATER_EQUAL   reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    LESSER_EQUAL    reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    GREATER         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    LESSER          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    NOT             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IS              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IN              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    AND             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    OR              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IF              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    COLON           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    COMMA           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    NEWLINE         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    SEMICOLON       reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    ENDMARKER       reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DEF             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    CLASS           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    FOR             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    WHILE           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    PASS            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BREAK           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    CONTINUE        reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IDENTIFIER      reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    RETURN          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DEL             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    GLOBAL          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    ELIF            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    ELSE            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DEDENT          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    R_SQB           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    R_PARENTHESIS   reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)


state 180

    (102) primary -> primary L_SQB slices R_SQB .

    EXPONENTIATION  reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DOT             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    L_PARENTHESIS   reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    L_SQB           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    PRODUCT         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DIVISION        reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    INTEGER_DIVISION reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    MODULUS         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    SUM             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    SUBTRACTION     reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    L_SHIFT         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    R_SHIFT         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BITWISE_AND     reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BITWISE_XOR     reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BITWISE_OR      reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    EQUALITY        reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    INEQUALITY      reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    GREATER_EQUAL   reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    LESSER_EQUAL    reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    GREATER         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    LESSER          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    NOT             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IS              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IN              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    AND             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    OR              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IF              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    COLON           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    COMMA           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    NEWLINE         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    SEMICOLON       reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    ENDMARKER       reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DEF             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    CLASS           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    FOR             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    WHILE           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    PASS            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BREAK           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    CONTINUE        reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IDENTIFIER      reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    RETURN          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DEL             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    GLOBAL          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    ELIF            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    ELSE            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DEDENT          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    R_SQB           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    R_PARENTHESIS   reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)


state 181

    (105) slices -> COMMA L_PARENTHESIS . slice R_PARENTHESIS slices
    (106) slice -> . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    slice                          shift and go to state 193
    expression                     shift and go to state 159
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 182

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 194
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 183

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS . COLON block

    COLON           shift and go to state 195


state 184

    (52) for_stmt -> FOR targets IN expressions COLON . else_block
    (53) for_stmt -> FOR targets IN expressions COLON . block
    (49) else_block -> . ELSE COLON block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    ELSE            shift and go to state 174
    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    else_block                     shift and go to state 196
    block                          shift and go to state 197
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 185

    (50) while_stmt -> WHILE expression COLON block else_block .

    ENDMARKER       reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    DEF             reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    IF              reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    CLASS           reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    FOR             reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    WHILE           reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    PASS            reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    BREAK           reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    CONTINUE        reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    IDENTIFIER      reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    RETURN          reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    DEL             reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    GLOBAL          reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)
    DEDENT          reduce using rule 50 (while_stmt -> WHILE expression COLON block else_block .)


state 186

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 198
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 187

    (41) parameters -> parameters COMMA IDENTIFIER .

    R_PARENTHESIS   reduce using rule 41 (parameters -> parameters COMMA IDENTIFIER .)
    COMMA           reduce using rule 41 (parameters -> parameters COMMA IDENTIFIER .)


state 188

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEF             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IF              reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FOR             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PASS            reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEL             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)


state 189

    (46) elif_stmt -> ELIF expression . COLON block elif_stmt
    (47) elif_stmt -> ELIF expression . COLON block else_block
    (48) elif_stmt -> ELIF expression . COLON block

    COLON           shift and go to state 199


state 190

    (49) else_block -> ELSE COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 200
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 191

    (34) block -> NEWLINE INDENT statements . DEDENT
    (2) statements -> statements . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF expression COLON block elif_stmt
    (44) if_stmt -> . IF expression COLON block else_block
    (45) if_stmt -> . IF expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (52) for_stmt -> . FOR targets IN expressions COLON else_block
    (53) for_stmt -> . FOR targets IN expressions COLON block
    (50) while_stmt -> . WHILE expression COLON block else_block
    (51) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    DEDENT          shift and go to state 201
    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    statement                      shift and go to state 29
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 192

    (57) expression -> disjunction IF disjunction ELSE expression .

    COLON           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    COMMA           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    NEWLINE         reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    SEMICOLON       reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    ENDMARKER       reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    DEF             reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    IF              reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    CLASS           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    FOR             reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    WHILE           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    PASS            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    BREAK           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    CONTINUE        reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    IDENTIFIER      reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    RETURN          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    DEL             reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    GLOBAL          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    ELIF            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    ELSE            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    DEDENT          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    R_SQB           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    R_PARENTHESIS   reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)


state 193

    (105) slices -> COMMA L_PARENTHESIS slice . R_PARENTHESIS slices

    R_PARENTHESIS   shift and go to state 202


state 194

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEF             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IF              reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FOR             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PASS            reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEL             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)


state 195

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 203
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 196

    (52) for_stmt -> FOR targets IN expressions COLON else_block .

    ENDMARKER       reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    DEF             reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    IF              reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    CLASS           reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    FOR             reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    WHILE           reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    PASS            reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    BREAK           reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    CONTINUE        reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    IDENTIFIER      reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    RETURN          reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    DEL             reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    GLOBAL          reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)
    DEDENT          reduce using rule 52 (for_stmt -> FOR targets IN expressions COLON else_block .)


state 197

    (53) for_stmt -> FOR targets IN expressions COLON block .

    ENDMARKER       reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    DEF             reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    IF              reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    CLASS           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    FOR             reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    WHILE           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    PASS            reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    BREAK           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    CONTINUE        reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    IDENTIFIER      reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    RETURN          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    DEL             reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    GLOBAL          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)
    DEDENT          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON block .)


state 198

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEF             reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    IF              reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    FOR             reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    PASS            reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEL             reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)


state 199

    (46) elif_stmt -> ELIF expression COLON . block elif_stmt
    (47) elif_stmt -> ELIF expression COLON . block else_block
    (48) elif_stmt -> ELIF expression COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 126
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 204
    simple_stmts                   shift and go to state 127
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 200

    (49) else_block -> ELSE COLON block .

    ENDMARKER       reduce using rule 49 (else_block -> ELSE COLON block .)
    DEF             reduce using rule 49 (else_block -> ELSE COLON block .)
    IF              reduce using rule 49 (else_block -> ELSE COLON block .)
    CLASS           reduce using rule 49 (else_block -> ELSE COLON block .)
    FOR             reduce using rule 49 (else_block -> ELSE COLON block .)
    WHILE           reduce using rule 49 (else_block -> ELSE COLON block .)
    PASS            reduce using rule 49 (else_block -> ELSE COLON block .)
    BREAK           reduce using rule 49 (else_block -> ELSE COLON block .)
    CONTINUE        reduce using rule 49 (else_block -> ELSE COLON block .)
    IDENTIFIER      reduce using rule 49 (else_block -> ELSE COLON block .)
    RETURN          reduce using rule 49 (else_block -> ELSE COLON block .)
    DEL             reduce using rule 49 (else_block -> ELSE COLON block .)
    GLOBAL          reduce using rule 49 (else_block -> ELSE COLON block .)
    DEDENT          reduce using rule 49 (else_block -> ELSE COLON block .)


state 201

    (34) block -> NEWLINE INDENT statements DEDENT .

    ELIF            reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    ELSE            reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    ENDMARKER       reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    DEF             reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    IF              reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    CLASS           reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    FOR             reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    WHILE           reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    PASS            reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    BREAK           reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    CONTINUE        reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    IDENTIFIER      reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    RETURN          reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    DEL             reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    GLOBAL          reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    DEDENT          reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)


state 202

    (105) slices -> COMMA L_PARENTHESIS slice R_PARENTHESIS . slices
    (104) slices -> . slice
    (105) slices -> . COMMA L_PARENTHESIS slice R_PARENTHESIS slices
    (106) slice -> . expression
    (56) expression -> . disjunction
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) disjunction -> . conjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) conjunction -> . inversion
    (61) conjunction -> . inversion AND inversion
    (62) inversion -> . NOT inversion
    (63) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . primary EXPONENTIATION target
    (99) power -> . primary
    (100) primary -> . primary DOT IDENTIFIER
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . atomic
    (107) atomic -> . IDENTIFIER
    (108) atomic -> . TRUE
    (109) atomic -> . FALSE
    (110) atomic -> . NONE
    (111) atomic -> . strings
    (112) atomic -> . NUMBER
    (113) atomic -> . F_NUMBER
    (115) strings -> . STRING
    (116) strings -> . TRIPLE_STRING

    COMMA           shift and go to state 158
    NOT             shift and go to state 46
    SUM             shift and go to state 53
    SUBTRACTION     shift and go to state 55
    IDENTIFIER      shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    NONE            shift and go to state 63
    NUMBER          shift and go to state 65
    F_NUMBER        shift and go to state 66
    STRING          shift and go to state 67
    TRIPLE_STRING   shift and go to state 68

    slice                          shift and go to state 157
    slices                         shift and go to state 205
    expression                     shift and go to state 159
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    bitwise_and                    shift and go to state 50
    shift_expr                     shift and go to state 51
    sum                            shift and go to state 52
    term                           shift and go to state 54
    factor                         shift and go to state 56
    power                          shift and go to state 57
    primary                        shift and go to state 58
    atomic                         shift and go to state 60
    strings                        shift and go to state 64

state 203

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEF             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    IF              reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    FOR             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    PASS            reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEL             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)


state 204

    (46) elif_stmt -> ELIF expression COLON block . elif_stmt
    (47) elif_stmt -> ELIF expression COLON block . else_block
    (48) elif_stmt -> ELIF expression COLON block .
    (46) elif_stmt -> . ELIF expression COLON block elif_stmt
    (47) elif_stmt -> . ELIF expression COLON block else_block
    (48) elif_stmt -> . ELIF expression COLON block
    (49) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    DEF             reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    IF              reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    CLASS           reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    FOR             reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    WHILE           reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    PASS            reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    BREAK           reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    CONTINUE        reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    IDENTIFIER      reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    RETURN          reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    DEL             reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    GLOBAL          reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    DEDENT          reduce using rule 48 (elif_stmt -> ELIF expression COLON block .)
    ELIF            shift and go to state 173
    ELSE            shift and go to state 174

    elif_stmt                      shift and go to state 206
    else_block                     shift and go to state 207

state 205

    (105) slices -> COMMA L_PARENTHESIS slice R_PARENTHESIS slices .

    R_SQB           reduce using rule 105 (slices -> COMMA L_PARENTHESIS slice R_PARENTHESIS slices .)


state 206

    (46) elif_stmt -> ELIF expression COLON block elif_stmt .

    ENDMARKER       reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    DEF             reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    IF              reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    CLASS           reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    FOR             reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    WHILE           reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    PASS            reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    BREAK           reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    CONTINUE        reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    IDENTIFIER      reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    RETURN          reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    DEL             reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    GLOBAL          reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    DEDENT          reduce using rule 46 (elif_stmt -> ELIF expression COLON block elif_stmt .)


state 207

    (47) elif_stmt -> ELIF expression COLON block else_block .

    ENDMARKER       reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    DEF             reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    IF              reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    CLASS           reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    FOR             reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    WHILE           reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    PASS            reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    BREAK           reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    CONTINUE        reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    IDENTIFIER      reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    RETURN          reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    DEL             reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    GLOBAL          reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)
    DEDENT          reduce using rule 47 (elif_stmt -> ELIF expression COLON block else_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for R_PARENTHESIS in state 116 resolved as shift
