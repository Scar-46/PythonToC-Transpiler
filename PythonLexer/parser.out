Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AS
    BIN_NUMBER
    HEX_NUMBER
    L_CB
    OCT_NUMBER
    R_CB
    WHITESPACE

Grammar

Rule 0     S' -> file
Rule 1     file -> statements ENDMARKER
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> compound_stmt
Rule 5     statement -> simple_stmts
Rule 6     simple_stmts -> simple_stmts SEMICOLON simple_stmt
Rule 7     simple_stmts -> simple_stmt NEWLINE
Rule 8     simple_stmt -> assignment
Rule 9     simple_stmt -> expressions
Rule 10    simple_stmt -> return_stmt
Rule 11    simple_stmt -> PASS
Rule 12    simple_stmt -> del_stmt
Rule 13    simple_stmt -> BREAK
Rule 14    simple_stmt -> CONTINUE
Rule 15    simple_stmt -> global_stmt
Rule 16    compound_stmt -> function_def
Rule 17    compound_stmt -> if_stmt
Rule 18    compound_stmt -> class_def
Rule 19    compound_stmt -> for_stmt
Rule 20    compound_stmt -> while_stmt
Rule 21    assignment -> IDENTIFIER augmentation_assignment expressions
Rule 22    augmentation_assignment -> ASSIGNMENT
Rule 23    augmentation_assignment -> SUM_ASSIGNMENT
Rule 24    augmentation_assignment -> SUBTRACTION_ASSIGNMENT
Rule 25    augmentation_assignment -> PRODUCT_ASSIGNMENT
Rule 26    augmentation_assignment -> DIVISION_ASSIGNMENT
Rule 27    augmentation_assignment -> MODULUS_ASSIGNMENT
Rule 28    augmentation_assignment -> EXPONENTIATION_ASSIGNMENT
Rule 29    augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT
Rule 30    return_stmt -> RETURN expressions
Rule 31    global_stmt -> GLOBAL namelist
Rule 32    del_stmt -> DEL namelist
Rule 33    namelist -> namelist COMMA IDENTIFIER
Rule 34    namelist -> IDENTIFIER
Rule 35    block -> NEWLINE INDENT statements DEDENT
Rule 36    block -> simple_stmts
Rule 37    class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
Rule 38    class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
Rule 39    class_def -> CLASS IDENTIFIER COLON block
Rule 40    function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
Rule 41    function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
Rule 42    parameters -> parameters COMMA IDENTIFIER
Rule 43    parameters -> IDENTIFIER
Rule 44    if_stmt -> IF expression COLON block elif_stmt
Rule 45    if_stmt -> IF expression COLON block else_block
Rule 46    if_stmt -> IF expression COLON block
Rule 47    elif_stmt -> ELIF expression COLON block elif_stmt
Rule 48    elif_stmt -> ELIF expression COLON block else_block
Rule 49    elif_stmt -> ELIF expression COLON block
Rule 50    else_block -> ELSE COLON block
Rule 51    while_stmt -> WHILE expression COLON block else_block
Rule 52    while_stmt -> WHILE expression COLON block
Rule 53    for_stmt -> FOR targets IN expressions COLON else_block
Rule 54    for_stmt -> FOR targets IN expressions COLON block
Rule 55    expressions -> expressions COMMA expression
Rule 56    expressions -> expression
Rule 57    expression -> disjunction IF disjunction ELSE expression
Rule 58    expression -> disjunction
Rule 59    disjunction -> conjunction OR disjunction
Rule 60    disjunction -> conjunction
Rule 61    conjunction -> inversion AND inversion
Rule 62    conjunction -> inversion
Rule 63    inversion -> NOT inversion
Rule 64    inversion -> comparison
Rule 65    comparison -> bitwise_or compare_op_list
Rule 66    comparison -> bitwise_or
Rule 67    compare_op_list -> compare_op_list compare_op
Rule 68    compare_op_list -> compare_op
Rule 69    compare_op -> EQUALITY bitwise_or
Rule 70    compare_op -> INEQUALITY bitwise_or
Rule 71    compare_op -> GREATER_EQUAL bitwise_or
Rule 72    compare_op -> LESSER_EQUAL bitwise_or
Rule 73    compare_op -> GREATER bitwise_or
Rule 74    compare_op -> LESSER bitwise_or
Rule 75    compare_op -> NOT IN bitwise_or
Rule 76    compare_op -> IS NOT bitwise_or
Rule 77    compare_op -> IN bitwise_or
Rule 78    compare_op -> IS bitwise_or
Rule 79    bitwise_or -> bitwise_or BITWISE_OR bitwise_xor
Rule 80    bitwise_or -> bitwise_xor
Rule 81    bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and
Rule 82    bitwise_xor -> bitwise_and
Rule 83    bitwise_and -> bitwise_and BITWISE_AND shift_expr
Rule 84    bitwise_and -> shift_expr
Rule 85    shift_expr -> shift_expr L_SHIFT sum
Rule 86    shift_expr -> shift_expr R_SHIFT sum
Rule 87    shift_expr -> sum
Rule 88    sum -> sum PLUS term
Rule 89    sum -> sum MINUS term
Rule 90    sum -> term
Rule 91    term -> term STAR factor
Rule 92    term -> term DIVISION factor
Rule 93    term -> term INTEGER_DIVISION factor
Rule 94    term -> term MODULUS factor
Rule 95    term -> factor
Rule 96    factor -> PLUS factor
Rule 97    factor -> MINUS factor
Rule 98    factor -> power
Rule 99    power -> primary EXPONENTIATION target
Rule 100   power -> primary
Rule 101   primary -> primary L_PARENTHESIS arguments R_PARENTHESIS
Rule 102   primary -> primary L_SQB slices R_SQB
Rule 103   primary -> primary DOT IDENTIFIER
Rule 104   primary -> atomic
Rule 105   slices -> slices COMMA L_PARENTHESIS slice R_PARENTHESIS
Rule 106   slices -> slice
Rule 107   slice -> expression
Rule 108   atomic -> IDENTIFIER
Rule 109   atomic -> TRUE
Rule 110   atomic -> FALSE
Rule 111   atomic -> NONE
Rule 112   atomic -> strings
Rule 113   atomic -> NUMBER
Rule 114   atomic -> F_NUMBER
Rule 115   arguments -> empty
Rule 116   strings -> STRING
Rule 117   strings -> TRIPLE_STRING
Rule 118   targets -> targets COMMA target
Rule 119   targets -> target
Rule 120   target -> empty
Rule 121   empty -> <empty>

Terminals, with rules where they appear

AND                  : 61
AS                   : 
ASSIGNMENT           : 22
BIN_NUMBER           : 
BITWISE_AND          : 83
BITWISE_OR           : 79
BITWISE_XOR          : 81
BREAK                : 13
CLASS                : 37 38 39
COLON                : 37 38 39 40 41 44 45 46 47 48 49 50 51 52 53 54
COMMA                : 33 42 55 105 118
CONTINUE             : 14
DEDENT               : 35
DEF                  : 40 41
DEL                  : 32
DIVISION             : 92
DIVISION_ASSIGNMENT  : 26
DOT                  : 103
ELIF                 : 47 48 49
ELSE                 : 50 57
ENDMARKER            : 1
EQUALITY             : 69
EXPONENTIATION       : 99
EXPONENTIATION_ASSIGNMENT : 28
FALSE                : 110
FOR                  : 53 54
F_NUMBER             : 114
GLOBAL               : 31
GREATER              : 73
GREATER_EQUAL        : 71
HEX_NUMBER           : 
IDENTIFIER           : 21 33 34 37 38 39 40 41 42 43 103 108
IF                   : 44 45 46 57
IN                   : 53 54 75 77
INDENT               : 35
INEQUALITY           : 70
INTEGER_DIVISION     : 93
INTEGER_DIVISION_ASSIGNMENT : 29
IS                   : 76 78
LESSER               : 74
LESSER_EQUAL         : 72
L_CB                 : 
L_PARENTHESIS        : 37 38 40 41 101 105
L_SHIFT              : 85
L_SQB                : 102
MINUS                : 89 97
MODULUS              : 94
MODULUS_ASSIGNMENT   : 27
NEWLINE              : 7 35
NONE                 : 111
NOT                  : 63 75 76
NUMBER               : 113
OCT_NUMBER           : 
OR                   : 59
PASS                 : 11
PLUS                 : 88 96
PRODUCT_ASSIGNMENT   : 25
RETURN               : 30
R_CB                 : 
R_PARENTHESIS        : 37 38 40 41 101 105
R_SHIFT              : 86
R_SQB                : 102
SEMICOLON            : 6
STAR                 : 91
STRING               : 116
SUBTRACTION_ASSIGNMENT : 24
SUM_ASSIGNMENT       : 23
TRIPLE_STRING        : 117
TRUE                 : 109
WHILE                : 51 52
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

arguments            : 37 101
assignment           : 8
atomic               : 104
augmentation_assignment : 21
bitwise_and          : 81 82 83
bitwise_or           : 65 66 69 70 71 72 73 74 75 76 77 78 79
bitwise_xor          : 79 80 81
block                : 37 38 39 40 41 44 45 46 47 48 49 50 51 52 54
class_def            : 18
compare_op           : 67 68
compare_op_list      : 65 67
comparison           : 64
compound_stmt        : 4
conjunction          : 59 60
del_stmt             : 12
disjunction          : 57 57 58 59
elif_stmt            : 44 47
else_block           : 45 48 51 53
empty                : 115 120
expression           : 44 45 46 47 48 49 51 52 55 56 57 107
expressions          : 9 21 30 53 54 55
factor               : 91 92 93 94 95 96 97
file                 : 0
for_stmt             : 19
function_def         : 16
global_stmt          : 15
if_stmt              : 17
inversion            : 61 61 62 63
namelist             : 31 32 33
parameters           : 40 42
power                : 98
primary              : 99 100 101 102 103
return_stmt          : 10
shift_expr           : 83 84 85 86
simple_stmt          : 6 7
simple_stmts         : 5 6 36
slice                : 105 106
slices               : 102 105
statement            : 2 3
statements           : 1 2 35
strings              : 112
sum                  : 85 86 87 88 89
target               : 99 118 119
targets              : 53 54 118
term                 : 88 89 90 91 92 93 94
while_stmt           : 20

Parsing method: LALR

state 0

    (0) S' -> . file
    (1) file -> . statements ENDMARKER
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (16) compound_stmt -> . function_def
    (17) compound_stmt -> . if_stmt
    (18) compound_stmt -> . class_def
    (19) compound_stmt -> . for_stmt
    (20) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (41) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (44) if_stmt -> . IF expression COLON block elif_stmt
    (45) if_stmt -> . IF expression COLON block else_block
    (46) if_stmt -> . IF expression COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (39) class_def -> . CLASS IDENTIFIER COLON block
    (53) for_stmt -> . FOR targets IN expressions COLON else_block
    (54) for_stmt -> . FOR targets IN expressions COLON block
    (51) while_stmt -> . WHILE expression COLON block else_block
    (52) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 16
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    file                           shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    expression                     shift and go to state 15
    expressions                    shift and go to state 18
    assignment                     shift and go to state 20
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 1

    (0) S' -> file .



state 2

    (1) file -> statements . ENDMARKER
    (2) statements -> statements . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (16) compound_stmt -> . function_def
    (17) compound_stmt -> . if_stmt
    (18) compound_stmt -> . class_def
    (19) compound_stmt -> . for_stmt
    (20) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (41) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (44) if_stmt -> . IF expression COLON block elif_stmt
    (45) if_stmt -> . IF expression COLON block else_block
    (46) if_stmt -> . IF expression COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (39) class_def -> . CLASS IDENTIFIER COLON block
    (53) for_stmt -> . FOR targets IN expressions COLON else_block
    (54) for_stmt -> . FOR targets IN expressions COLON block
    (51) while_stmt -> . WHILE expression COLON block else_block
    (52) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    ENDMARKER       shift and go to state 55
    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 16
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    statement                      shift and go to state 56
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    expression                     shift and go to state 15
    expressions                    shift and go to state 18
    assignment                     shift and go to state 20
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 3

    (3) statements -> statement .

    ENDMARKER       reduce using rule 3 (statements -> statement .)
    DEF             reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    CLASS           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)
    PASS            reduce using rule 3 (statements -> statement .)
    BREAK           reduce using rule 3 (statements -> statement .)
    CONTINUE        reduce using rule 3 (statements -> statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    DEL             reduce using rule 3 (statements -> statement .)
    GLOBAL          reduce using rule 3 (statements -> statement .)
    NOT             reduce using rule 3 (statements -> statement .)
    PLUS            reduce using rule 3 (statements -> statement .)
    MINUS           reduce using rule 3 (statements -> statement .)
    TRUE            reduce using rule 3 (statements -> statement .)
    FALSE           reduce using rule 3 (statements -> statement .)
    NONE            reduce using rule 3 (statements -> statement .)
    NUMBER          reduce using rule 3 (statements -> statement .)
    F_NUMBER        reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    TRIPLE_STRING   reduce using rule 3 (statements -> statement .)
    DEDENT          reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> compound_stmt .

    ENDMARKER       reduce using rule 4 (statement -> compound_stmt .)
    DEF             reduce using rule 4 (statement -> compound_stmt .)
    IF              reduce using rule 4 (statement -> compound_stmt .)
    CLASS           reduce using rule 4 (statement -> compound_stmt .)
    FOR             reduce using rule 4 (statement -> compound_stmt .)
    WHILE           reduce using rule 4 (statement -> compound_stmt .)
    PASS            reduce using rule 4 (statement -> compound_stmt .)
    BREAK           reduce using rule 4 (statement -> compound_stmt .)
    CONTINUE        reduce using rule 4 (statement -> compound_stmt .)
    IDENTIFIER      reduce using rule 4 (statement -> compound_stmt .)
    RETURN          reduce using rule 4 (statement -> compound_stmt .)
    DEL             reduce using rule 4 (statement -> compound_stmt .)
    GLOBAL          reduce using rule 4 (statement -> compound_stmt .)
    NOT             reduce using rule 4 (statement -> compound_stmt .)
    PLUS            reduce using rule 4 (statement -> compound_stmt .)
    MINUS           reduce using rule 4 (statement -> compound_stmt .)
    TRUE            reduce using rule 4 (statement -> compound_stmt .)
    FALSE           reduce using rule 4 (statement -> compound_stmt .)
    NONE            reduce using rule 4 (statement -> compound_stmt .)
    NUMBER          reduce using rule 4 (statement -> compound_stmt .)
    F_NUMBER        reduce using rule 4 (statement -> compound_stmt .)
    STRING          reduce using rule 4 (statement -> compound_stmt .)
    TRIPLE_STRING   reduce using rule 4 (statement -> compound_stmt .)
    DEDENT          reduce using rule 4 (statement -> compound_stmt .)


state 5

    (5) statement -> simple_stmts .
    (6) simple_stmts -> simple_stmts . SEMICOLON simple_stmt

    ENDMARKER       reduce using rule 5 (statement -> simple_stmts .)
    DEF             reduce using rule 5 (statement -> simple_stmts .)
    IF              reduce using rule 5 (statement -> simple_stmts .)
    CLASS           reduce using rule 5 (statement -> simple_stmts .)
    FOR             reduce using rule 5 (statement -> simple_stmts .)
    WHILE           reduce using rule 5 (statement -> simple_stmts .)
    PASS            reduce using rule 5 (statement -> simple_stmts .)
    BREAK           reduce using rule 5 (statement -> simple_stmts .)
    CONTINUE        reduce using rule 5 (statement -> simple_stmts .)
    IDENTIFIER      reduce using rule 5 (statement -> simple_stmts .)
    RETURN          reduce using rule 5 (statement -> simple_stmts .)
    DEL             reduce using rule 5 (statement -> simple_stmts .)
    GLOBAL          reduce using rule 5 (statement -> simple_stmts .)
    NOT             reduce using rule 5 (statement -> simple_stmts .)
    PLUS            reduce using rule 5 (statement -> simple_stmts .)
    MINUS           reduce using rule 5 (statement -> simple_stmts .)
    TRUE            reduce using rule 5 (statement -> simple_stmts .)
    FALSE           reduce using rule 5 (statement -> simple_stmts .)
    NONE            reduce using rule 5 (statement -> simple_stmts .)
    NUMBER          reduce using rule 5 (statement -> simple_stmts .)
    F_NUMBER        reduce using rule 5 (statement -> simple_stmts .)
    STRING          reduce using rule 5 (statement -> simple_stmts .)
    TRIPLE_STRING   reduce using rule 5 (statement -> simple_stmts .)
    DEDENT          reduce using rule 5 (statement -> simple_stmts .)
    SEMICOLON       shift and go to state 57


state 6

    (16) compound_stmt -> function_def .

    ENDMARKER       reduce using rule 16 (compound_stmt -> function_def .)
    DEF             reduce using rule 16 (compound_stmt -> function_def .)
    IF              reduce using rule 16 (compound_stmt -> function_def .)
    CLASS           reduce using rule 16 (compound_stmt -> function_def .)
    FOR             reduce using rule 16 (compound_stmt -> function_def .)
    WHILE           reduce using rule 16 (compound_stmt -> function_def .)
    PASS            reduce using rule 16 (compound_stmt -> function_def .)
    BREAK           reduce using rule 16 (compound_stmt -> function_def .)
    CONTINUE        reduce using rule 16 (compound_stmt -> function_def .)
    IDENTIFIER      reduce using rule 16 (compound_stmt -> function_def .)
    RETURN          reduce using rule 16 (compound_stmt -> function_def .)
    DEL             reduce using rule 16 (compound_stmt -> function_def .)
    GLOBAL          reduce using rule 16 (compound_stmt -> function_def .)
    NOT             reduce using rule 16 (compound_stmt -> function_def .)
    PLUS            reduce using rule 16 (compound_stmt -> function_def .)
    MINUS           reduce using rule 16 (compound_stmt -> function_def .)
    TRUE            reduce using rule 16 (compound_stmt -> function_def .)
    FALSE           reduce using rule 16 (compound_stmt -> function_def .)
    NONE            reduce using rule 16 (compound_stmt -> function_def .)
    NUMBER          reduce using rule 16 (compound_stmt -> function_def .)
    F_NUMBER        reduce using rule 16 (compound_stmt -> function_def .)
    STRING          reduce using rule 16 (compound_stmt -> function_def .)
    TRIPLE_STRING   reduce using rule 16 (compound_stmt -> function_def .)
    DEDENT          reduce using rule 16 (compound_stmt -> function_def .)


state 7

    (17) compound_stmt -> if_stmt .

    ENDMARKER       reduce using rule 17 (compound_stmt -> if_stmt .)
    DEF             reduce using rule 17 (compound_stmt -> if_stmt .)
    IF              reduce using rule 17 (compound_stmt -> if_stmt .)
    CLASS           reduce using rule 17 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 17 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 17 (compound_stmt -> if_stmt .)
    PASS            reduce using rule 17 (compound_stmt -> if_stmt .)
    BREAK           reduce using rule 17 (compound_stmt -> if_stmt .)
    CONTINUE        reduce using rule 17 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 17 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 17 (compound_stmt -> if_stmt .)
    DEL             reduce using rule 17 (compound_stmt -> if_stmt .)
    GLOBAL          reduce using rule 17 (compound_stmt -> if_stmt .)
    NOT             reduce using rule 17 (compound_stmt -> if_stmt .)
    PLUS            reduce using rule 17 (compound_stmt -> if_stmt .)
    MINUS           reduce using rule 17 (compound_stmt -> if_stmt .)
    TRUE            reduce using rule 17 (compound_stmt -> if_stmt .)
    FALSE           reduce using rule 17 (compound_stmt -> if_stmt .)
    NONE            reduce using rule 17 (compound_stmt -> if_stmt .)
    NUMBER          reduce using rule 17 (compound_stmt -> if_stmt .)
    F_NUMBER        reduce using rule 17 (compound_stmt -> if_stmt .)
    STRING          reduce using rule 17 (compound_stmt -> if_stmt .)
    TRIPLE_STRING   reduce using rule 17 (compound_stmt -> if_stmt .)
    DEDENT          reduce using rule 17 (compound_stmt -> if_stmt .)


state 8

    (18) compound_stmt -> class_def .

    ENDMARKER       reduce using rule 18 (compound_stmt -> class_def .)
    DEF             reduce using rule 18 (compound_stmt -> class_def .)
    IF              reduce using rule 18 (compound_stmt -> class_def .)
    CLASS           reduce using rule 18 (compound_stmt -> class_def .)
    FOR             reduce using rule 18 (compound_stmt -> class_def .)
    WHILE           reduce using rule 18 (compound_stmt -> class_def .)
    PASS            reduce using rule 18 (compound_stmt -> class_def .)
    BREAK           reduce using rule 18 (compound_stmt -> class_def .)
    CONTINUE        reduce using rule 18 (compound_stmt -> class_def .)
    IDENTIFIER      reduce using rule 18 (compound_stmt -> class_def .)
    RETURN          reduce using rule 18 (compound_stmt -> class_def .)
    DEL             reduce using rule 18 (compound_stmt -> class_def .)
    GLOBAL          reduce using rule 18 (compound_stmt -> class_def .)
    NOT             reduce using rule 18 (compound_stmt -> class_def .)
    PLUS            reduce using rule 18 (compound_stmt -> class_def .)
    MINUS           reduce using rule 18 (compound_stmt -> class_def .)
    TRUE            reduce using rule 18 (compound_stmt -> class_def .)
    FALSE           reduce using rule 18 (compound_stmt -> class_def .)
    NONE            reduce using rule 18 (compound_stmt -> class_def .)
    NUMBER          reduce using rule 18 (compound_stmt -> class_def .)
    F_NUMBER        reduce using rule 18 (compound_stmt -> class_def .)
    STRING          reduce using rule 18 (compound_stmt -> class_def .)
    TRIPLE_STRING   reduce using rule 18 (compound_stmt -> class_def .)
    DEDENT          reduce using rule 18 (compound_stmt -> class_def .)


state 9

    (19) compound_stmt -> for_stmt .

    ENDMARKER       reduce using rule 19 (compound_stmt -> for_stmt .)
    DEF             reduce using rule 19 (compound_stmt -> for_stmt .)
    IF              reduce using rule 19 (compound_stmt -> for_stmt .)
    CLASS           reduce using rule 19 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 19 (compound_stmt -> for_stmt .)
    WHILE           reduce using rule 19 (compound_stmt -> for_stmt .)
    PASS            reduce using rule 19 (compound_stmt -> for_stmt .)
    BREAK           reduce using rule 19 (compound_stmt -> for_stmt .)
    CONTINUE        reduce using rule 19 (compound_stmt -> for_stmt .)
    IDENTIFIER      reduce using rule 19 (compound_stmt -> for_stmt .)
    RETURN          reduce using rule 19 (compound_stmt -> for_stmt .)
    DEL             reduce using rule 19 (compound_stmt -> for_stmt .)
    GLOBAL          reduce using rule 19 (compound_stmt -> for_stmt .)
    NOT             reduce using rule 19 (compound_stmt -> for_stmt .)
    PLUS            reduce using rule 19 (compound_stmt -> for_stmt .)
    MINUS           reduce using rule 19 (compound_stmt -> for_stmt .)
    TRUE            reduce using rule 19 (compound_stmt -> for_stmt .)
    FALSE           reduce using rule 19 (compound_stmt -> for_stmt .)
    NONE            reduce using rule 19 (compound_stmt -> for_stmt .)
    NUMBER          reduce using rule 19 (compound_stmt -> for_stmt .)
    F_NUMBER        reduce using rule 19 (compound_stmt -> for_stmt .)
    STRING          reduce using rule 19 (compound_stmt -> for_stmt .)
    TRIPLE_STRING   reduce using rule 19 (compound_stmt -> for_stmt .)
    DEDENT          reduce using rule 19 (compound_stmt -> for_stmt .)


state 10

    (20) compound_stmt -> while_stmt .

    ENDMARKER       reduce using rule 20 (compound_stmt -> while_stmt .)
    DEF             reduce using rule 20 (compound_stmt -> while_stmt .)
    IF              reduce using rule 20 (compound_stmt -> while_stmt .)
    CLASS           reduce using rule 20 (compound_stmt -> while_stmt .)
    FOR             reduce using rule 20 (compound_stmt -> while_stmt .)
    WHILE           reduce using rule 20 (compound_stmt -> while_stmt .)
    PASS            reduce using rule 20 (compound_stmt -> while_stmt .)
    BREAK           reduce using rule 20 (compound_stmt -> while_stmt .)
    CONTINUE        reduce using rule 20 (compound_stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 20 (compound_stmt -> while_stmt .)
    RETURN          reduce using rule 20 (compound_stmt -> while_stmt .)
    DEL             reduce using rule 20 (compound_stmt -> while_stmt .)
    GLOBAL          reduce using rule 20 (compound_stmt -> while_stmt .)
    NOT             reduce using rule 20 (compound_stmt -> while_stmt .)
    PLUS            reduce using rule 20 (compound_stmt -> while_stmt .)
    MINUS           reduce using rule 20 (compound_stmt -> while_stmt .)
    TRUE            reduce using rule 20 (compound_stmt -> while_stmt .)
    FALSE           reduce using rule 20 (compound_stmt -> while_stmt .)
    NONE            reduce using rule 20 (compound_stmt -> while_stmt .)
    NUMBER          reduce using rule 20 (compound_stmt -> while_stmt .)
    F_NUMBER        reduce using rule 20 (compound_stmt -> while_stmt .)
    STRING          reduce using rule 20 (compound_stmt -> while_stmt .)
    TRIPLE_STRING   reduce using rule 20 (compound_stmt -> while_stmt .)
    DEDENT          reduce using rule 20 (compound_stmt -> while_stmt .)


state 11

    (7) simple_stmts -> simple_stmt . NEWLINE

    NEWLINE         shift and go to state 58


state 12

    (40) function_def -> DEF . IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (41) function_def -> DEF . IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block

    IDENTIFIER      shift and go to state 59


state 13

    (21) assignment -> IDENTIFIER . augmentation_assignment expressions
    (108) atomic -> IDENTIFIER .
    (22) augmentation_assignment -> . ASSIGNMENT
    (23) augmentation_assignment -> . SUM_ASSIGNMENT
    (24) augmentation_assignment -> . SUBTRACTION_ASSIGNMENT
    (25) augmentation_assignment -> . PRODUCT_ASSIGNMENT
    (26) augmentation_assignment -> . DIVISION_ASSIGNMENT
    (27) augmentation_assignment -> . MODULUS_ASSIGNMENT
    (28) augmentation_assignment -> . EXPONENTIATION_ASSIGNMENT
    (29) augmentation_assignment -> . INTEGER_DIVISION_ASSIGNMENT

    EXPONENTIATION  reduce using rule 108 (atomic -> IDENTIFIER .)
    L_PARENTHESIS   reduce using rule 108 (atomic -> IDENTIFIER .)
    L_SQB           reduce using rule 108 (atomic -> IDENTIFIER .)
    DOT             reduce using rule 108 (atomic -> IDENTIFIER .)
    STAR            reduce using rule 108 (atomic -> IDENTIFIER .)
    DIVISION        reduce using rule 108 (atomic -> IDENTIFIER .)
    INTEGER_DIVISION reduce using rule 108 (atomic -> IDENTIFIER .)
    MODULUS         reduce using rule 108 (atomic -> IDENTIFIER .)
    PLUS            reduce using rule 108 (atomic -> IDENTIFIER .)
    MINUS           reduce using rule 108 (atomic -> IDENTIFIER .)
    L_SHIFT         reduce using rule 108 (atomic -> IDENTIFIER .)
    R_SHIFT         reduce using rule 108 (atomic -> IDENTIFIER .)
    BITWISE_AND     reduce using rule 108 (atomic -> IDENTIFIER .)
    BITWISE_XOR     reduce using rule 108 (atomic -> IDENTIFIER .)
    BITWISE_OR      reduce using rule 108 (atomic -> IDENTIFIER .)
    EQUALITY        reduce using rule 108 (atomic -> IDENTIFIER .)
    INEQUALITY      reduce using rule 108 (atomic -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 108 (atomic -> IDENTIFIER .)
    LESSER_EQUAL    reduce using rule 108 (atomic -> IDENTIFIER .)
    GREATER         reduce using rule 108 (atomic -> IDENTIFIER .)
    LESSER          reduce using rule 108 (atomic -> IDENTIFIER .)
    NOT             reduce using rule 108 (atomic -> IDENTIFIER .)
    IS              reduce using rule 108 (atomic -> IDENTIFIER .)
    IN              reduce using rule 108 (atomic -> IDENTIFIER .)
    AND             reduce using rule 108 (atomic -> IDENTIFIER .)
    OR              reduce using rule 108 (atomic -> IDENTIFIER .)
    IF              reduce using rule 108 (atomic -> IDENTIFIER .)
    COMMA           reduce using rule 108 (atomic -> IDENTIFIER .)
    NEWLINE         reduce using rule 108 (atomic -> IDENTIFIER .)
    SEMICOLON       reduce using rule 108 (atomic -> IDENTIFIER .)
    ENDMARKER       reduce using rule 108 (atomic -> IDENTIFIER .)
    DEF             reduce using rule 108 (atomic -> IDENTIFIER .)
    CLASS           reduce using rule 108 (atomic -> IDENTIFIER .)
    FOR             reduce using rule 108 (atomic -> IDENTIFIER .)
    WHILE           reduce using rule 108 (atomic -> IDENTIFIER .)
    PASS            reduce using rule 108 (atomic -> IDENTIFIER .)
    BREAK           reduce using rule 108 (atomic -> IDENTIFIER .)
    CONTINUE        reduce using rule 108 (atomic -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 108 (atomic -> IDENTIFIER .)
    RETURN          reduce using rule 108 (atomic -> IDENTIFIER .)
    DEL             reduce using rule 108 (atomic -> IDENTIFIER .)
    GLOBAL          reduce using rule 108 (atomic -> IDENTIFIER .)
    TRUE            reduce using rule 108 (atomic -> IDENTIFIER .)
    FALSE           reduce using rule 108 (atomic -> IDENTIFIER .)
    NONE            reduce using rule 108 (atomic -> IDENTIFIER .)
    NUMBER          reduce using rule 108 (atomic -> IDENTIFIER .)
    F_NUMBER        reduce using rule 108 (atomic -> IDENTIFIER .)
    STRING          reduce using rule 108 (atomic -> IDENTIFIER .)
    TRIPLE_STRING   reduce using rule 108 (atomic -> IDENTIFIER .)
    ELIF            reduce using rule 108 (atomic -> IDENTIFIER .)
    ELSE            reduce using rule 108 (atomic -> IDENTIFIER .)
    DEDENT          reduce using rule 108 (atomic -> IDENTIFIER .)
    ASSIGNMENT      shift and go to state 61
    SUM_ASSIGNMENT  shift and go to state 62
    SUBTRACTION_ASSIGNMENT shift and go to state 63
    PRODUCT_ASSIGNMENT shift and go to state 64
    DIVISION_ASSIGNMENT shift and go to state 65
    MODULUS_ASSIGNMENT shift and go to state 66
    EXPONENTIATION_ASSIGNMENT shift and go to state 67
    INTEGER_DIVISION_ASSIGNMENT shift and go to state 68

    augmentation_assignment        shift and go to state 60

state 14

    (44) if_stmt -> IF . expression COLON block elif_stmt
    (45) if_stmt -> IF . expression COLON block else_block
    (46) if_stmt -> IF . expression COLON block
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expression                     shift and go to state 69
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 15

    (56) expressions -> expression .

    COMMA           reduce using rule 56 (expressions -> expression .)
    NEWLINE         reduce using rule 56 (expressions -> expression .)
    SEMICOLON       reduce using rule 56 (expressions -> expression .)
    ENDMARKER       reduce using rule 56 (expressions -> expression .)
    DEF             reduce using rule 56 (expressions -> expression .)
    IF              reduce using rule 56 (expressions -> expression .)
    CLASS           reduce using rule 56 (expressions -> expression .)
    FOR             reduce using rule 56 (expressions -> expression .)
    WHILE           reduce using rule 56 (expressions -> expression .)
    PASS            reduce using rule 56 (expressions -> expression .)
    BREAK           reduce using rule 56 (expressions -> expression .)
    CONTINUE        reduce using rule 56 (expressions -> expression .)
    IDENTIFIER      reduce using rule 56 (expressions -> expression .)
    RETURN          reduce using rule 56 (expressions -> expression .)
    DEL             reduce using rule 56 (expressions -> expression .)
    GLOBAL          reduce using rule 56 (expressions -> expression .)
    NOT             reduce using rule 56 (expressions -> expression .)
    PLUS            reduce using rule 56 (expressions -> expression .)
    MINUS           reduce using rule 56 (expressions -> expression .)
    TRUE            reduce using rule 56 (expressions -> expression .)
    FALSE           reduce using rule 56 (expressions -> expression .)
    NONE            reduce using rule 56 (expressions -> expression .)
    NUMBER          reduce using rule 56 (expressions -> expression .)
    F_NUMBER        reduce using rule 56 (expressions -> expression .)
    STRING          reduce using rule 56 (expressions -> expression .)
    TRIPLE_STRING   reduce using rule 56 (expressions -> expression .)
    ELIF            reduce using rule 56 (expressions -> expression .)
    ELSE            reduce using rule 56 (expressions -> expression .)
    DEDENT          reduce using rule 56 (expressions -> expression .)
    COLON           reduce using rule 56 (expressions -> expression .)


state 16

    (37) class_def -> CLASS . IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (38) class_def -> CLASS . IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (39) class_def -> CLASS . IDENTIFIER COLON block

    IDENTIFIER      shift and go to state 71


state 17

    (53) for_stmt -> FOR . targets IN expressions COLON else_block
    (54) for_stmt -> FOR . targets IN expressions COLON block
    (118) targets -> . targets COMMA target
    (119) targets -> . target
    (120) target -> . empty
    (121) empty -> .

    IN              reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)

    targets                        shift and go to state 72
    target                         shift and go to state 73
    empty                          shift and go to state 74

state 18

    (9) simple_stmt -> expressions .
    (55) expressions -> expressions . COMMA expression

    NEWLINE         reduce using rule 9 (simple_stmt -> expressions .)
    SEMICOLON       reduce using rule 9 (simple_stmt -> expressions .)
    ENDMARKER       reduce using rule 9 (simple_stmt -> expressions .)
    DEF             reduce using rule 9 (simple_stmt -> expressions .)
    IF              reduce using rule 9 (simple_stmt -> expressions .)
    CLASS           reduce using rule 9 (simple_stmt -> expressions .)
    FOR             reduce using rule 9 (simple_stmt -> expressions .)
    WHILE           reduce using rule 9 (simple_stmt -> expressions .)
    PASS            reduce using rule 9 (simple_stmt -> expressions .)
    BREAK           reduce using rule 9 (simple_stmt -> expressions .)
    CONTINUE        reduce using rule 9 (simple_stmt -> expressions .)
    IDENTIFIER      reduce using rule 9 (simple_stmt -> expressions .)
    RETURN          reduce using rule 9 (simple_stmt -> expressions .)
    DEL             reduce using rule 9 (simple_stmt -> expressions .)
    GLOBAL          reduce using rule 9 (simple_stmt -> expressions .)
    NOT             reduce using rule 9 (simple_stmt -> expressions .)
    PLUS            reduce using rule 9 (simple_stmt -> expressions .)
    MINUS           reduce using rule 9 (simple_stmt -> expressions .)
    TRUE            reduce using rule 9 (simple_stmt -> expressions .)
    FALSE           reduce using rule 9 (simple_stmt -> expressions .)
    NONE            reduce using rule 9 (simple_stmt -> expressions .)
    NUMBER          reduce using rule 9 (simple_stmt -> expressions .)
    F_NUMBER        reduce using rule 9 (simple_stmt -> expressions .)
    STRING          reduce using rule 9 (simple_stmt -> expressions .)
    TRIPLE_STRING   reduce using rule 9 (simple_stmt -> expressions .)
    ELIF            reduce using rule 9 (simple_stmt -> expressions .)
    ELSE            reduce using rule 9 (simple_stmt -> expressions .)
    DEDENT          reduce using rule 9 (simple_stmt -> expressions .)
    COMMA           shift and go to state 75


state 19

    (51) while_stmt -> WHILE . expression COLON block else_block
    (52) while_stmt -> WHILE . expression COLON block
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expression                     shift and go to state 76
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 20

    (8) simple_stmt -> assignment .

    NEWLINE         reduce using rule 8 (simple_stmt -> assignment .)
    SEMICOLON       reduce using rule 8 (simple_stmt -> assignment .)
    ENDMARKER       reduce using rule 8 (simple_stmt -> assignment .)
    DEF             reduce using rule 8 (simple_stmt -> assignment .)
    IF              reduce using rule 8 (simple_stmt -> assignment .)
    CLASS           reduce using rule 8 (simple_stmt -> assignment .)
    FOR             reduce using rule 8 (simple_stmt -> assignment .)
    WHILE           reduce using rule 8 (simple_stmt -> assignment .)
    PASS            reduce using rule 8 (simple_stmt -> assignment .)
    BREAK           reduce using rule 8 (simple_stmt -> assignment .)
    CONTINUE        reduce using rule 8 (simple_stmt -> assignment .)
    IDENTIFIER      reduce using rule 8 (simple_stmt -> assignment .)
    RETURN          reduce using rule 8 (simple_stmt -> assignment .)
    DEL             reduce using rule 8 (simple_stmt -> assignment .)
    GLOBAL          reduce using rule 8 (simple_stmt -> assignment .)
    NOT             reduce using rule 8 (simple_stmt -> assignment .)
    PLUS            reduce using rule 8 (simple_stmt -> assignment .)
    MINUS           reduce using rule 8 (simple_stmt -> assignment .)
    TRUE            reduce using rule 8 (simple_stmt -> assignment .)
    FALSE           reduce using rule 8 (simple_stmt -> assignment .)
    NONE            reduce using rule 8 (simple_stmt -> assignment .)
    NUMBER          reduce using rule 8 (simple_stmt -> assignment .)
    F_NUMBER        reduce using rule 8 (simple_stmt -> assignment .)
    STRING          reduce using rule 8 (simple_stmt -> assignment .)
    TRIPLE_STRING   reduce using rule 8 (simple_stmt -> assignment .)
    ELIF            reduce using rule 8 (simple_stmt -> assignment .)
    ELSE            reduce using rule 8 (simple_stmt -> assignment .)
    DEDENT          reduce using rule 8 (simple_stmt -> assignment .)


state 21

    (10) simple_stmt -> return_stmt .

    NEWLINE         reduce using rule 10 (simple_stmt -> return_stmt .)
    SEMICOLON       reduce using rule 10 (simple_stmt -> return_stmt .)
    ENDMARKER       reduce using rule 10 (simple_stmt -> return_stmt .)
    DEF             reduce using rule 10 (simple_stmt -> return_stmt .)
    IF              reduce using rule 10 (simple_stmt -> return_stmt .)
    CLASS           reduce using rule 10 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 10 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 10 (simple_stmt -> return_stmt .)
    PASS            reduce using rule 10 (simple_stmt -> return_stmt .)
    BREAK           reduce using rule 10 (simple_stmt -> return_stmt .)
    CONTINUE        reduce using rule 10 (simple_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 10 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 10 (simple_stmt -> return_stmt .)
    DEL             reduce using rule 10 (simple_stmt -> return_stmt .)
    GLOBAL          reduce using rule 10 (simple_stmt -> return_stmt .)
    NOT             reduce using rule 10 (simple_stmt -> return_stmt .)
    PLUS            reduce using rule 10 (simple_stmt -> return_stmt .)
    MINUS           reduce using rule 10 (simple_stmt -> return_stmt .)
    TRUE            reduce using rule 10 (simple_stmt -> return_stmt .)
    FALSE           reduce using rule 10 (simple_stmt -> return_stmt .)
    NONE            reduce using rule 10 (simple_stmt -> return_stmt .)
    NUMBER          reduce using rule 10 (simple_stmt -> return_stmt .)
    F_NUMBER        reduce using rule 10 (simple_stmt -> return_stmt .)
    STRING          reduce using rule 10 (simple_stmt -> return_stmt .)
    TRIPLE_STRING   reduce using rule 10 (simple_stmt -> return_stmt .)
    ELIF            reduce using rule 10 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 10 (simple_stmt -> return_stmt .)
    DEDENT          reduce using rule 10 (simple_stmt -> return_stmt .)


state 22

    (11) simple_stmt -> PASS .

    NEWLINE         reduce using rule 11 (simple_stmt -> PASS .)
    SEMICOLON       reduce using rule 11 (simple_stmt -> PASS .)
    ENDMARKER       reduce using rule 11 (simple_stmt -> PASS .)
    DEF             reduce using rule 11 (simple_stmt -> PASS .)
    IF              reduce using rule 11 (simple_stmt -> PASS .)
    CLASS           reduce using rule 11 (simple_stmt -> PASS .)
    FOR             reduce using rule 11 (simple_stmt -> PASS .)
    WHILE           reduce using rule 11 (simple_stmt -> PASS .)
    PASS            reduce using rule 11 (simple_stmt -> PASS .)
    BREAK           reduce using rule 11 (simple_stmt -> PASS .)
    CONTINUE        reduce using rule 11 (simple_stmt -> PASS .)
    IDENTIFIER      reduce using rule 11 (simple_stmt -> PASS .)
    RETURN          reduce using rule 11 (simple_stmt -> PASS .)
    DEL             reduce using rule 11 (simple_stmt -> PASS .)
    GLOBAL          reduce using rule 11 (simple_stmt -> PASS .)
    NOT             reduce using rule 11 (simple_stmt -> PASS .)
    PLUS            reduce using rule 11 (simple_stmt -> PASS .)
    MINUS           reduce using rule 11 (simple_stmt -> PASS .)
    TRUE            reduce using rule 11 (simple_stmt -> PASS .)
    FALSE           reduce using rule 11 (simple_stmt -> PASS .)
    NONE            reduce using rule 11 (simple_stmt -> PASS .)
    NUMBER          reduce using rule 11 (simple_stmt -> PASS .)
    F_NUMBER        reduce using rule 11 (simple_stmt -> PASS .)
    STRING          reduce using rule 11 (simple_stmt -> PASS .)
    TRIPLE_STRING   reduce using rule 11 (simple_stmt -> PASS .)
    ELIF            reduce using rule 11 (simple_stmt -> PASS .)
    ELSE            reduce using rule 11 (simple_stmt -> PASS .)
    DEDENT          reduce using rule 11 (simple_stmt -> PASS .)


state 23

    (12) simple_stmt -> del_stmt .

    NEWLINE         reduce using rule 12 (simple_stmt -> del_stmt .)
    SEMICOLON       reduce using rule 12 (simple_stmt -> del_stmt .)
    ENDMARKER       reduce using rule 12 (simple_stmt -> del_stmt .)
    DEF             reduce using rule 12 (simple_stmt -> del_stmt .)
    IF              reduce using rule 12 (simple_stmt -> del_stmt .)
    CLASS           reduce using rule 12 (simple_stmt -> del_stmt .)
    FOR             reduce using rule 12 (simple_stmt -> del_stmt .)
    WHILE           reduce using rule 12 (simple_stmt -> del_stmt .)
    PASS            reduce using rule 12 (simple_stmt -> del_stmt .)
    BREAK           reduce using rule 12 (simple_stmt -> del_stmt .)
    CONTINUE        reduce using rule 12 (simple_stmt -> del_stmt .)
    IDENTIFIER      reduce using rule 12 (simple_stmt -> del_stmt .)
    RETURN          reduce using rule 12 (simple_stmt -> del_stmt .)
    DEL             reduce using rule 12 (simple_stmt -> del_stmt .)
    GLOBAL          reduce using rule 12 (simple_stmt -> del_stmt .)
    NOT             reduce using rule 12 (simple_stmt -> del_stmt .)
    PLUS            reduce using rule 12 (simple_stmt -> del_stmt .)
    MINUS           reduce using rule 12 (simple_stmt -> del_stmt .)
    TRUE            reduce using rule 12 (simple_stmt -> del_stmt .)
    FALSE           reduce using rule 12 (simple_stmt -> del_stmt .)
    NONE            reduce using rule 12 (simple_stmt -> del_stmt .)
    NUMBER          reduce using rule 12 (simple_stmt -> del_stmt .)
    F_NUMBER        reduce using rule 12 (simple_stmt -> del_stmt .)
    STRING          reduce using rule 12 (simple_stmt -> del_stmt .)
    TRIPLE_STRING   reduce using rule 12 (simple_stmt -> del_stmt .)
    ELIF            reduce using rule 12 (simple_stmt -> del_stmt .)
    ELSE            reduce using rule 12 (simple_stmt -> del_stmt .)
    DEDENT          reduce using rule 12 (simple_stmt -> del_stmt .)


state 24

    (13) simple_stmt -> BREAK .

    NEWLINE         reduce using rule 13 (simple_stmt -> BREAK .)
    SEMICOLON       reduce using rule 13 (simple_stmt -> BREAK .)
    ENDMARKER       reduce using rule 13 (simple_stmt -> BREAK .)
    DEF             reduce using rule 13 (simple_stmt -> BREAK .)
    IF              reduce using rule 13 (simple_stmt -> BREAK .)
    CLASS           reduce using rule 13 (simple_stmt -> BREAK .)
    FOR             reduce using rule 13 (simple_stmt -> BREAK .)
    WHILE           reduce using rule 13 (simple_stmt -> BREAK .)
    PASS            reduce using rule 13 (simple_stmt -> BREAK .)
    BREAK           reduce using rule 13 (simple_stmt -> BREAK .)
    CONTINUE        reduce using rule 13 (simple_stmt -> BREAK .)
    IDENTIFIER      reduce using rule 13 (simple_stmt -> BREAK .)
    RETURN          reduce using rule 13 (simple_stmt -> BREAK .)
    DEL             reduce using rule 13 (simple_stmt -> BREAK .)
    GLOBAL          reduce using rule 13 (simple_stmt -> BREAK .)
    NOT             reduce using rule 13 (simple_stmt -> BREAK .)
    PLUS            reduce using rule 13 (simple_stmt -> BREAK .)
    MINUS           reduce using rule 13 (simple_stmt -> BREAK .)
    TRUE            reduce using rule 13 (simple_stmt -> BREAK .)
    FALSE           reduce using rule 13 (simple_stmt -> BREAK .)
    NONE            reduce using rule 13 (simple_stmt -> BREAK .)
    NUMBER          reduce using rule 13 (simple_stmt -> BREAK .)
    F_NUMBER        reduce using rule 13 (simple_stmt -> BREAK .)
    STRING          reduce using rule 13 (simple_stmt -> BREAK .)
    TRIPLE_STRING   reduce using rule 13 (simple_stmt -> BREAK .)
    ELIF            reduce using rule 13 (simple_stmt -> BREAK .)
    ELSE            reduce using rule 13 (simple_stmt -> BREAK .)
    DEDENT          reduce using rule 13 (simple_stmt -> BREAK .)


state 25

    (14) simple_stmt -> CONTINUE .

    NEWLINE         reduce using rule 14 (simple_stmt -> CONTINUE .)
    SEMICOLON       reduce using rule 14 (simple_stmt -> CONTINUE .)
    ENDMARKER       reduce using rule 14 (simple_stmt -> CONTINUE .)
    DEF             reduce using rule 14 (simple_stmt -> CONTINUE .)
    IF              reduce using rule 14 (simple_stmt -> CONTINUE .)
    CLASS           reduce using rule 14 (simple_stmt -> CONTINUE .)
    FOR             reduce using rule 14 (simple_stmt -> CONTINUE .)
    WHILE           reduce using rule 14 (simple_stmt -> CONTINUE .)
    PASS            reduce using rule 14 (simple_stmt -> CONTINUE .)
    BREAK           reduce using rule 14 (simple_stmt -> CONTINUE .)
    CONTINUE        reduce using rule 14 (simple_stmt -> CONTINUE .)
    IDENTIFIER      reduce using rule 14 (simple_stmt -> CONTINUE .)
    RETURN          reduce using rule 14 (simple_stmt -> CONTINUE .)
    DEL             reduce using rule 14 (simple_stmt -> CONTINUE .)
    GLOBAL          reduce using rule 14 (simple_stmt -> CONTINUE .)
    NOT             reduce using rule 14 (simple_stmt -> CONTINUE .)
    PLUS            reduce using rule 14 (simple_stmt -> CONTINUE .)
    MINUS           reduce using rule 14 (simple_stmt -> CONTINUE .)
    TRUE            reduce using rule 14 (simple_stmt -> CONTINUE .)
    FALSE           reduce using rule 14 (simple_stmt -> CONTINUE .)
    NONE            reduce using rule 14 (simple_stmt -> CONTINUE .)
    NUMBER          reduce using rule 14 (simple_stmt -> CONTINUE .)
    F_NUMBER        reduce using rule 14 (simple_stmt -> CONTINUE .)
    STRING          reduce using rule 14 (simple_stmt -> CONTINUE .)
    TRIPLE_STRING   reduce using rule 14 (simple_stmt -> CONTINUE .)
    ELIF            reduce using rule 14 (simple_stmt -> CONTINUE .)
    ELSE            reduce using rule 14 (simple_stmt -> CONTINUE .)
    DEDENT          reduce using rule 14 (simple_stmt -> CONTINUE .)


state 26

    (15) simple_stmt -> global_stmt .

    NEWLINE         reduce using rule 15 (simple_stmt -> global_stmt .)
    SEMICOLON       reduce using rule 15 (simple_stmt -> global_stmt .)
    ENDMARKER       reduce using rule 15 (simple_stmt -> global_stmt .)
    DEF             reduce using rule 15 (simple_stmt -> global_stmt .)
    IF              reduce using rule 15 (simple_stmt -> global_stmt .)
    CLASS           reduce using rule 15 (simple_stmt -> global_stmt .)
    FOR             reduce using rule 15 (simple_stmt -> global_stmt .)
    WHILE           reduce using rule 15 (simple_stmt -> global_stmt .)
    PASS            reduce using rule 15 (simple_stmt -> global_stmt .)
    BREAK           reduce using rule 15 (simple_stmt -> global_stmt .)
    CONTINUE        reduce using rule 15 (simple_stmt -> global_stmt .)
    IDENTIFIER      reduce using rule 15 (simple_stmt -> global_stmt .)
    RETURN          reduce using rule 15 (simple_stmt -> global_stmt .)
    DEL             reduce using rule 15 (simple_stmt -> global_stmt .)
    GLOBAL          reduce using rule 15 (simple_stmt -> global_stmt .)
    NOT             reduce using rule 15 (simple_stmt -> global_stmt .)
    PLUS            reduce using rule 15 (simple_stmt -> global_stmt .)
    MINUS           reduce using rule 15 (simple_stmt -> global_stmt .)
    TRUE            reduce using rule 15 (simple_stmt -> global_stmt .)
    FALSE           reduce using rule 15 (simple_stmt -> global_stmt .)
    NONE            reduce using rule 15 (simple_stmt -> global_stmt .)
    NUMBER          reduce using rule 15 (simple_stmt -> global_stmt .)
    F_NUMBER        reduce using rule 15 (simple_stmt -> global_stmt .)
    STRING          reduce using rule 15 (simple_stmt -> global_stmt .)
    TRIPLE_STRING   reduce using rule 15 (simple_stmt -> global_stmt .)
    ELIF            reduce using rule 15 (simple_stmt -> global_stmt .)
    ELSE            reduce using rule 15 (simple_stmt -> global_stmt .)
    DEDENT          reduce using rule 15 (simple_stmt -> global_stmt .)


state 27

    (30) return_stmt -> RETURN . expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expressions                    shift and go to state 77
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 28

    (32) del_stmt -> DEL . namelist
    (33) namelist -> . namelist COMMA IDENTIFIER
    (34) namelist -> . IDENTIFIER

    IDENTIFIER      shift and go to state 79

    namelist                       shift and go to state 78

state 29

    (31) global_stmt -> GLOBAL . namelist
    (33) namelist -> . namelist COMMA IDENTIFIER
    (34) namelist -> . IDENTIFIER

    IDENTIFIER      shift and go to state 79

    namelist                       shift and go to state 80

state 30

    (57) expression -> disjunction . IF disjunction ELSE expression
    (58) expression -> disjunction .

  ! shift/reduce conflict for IF resolved as shift
    IF              shift and go to state 81
    COMMA           reduce using rule 58 (expression -> disjunction .)
    NEWLINE         reduce using rule 58 (expression -> disjunction .)
    COLON           reduce using rule 58 (expression -> disjunction .)
    SEMICOLON       reduce using rule 58 (expression -> disjunction .)
    ENDMARKER       reduce using rule 58 (expression -> disjunction .)
    DEF             reduce using rule 58 (expression -> disjunction .)
    CLASS           reduce using rule 58 (expression -> disjunction .)
    FOR             reduce using rule 58 (expression -> disjunction .)
    WHILE           reduce using rule 58 (expression -> disjunction .)
    PASS            reduce using rule 58 (expression -> disjunction .)
    BREAK           reduce using rule 58 (expression -> disjunction .)
    CONTINUE        reduce using rule 58 (expression -> disjunction .)
    IDENTIFIER      reduce using rule 58 (expression -> disjunction .)
    RETURN          reduce using rule 58 (expression -> disjunction .)
    DEL             reduce using rule 58 (expression -> disjunction .)
    GLOBAL          reduce using rule 58 (expression -> disjunction .)
    NOT             reduce using rule 58 (expression -> disjunction .)
    PLUS            reduce using rule 58 (expression -> disjunction .)
    MINUS           reduce using rule 58 (expression -> disjunction .)
    TRUE            reduce using rule 58 (expression -> disjunction .)
    FALSE           reduce using rule 58 (expression -> disjunction .)
    NONE            reduce using rule 58 (expression -> disjunction .)
    NUMBER          reduce using rule 58 (expression -> disjunction .)
    F_NUMBER        reduce using rule 58 (expression -> disjunction .)
    STRING          reduce using rule 58 (expression -> disjunction .)
    TRIPLE_STRING   reduce using rule 58 (expression -> disjunction .)
    ELIF            reduce using rule 58 (expression -> disjunction .)
    ELSE            reduce using rule 58 (expression -> disjunction .)
    DEDENT          reduce using rule 58 (expression -> disjunction .)
    R_SQB           reduce using rule 58 (expression -> disjunction .)
    R_PARENTHESIS   reduce using rule 58 (expression -> disjunction .)

  ! IF              [ reduce using rule 58 (expression -> disjunction .) ]


state 31

    (59) disjunction -> conjunction . OR disjunction
    (60) disjunction -> conjunction .

    OR              shift and go to state 82
    IF              reduce using rule 60 (disjunction -> conjunction .)
    COMMA           reduce using rule 60 (disjunction -> conjunction .)
    NEWLINE         reduce using rule 60 (disjunction -> conjunction .)
    COLON           reduce using rule 60 (disjunction -> conjunction .)
    SEMICOLON       reduce using rule 60 (disjunction -> conjunction .)
    ENDMARKER       reduce using rule 60 (disjunction -> conjunction .)
    DEF             reduce using rule 60 (disjunction -> conjunction .)
    CLASS           reduce using rule 60 (disjunction -> conjunction .)
    FOR             reduce using rule 60 (disjunction -> conjunction .)
    WHILE           reduce using rule 60 (disjunction -> conjunction .)
    PASS            reduce using rule 60 (disjunction -> conjunction .)
    BREAK           reduce using rule 60 (disjunction -> conjunction .)
    CONTINUE        reduce using rule 60 (disjunction -> conjunction .)
    IDENTIFIER      reduce using rule 60 (disjunction -> conjunction .)
    RETURN          reduce using rule 60 (disjunction -> conjunction .)
    DEL             reduce using rule 60 (disjunction -> conjunction .)
    GLOBAL          reduce using rule 60 (disjunction -> conjunction .)
    NOT             reduce using rule 60 (disjunction -> conjunction .)
    PLUS            reduce using rule 60 (disjunction -> conjunction .)
    MINUS           reduce using rule 60 (disjunction -> conjunction .)
    TRUE            reduce using rule 60 (disjunction -> conjunction .)
    FALSE           reduce using rule 60 (disjunction -> conjunction .)
    NONE            reduce using rule 60 (disjunction -> conjunction .)
    NUMBER          reduce using rule 60 (disjunction -> conjunction .)
    F_NUMBER        reduce using rule 60 (disjunction -> conjunction .)
    STRING          reduce using rule 60 (disjunction -> conjunction .)
    TRIPLE_STRING   reduce using rule 60 (disjunction -> conjunction .)
    ELIF            reduce using rule 60 (disjunction -> conjunction .)
    ELSE            reduce using rule 60 (disjunction -> conjunction .)
    DEDENT          reduce using rule 60 (disjunction -> conjunction .)
    R_SQB           reduce using rule 60 (disjunction -> conjunction .)
    R_PARENTHESIS   reduce using rule 60 (disjunction -> conjunction .)


state 32

    (61) conjunction -> inversion . AND inversion
    (62) conjunction -> inversion .

    AND             shift and go to state 83
    OR              reduce using rule 62 (conjunction -> inversion .)
    IF              reduce using rule 62 (conjunction -> inversion .)
    COMMA           reduce using rule 62 (conjunction -> inversion .)
    NEWLINE         reduce using rule 62 (conjunction -> inversion .)
    COLON           reduce using rule 62 (conjunction -> inversion .)
    SEMICOLON       reduce using rule 62 (conjunction -> inversion .)
    ENDMARKER       reduce using rule 62 (conjunction -> inversion .)
    DEF             reduce using rule 62 (conjunction -> inversion .)
    CLASS           reduce using rule 62 (conjunction -> inversion .)
    FOR             reduce using rule 62 (conjunction -> inversion .)
    WHILE           reduce using rule 62 (conjunction -> inversion .)
    PASS            reduce using rule 62 (conjunction -> inversion .)
    BREAK           reduce using rule 62 (conjunction -> inversion .)
    CONTINUE        reduce using rule 62 (conjunction -> inversion .)
    IDENTIFIER      reduce using rule 62 (conjunction -> inversion .)
    RETURN          reduce using rule 62 (conjunction -> inversion .)
    DEL             reduce using rule 62 (conjunction -> inversion .)
    GLOBAL          reduce using rule 62 (conjunction -> inversion .)
    NOT             reduce using rule 62 (conjunction -> inversion .)
    PLUS            reduce using rule 62 (conjunction -> inversion .)
    MINUS           reduce using rule 62 (conjunction -> inversion .)
    TRUE            reduce using rule 62 (conjunction -> inversion .)
    FALSE           reduce using rule 62 (conjunction -> inversion .)
    NONE            reduce using rule 62 (conjunction -> inversion .)
    NUMBER          reduce using rule 62 (conjunction -> inversion .)
    F_NUMBER        reduce using rule 62 (conjunction -> inversion .)
    STRING          reduce using rule 62 (conjunction -> inversion .)
    TRIPLE_STRING   reduce using rule 62 (conjunction -> inversion .)
    ELIF            reduce using rule 62 (conjunction -> inversion .)
    ELSE            reduce using rule 62 (conjunction -> inversion .)
    DEDENT          reduce using rule 62 (conjunction -> inversion .)
    R_SQB           reduce using rule 62 (conjunction -> inversion .)
    R_PARENTHESIS   reduce using rule 62 (conjunction -> inversion .)


state 33

    (63) inversion -> NOT . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    inversion                      shift and go to state 84
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 34

    (64) inversion -> comparison .

    AND             reduce using rule 64 (inversion -> comparison .)
    OR              reduce using rule 64 (inversion -> comparison .)
    IF              reduce using rule 64 (inversion -> comparison .)
    COMMA           reduce using rule 64 (inversion -> comparison .)
    NEWLINE         reduce using rule 64 (inversion -> comparison .)
    COLON           reduce using rule 64 (inversion -> comparison .)
    SEMICOLON       reduce using rule 64 (inversion -> comparison .)
    ENDMARKER       reduce using rule 64 (inversion -> comparison .)
    DEF             reduce using rule 64 (inversion -> comparison .)
    CLASS           reduce using rule 64 (inversion -> comparison .)
    FOR             reduce using rule 64 (inversion -> comparison .)
    WHILE           reduce using rule 64 (inversion -> comparison .)
    PASS            reduce using rule 64 (inversion -> comparison .)
    BREAK           reduce using rule 64 (inversion -> comparison .)
    CONTINUE        reduce using rule 64 (inversion -> comparison .)
    IDENTIFIER      reduce using rule 64 (inversion -> comparison .)
    RETURN          reduce using rule 64 (inversion -> comparison .)
    DEL             reduce using rule 64 (inversion -> comparison .)
    GLOBAL          reduce using rule 64 (inversion -> comparison .)
    NOT             reduce using rule 64 (inversion -> comparison .)
    PLUS            reduce using rule 64 (inversion -> comparison .)
    MINUS           reduce using rule 64 (inversion -> comparison .)
    TRUE            reduce using rule 64 (inversion -> comparison .)
    FALSE           reduce using rule 64 (inversion -> comparison .)
    NONE            reduce using rule 64 (inversion -> comparison .)
    NUMBER          reduce using rule 64 (inversion -> comparison .)
    F_NUMBER        reduce using rule 64 (inversion -> comparison .)
    STRING          reduce using rule 64 (inversion -> comparison .)
    TRIPLE_STRING   reduce using rule 64 (inversion -> comparison .)
    ELIF            reduce using rule 64 (inversion -> comparison .)
    ELSE            reduce using rule 64 (inversion -> comparison .)
    DEDENT          reduce using rule 64 (inversion -> comparison .)
    R_SQB           reduce using rule 64 (inversion -> comparison .)
    R_PARENTHESIS   reduce using rule 64 (inversion -> comparison .)


state 35

    (65) comparison -> bitwise_or . compare_op_list
    (66) comparison -> bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor
    (67) compare_op_list -> . compare_op_list compare_op
    (68) compare_op_list -> . compare_op
    (69) compare_op -> . EQUALITY bitwise_or
    (70) compare_op -> . INEQUALITY bitwise_or
    (71) compare_op -> . GREATER_EQUAL bitwise_or
    (72) compare_op -> . LESSER_EQUAL bitwise_or
    (73) compare_op -> . GREATER bitwise_or
    (74) compare_op -> . LESSER bitwise_or
    (75) compare_op -> . NOT IN bitwise_or
    (76) compare_op -> . IS NOT bitwise_or
    (77) compare_op -> . IN bitwise_or
    (78) compare_op -> . IS bitwise_or

  ! shift/reduce conflict for NOT resolved as shift
    AND             reduce using rule 66 (comparison -> bitwise_or .)
    OR              reduce using rule 66 (comparison -> bitwise_or .)
    IF              reduce using rule 66 (comparison -> bitwise_or .)
    COMMA           reduce using rule 66 (comparison -> bitwise_or .)
    NEWLINE         reduce using rule 66 (comparison -> bitwise_or .)
    COLON           reduce using rule 66 (comparison -> bitwise_or .)
    SEMICOLON       reduce using rule 66 (comparison -> bitwise_or .)
    ENDMARKER       reduce using rule 66 (comparison -> bitwise_or .)
    DEF             reduce using rule 66 (comparison -> bitwise_or .)
    CLASS           reduce using rule 66 (comparison -> bitwise_or .)
    FOR             reduce using rule 66 (comparison -> bitwise_or .)
    WHILE           reduce using rule 66 (comparison -> bitwise_or .)
    PASS            reduce using rule 66 (comparison -> bitwise_or .)
    BREAK           reduce using rule 66 (comparison -> bitwise_or .)
    CONTINUE        reduce using rule 66 (comparison -> bitwise_or .)
    IDENTIFIER      reduce using rule 66 (comparison -> bitwise_or .)
    RETURN          reduce using rule 66 (comparison -> bitwise_or .)
    DEL             reduce using rule 66 (comparison -> bitwise_or .)
    GLOBAL          reduce using rule 66 (comparison -> bitwise_or .)
    PLUS            reduce using rule 66 (comparison -> bitwise_or .)
    MINUS           reduce using rule 66 (comparison -> bitwise_or .)
    TRUE            reduce using rule 66 (comparison -> bitwise_or .)
    FALSE           reduce using rule 66 (comparison -> bitwise_or .)
    NONE            reduce using rule 66 (comparison -> bitwise_or .)
    NUMBER          reduce using rule 66 (comparison -> bitwise_or .)
    F_NUMBER        reduce using rule 66 (comparison -> bitwise_or .)
    STRING          reduce using rule 66 (comparison -> bitwise_or .)
    TRIPLE_STRING   reduce using rule 66 (comparison -> bitwise_or .)
    ELIF            reduce using rule 66 (comparison -> bitwise_or .)
    ELSE            reduce using rule 66 (comparison -> bitwise_or .)
    DEDENT          reduce using rule 66 (comparison -> bitwise_or .)
    R_SQB           reduce using rule 66 (comparison -> bitwise_or .)
    R_PARENTHESIS   reduce using rule 66 (comparison -> bitwise_or .)
    BITWISE_OR      shift and go to state 86
    EQUALITY        shift and go to state 88
    INEQUALITY      shift and go to state 89
    GREATER_EQUAL   shift and go to state 90
    LESSER_EQUAL    shift and go to state 91
    GREATER         shift and go to state 92
    LESSER          shift and go to state 93
    NOT             shift and go to state 94
    IS              shift and go to state 96
    IN              shift and go to state 95

  ! NOT             [ reduce using rule 66 (comparison -> bitwise_or .) ]

    compare_op_list                shift and go to state 85
    compare_op                     shift and go to state 87

state 36

    (80) bitwise_or -> bitwise_xor .
    (81) bitwise_xor -> bitwise_xor . BITWISE_XOR bitwise_and

    BITWISE_OR      reduce using rule 80 (bitwise_or -> bitwise_xor .)
    EQUALITY        reduce using rule 80 (bitwise_or -> bitwise_xor .)
    INEQUALITY      reduce using rule 80 (bitwise_or -> bitwise_xor .)
    GREATER_EQUAL   reduce using rule 80 (bitwise_or -> bitwise_xor .)
    LESSER_EQUAL    reduce using rule 80 (bitwise_or -> bitwise_xor .)
    GREATER         reduce using rule 80 (bitwise_or -> bitwise_xor .)
    LESSER          reduce using rule 80 (bitwise_or -> bitwise_xor .)
    NOT             reduce using rule 80 (bitwise_or -> bitwise_xor .)
    IS              reduce using rule 80 (bitwise_or -> bitwise_xor .)
    IN              reduce using rule 80 (bitwise_or -> bitwise_xor .)
    AND             reduce using rule 80 (bitwise_or -> bitwise_xor .)
    OR              reduce using rule 80 (bitwise_or -> bitwise_xor .)
    IF              reduce using rule 80 (bitwise_or -> bitwise_xor .)
    COMMA           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    NEWLINE         reduce using rule 80 (bitwise_or -> bitwise_xor .)
    COLON           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    SEMICOLON       reduce using rule 80 (bitwise_or -> bitwise_xor .)
    ENDMARKER       reduce using rule 80 (bitwise_or -> bitwise_xor .)
    DEF             reduce using rule 80 (bitwise_or -> bitwise_xor .)
    CLASS           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    FOR             reduce using rule 80 (bitwise_or -> bitwise_xor .)
    WHILE           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    PASS            reduce using rule 80 (bitwise_or -> bitwise_xor .)
    BREAK           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    CONTINUE        reduce using rule 80 (bitwise_or -> bitwise_xor .)
    IDENTIFIER      reduce using rule 80 (bitwise_or -> bitwise_xor .)
    RETURN          reduce using rule 80 (bitwise_or -> bitwise_xor .)
    DEL             reduce using rule 80 (bitwise_or -> bitwise_xor .)
    GLOBAL          reduce using rule 80 (bitwise_or -> bitwise_xor .)
    PLUS            reduce using rule 80 (bitwise_or -> bitwise_xor .)
    MINUS           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    TRUE            reduce using rule 80 (bitwise_or -> bitwise_xor .)
    FALSE           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    NONE            reduce using rule 80 (bitwise_or -> bitwise_xor .)
    NUMBER          reduce using rule 80 (bitwise_or -> bitwise_xor .)
    F_NUMBER        reduce using rule 80 (bitwise_or -> bitwise_xor .)
    STRING          reduce using rule 80 (bitwise_or -> bitwise_xor .)
    TRIPLE_STRING   reduce using rule 80 (bitwise_or -> bitwise_xor .)
    ELIF            reduce using rule 80 (bitwise_or -> bitwise_xor .)
    ELSE            reduce using rule 80 (bitwise_or -> bitwise_xor .)
    DEDENT          reduce using rule 80 (bitwise_or -> bitwise_xor .)
    R_SQB           reduce using rule 80 (bitwise_or -> bitwise_xor .)
    R_PARENTHESIS   reduce using rule 80 (bitwise_or -> bitwise_xor .)
    BITWISE_XOR     shift and go to state 97


state 37

    (82) bitwise_xor -> bitwise_and .
    (83) bitwise_and -> bitwise_and . BITWISE_AND shift_expr

    BITWISE_XOR     reduce using rule 82 (bitwise_xor -> bitwise_and .)
    BITWISE_OR      reduce using rule 82 (bitwise_xor -> bitwise_and .)
    EQUALITY        reduce using rule 82 (bitwise_xor -> bitwise_and .)
    INEQUALITY      reduce using rule 82 (bitwise_xor -> bitwise_and .)
    GREATER_EQUAL   reduce using rule 82 (bitwise_xor -> bitwise_and .)
    LESSER_EQUAL    reduce using rule 82 (bitwise_xor -> bitwise_and .)
    GREATER         reduce using rule 82 (bitwise_xor -> bitwise_and .)
    LESSER          reduce using rule 82 (bitwise_xor -> bitwise_and .)
    NOT             reduce using rule 82 (bitwise_xor -> bitwise_and .)
    IS              reduce using rule 82 (bitwise_xor -> bitwise_and .)
    IN              reduce using rule 82 (bitwise_xor -> bitwise_and .)
    AND             reduce using rule 82 (bitwise_xor -> bitwise_and .)
    OR              reduce using rule 82 (bitwise_xor -> bitwise_and .)
    IF              reduce using rule 82 (bitwise_xor -> bitwise_and .)
    COMMA           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    NEWLINE         reduce using rule 82 (bitwise_xor -> bitwise_and .)
    COLON           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    SEMICOLON       reduce using rule 82 (bitwise_xor -> bitwise_and .)
    ENDMARKER       reduce using rule 82 (bitwise_xor -> bitwise_and .)
    DEF             reduce using rule 82 (bitwise_xor -> bitwise_and .)
    CLASS           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    FOR             reduce using rule 82 (bitwise_xor -> bitwise_and .)
    WHILE           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    PASS            reduce using rule 82 (bitwise_xor -> bitwise_and .)
    BREAK           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    CONTINUE        reduce using rule 82 (bitwise_xor -> bitwise_and .)
    IDENTIFIER      reduce using rule 82 (bitwise_xor -> bitwise_and .)
    RETURN          reduce using rule 82 (bitwise_xor -> bitwise_and .)
    DEL             reduce using rule 82 (bitwise_xor -> bitwise_and .)
    GLOBAL          reduce using rule 82 (bitwise_xor -> bitwise_and .)
    PLUS            reduce using rule 82 (bitwise_xor -> bitwise_and .)
    MINUS           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    TRUE            reduce using rule 82 (bitwise_xor -> bitwise_and .)
    FALSE           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    NONE            reduce using rule 82 (bitwise_xor -> bitwise_and .)
    NUMBER          reduce using rule 82 (bitwise_xor -> bitwise_and .)
    F_NUMBER        reduce using rule 82 (bitwise_xor -> bitwise_and .)
    STRING          reduce using rule 82 (bitwise_xor -> bitwise_and .)
    TRIPLE_STRING   reduce using rule 82 (bitwise_xor -> bitwise_and .)
    ELIF            reduce using rule 82 (bitwise_xor -> bitwise_and .)
    ELSE            reduce using rule 82 (bitwise_xor -> bitwise_and .)
    DEDENT          reduce using rule 82 (bitwise_xor -> bitwise_and .)
    R_SQB           reduce using rule 82 (bitwise_xor -> bitwise_and .)
    R_PARENTHESIS   reduce using rule 82 (bitwise_xor -> bitwise_and .)
    BITWISE_AND     shift and go to state 98


state 38

    (84) bitwise_and -> shift_expr .
    (85) shift_expr -> shift_expr . L_SHIFT sum
    (86) shift_expr -> shift_expr . R_SHIFT sum

    BITWISE_AND     reduce using rule 84 (bitwise_and -> shift_expr .)
    BITWISE_XOR     reduce using rule 84 (bitwise_and -> shift_expr .)
    BITWISE_OR      reduce using rule 84 (bitwise_and -> shift_expr .)
    EQUALITY        reduce using rule 84 (bitwise_and -> shift_expr .)
    INEQUALITY      reduce using rule 84 (bitwise_and -> shift_expr .)
    GREATER_EQUAL   reduce using rule 84 (bitwise_and -> shift_expr .)
    LESSER_EQUAL    reduce using rule 84 (bitwise_and -> shift_expr .)
    GREATER         reduce using rule 84 (bitwise_and -> shift_expr .)
    LESSER          reduce using rule 84 (bitwise_and -> shift_expr .)
    NOT             reduce using rule 84 (bitwise_and -> shift_expr .)
    IS              reduce using rule 84 (bitwise_and -> shift_expr .)
    IN              reduce using rule 84 (bitwise_and -> shift_expr .)
    AND             reduce using rule 84 (bitwise_and -> shift_expr .)
    OR              reduce using rule 84 (bitwise_and -> shift_expr .)
    IF              reduce using rule 84 (bitwise_and -> shift_expr .)
    COMMA           reduce using rule 84 (bitwise_and -> shift_expr .)
    NEWLINE         reduce using rule 84 (bitwise_and -> shift_expr .)
    COLON           reduce using rule 84 (bitwise_and -> shift_expr .)
    SEMICOLON       reduce using rule 84 (bitwise_and -> shift_expr .)
    ENDMARKER       reduce using rule 84 (bitwise_and -> shift_expr .)
    DEF             reduce using rule 84 (bitwise_and -> shift_expr .)
    CLASS           reduce using rule 84 (bitwise_and -> shift_expr .)
    FOR             reduce using rule 84 (bitwise_and -> shift_expr .)
    WHILE           reduce using rule 84 (bitwise_and -> shift_expr .)
    PASS            reduce using rule 84 (bitwise_and -> shift_expr .)
    BREAK           reduce using rule 84 (bitwise_and -> shift_expr .)
    CONTINUE        reduce using rule 84 (bitwise_and -> shift_expr .)
    IDENTIFIER      reduce using rule 84 (bitwise_and -> shift_expr .)
    RETURN          reduce using rule 84 (bitwise_and -> shift_expr .)
    DEL             reduce using rule 84 (bitwise_and -> shift_expr .)
    GLOBAL          reduce using rule 84 (bitwise_and -> shift_expr .)
    PLUS            reduce using rule 84 (bitwise_and -> shift_expr .)
    MINUS           reduce using rule 84 (bitwise_and -> shift_expr .)
    TRUE            reduce using rule 84 (bitwise_and -> shift_expr .)
    FALSE           reduce using rule 84 (bitwise_and -> shift_expr .)
    NONE            reduce using rule 84 (bitwise_and -> shift_expr .)
    NUMBER          reduce using rule 84 (bitwise_and -> shift_expr .)
    F_NUMBER        reduce using rule 84 (bitwise_and -> shift_expr .)
    STRING          reduce using rule 84 (bitwise_and -> shift_expr .)
    TRIPLE_STRING   reduce using rule 84 (bitwise_and -> shift_expr .)
    ELIF            reduce using rule 84 (bitwise_and -> shift_expr .)
    ELSE            reduce using rule 84 (bitwise_and -> shift_expr .)
    DEDENT          reduce using rule 84 (bitwise_and -> shift_expr .)
    R_SQB           reduce using rule 84 (bitwise_and -> shift_expr .)
    R_PARENTHESIS   reduce using rule 84 (bitwise_and -> shift_expr .)
    L_SHIFT         shift and go to state 99
    R_SHIFT         shift and go to state 100


state 39

    (87) shift_expr -> sum .
    (88) sum -> sum . PLUS term
    (89) sum -> sum . MINUS term

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    L_SHIFT         reduce using rule 87 (shift_expr -> sum .)
    R_SHIFT         reduce using rule 87 (shift_expr -> sum .)
    BITWISE_AND     reduce using rule 87 (shift_expr -> sum .)
    BITWISE_XOR     reduce using rule 87 (shift_expr -> sum .)
    BITWISE_OR      reduce using rule 87 (shift_expr -> sum .)
    EQUALITY        reduce using rule 87 (shift_expr -> sum .)
    INEQUALITY      reduce using rule 87 (shift_expr -> sum .)
    GREATER_EQUAL   reduce using rule 87 (shift_expr -> sum .)
    LESSER_EQUAL    reduce using rule 87 (shift_expr -> sum .)
    GREATER         reduce using rule 87 (shift_expr -> sum .)
    LESSER          reduce using rule 87 (shift_expr -> sum .)
    NOT             reduce using rule 87 (shift_expr -> sum .)
    IS              reduce using rule 87 (shift_expr -> sum .)
    IN              reduce using rule 87 (shift_expr -> sum .)
    AND             reduce using rule 87 (shift_expr -> sum .)
    OR              reduce using rule 87 (shift_expr -> sum .)
    IF              reduce using rule 87 (shift_expr -> sum .)
    COMMA           reduce using rule 87 (shift_expr -> sum .)
    NEWLINE         reduce using rule 87 (shift_expr -> sum .)
    COLON           reduce using rule 87 (shift_expr -> sum .)
    SEMICOLON       reduce using rule 87 (shift_expr -> sum .)
    ENDMARKER       reduce using rule 87 (shift_expr -> sum .)
    DEF             reduce using rule 87 (shift_expr -> sum .)
    CLASS           reduce using rule 87 (shift_expr -> sum .)
    FOR             reduce using rule 87 (shift_expr -> sum .)
    WHILE           reduce using rule 87 (shift_expr -> sum .)
    PASS            reduce using rule 87 (shift_expr -> sum .)
    BREAK           reduce using rule 87 (shift_expr -> sum .)
    CONTINUE        reduce using rule 87 (shift_expr -> sum .)
    IDENTIFIER      reduce using rule 87 (shift_expr -> sum .)
    RETURN          reduce using rule 87 (shift_expr -> sum .)
    DEL             reduce using rule 87 (shift_expr -> sum .)
    GLOBAL          reduce using rule 87 (shift_expr -> sum .)
    TRUE            reduce using rule 87 (shift_expr -> sum .)
    FALSE           reduce using rule 87 (shift_expr -> sum .)
    NONE            reduce using rule 87 (shift_expr -> sum .)
    NUMBER          reduce using rule 87 (shift_expr -> sum .)
    F_NUMBER        reduce using rule 87 (shift_expr -> sum .)
    STRING          reduce using rule 87 (shift_expr -> sum .)
    TRIPLE_STRING   reduce using rule 87 (shift_expr -> sum .)
    ELIF            reduce using rule 87 (shift_expr -> sum .)
    ELSE            reduce using rule 87 (shift_expr -> sum .)
    DEDENT          reduce using rule 87 (shift_expr -> sum .)
    R_SQB           reduce using rule 87 (shift_expr -> sum .)
    R_PARENTHESIS   reduce using rule 87 (shift_expr -> sum .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102

  ! PLUS            [ reduce using rule 87 (shift_expr -> sum .) ]
  ! MINUS           [ reduce using rule 87 (shift_expr -> sum .) ]


state 40

    (96) factor -> PLUS . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    factor                         shift and go to state 103
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 41

    (90) sum -> term .
    (91) term -> term . STAR factor
    (92) term -> term . DIVISION factor
    (93) term -> term . INTEGER_DIVISION factor
    (94) term -> term . MODULUS factor

    PLUS            reduce using rule 90 (sum -> term .)
    MINUS           reduce using rule 90 (sum -> term .)
    L_SHIFT         reduce using rule 90 (sum -> term .)
    R_SHIFT         reduce using rule 90 (sum -> term .)
    BITWISE_AND     reduce using rule 90 (sum -> term .)
    BITWISE_XOR     reduce using rule 90 (sum -> term .)
    BITWISE_OR      reduce using rule 90 (sum -> term .)
    EQUALITY        reduce using rule 90 (sum -> term .)
    INEQUALITY      reduce using rule 90 (sum -> term .)
    GREATER_EQUAL   reduce using rule 90 (sum -> term .)
    LESSER_EQUAL    reduce using rule 90 (sum -> term .)
    GREATER         reduce using rule 90 (sum -> term .)
    LESSER          reduce using rule 90 (sum -> term .)
    NOT             reduce using rule 90 (sum -> term .)
    IS              reduce using rule 90 (sum -> term .)
    IN              reduce using rule 90 (sum -> term .)
    AND             reduce using rule 90 (sum -> term .)
    OR              reduce using rule 90 (sum -> term .)
    IF              reduce using rule 90 (sum -> term .)
    COMMA           reduce using rule 90 (sum -> term .)
    NEWLINE         reduce using rule 90 (sum -> term .)
    COLON           reduce using rule 90 (sum -> term .)
    SEMICOLON       reduce using rule 90 (sum -> term .)
    ENDMARKER       reduce using rule 90 (sum -> term .)
    DEF             reduce using rule 90 (sum -> term .)
    CLASS           reduce using rule 90 (sum -> term .)
    FOR             reduce using rule 90 (sum -> term .)
    WHILE           reduce using rule 90 (sum -> term .)
    PASS            reduce using rule 90 (sum -> term .)
    BREAK           reduce using rule 90 (sum -> term .)
    CONTINUE        reduce using rule 90 (sum -> term .)
    IDENTIFIER      reduce using rule 90 (sum -> term .)
    RETURN          reduce using rule 90 (sum -> term .)
    DEL             reduce using rule 90 (sum -> term .)
    GLOBAL          reduce using rule 90 (sum -> term .)
    TRUE            reduce using rule 90 (sum -> term .)
    FALSE           reduce using rule 90 (sum -> term .)
    NONE            reduce using rule 90 (sum -> term .)
    NUMBER          reduce using rule 90 (sum -> term .)
    F_NUMBER        reduce using rule 90 (sum -> term .)
    STRING          reduce using rule 90 (sum -> term .)
    TRIPLE_STRING   reduce using rule 90 (sum -> term .)
    ELIF            reduce using rule 90 (sum -> term .)
    ELSE            reduce using rule 90 (sum -> term .)
    DEDENT          reduce using rule 90 (sum -> term .)
    R_SQB           reduce using rule 90 (sum -> term .)
    R_PARENTHESIS   reduce using rule 90 (sum -> term .)
    STAR            shift and go to state 104
    DIVISION        shift and go to state 105
    INTEGER_DIVISION shift and go to state 106
    MODULUS         shift and go to state 107


state 42

    (97) factor -> MINUS . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    factor                         shift and go to state 108
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 43

    (95) term -> factor .

    STAR            reduce using rule 95 (term -> factor .)
    DIVISION        reduce using rule 95 (term -> factor .)
    INTEGER_DIVISION reduce using rule 95 (term -> factor .)
    MODULUS         reduce using rule 95 (term -> factor .)
    PLUS            reduce using rule 95 (term -> factor .)
    MINUS           reduce using rule 95 (term -> factor .)
    L_SHIFT         reduce using rule 95 (term -> factor .)
    R_SHIFT         reduce using rule 95 (term -> factor .)
    BITWISE_AND     reduce using rule 95 (term -> factor .)
    BITWISE_XOR     reduce using rule 95 (term -> factor .)
    BITWISE_OR      reduce using rule 95 (term -> factor .)
    EQUALITY        reduce using rule 95 (term -> factor .)
    INEQUALITY      reduce using rule 95 (term -> factor .)
    GREATER_EQUAL   reduce using rule 95 (term -> factor .)
    LESSER_EQUAL    reduce using rule 95 (term -> factor .)
    GREATER         reduce using rule 95 (term -> factor .)
    LESSER          reduce using rule 95 (term -> factor .)
    NOT             reduce using rule 95 (term -> factor .)
    IS              reduce using rule 95 (term -> factor .)
    IN              reduce using rule 95 (term -> factor .)
    AND             reduce using rule 95 (term -> factor .)
    OR              reduce using rule 95 (term -> factor .)
    IF              reduce using rule 95 (term -> factor .)
    COMMA           reduce using rule 95 (term -> factor .)
    NEWLINE         reduce using rule 95 (term -> factor .)
    COLON           reduce using rule 95 (term -> factor .)
    SEMICOLON       reduce using rule 95 (term -> factor .)
    ENDMARKER       reduce using rule 95 (term -> factor .)
    DEF             reduce using rule 95 (term -> factor .)
    CLASS           reduce using rule 95 (term -> factor .)
    FOR             reduce using rule 95 (term -> factor .)
    WHILE           reduce using rule 95 (term -> factor .)
    PASS            reduce using rule 95 (term -> factor .)
    BREAK           reduce using rule 95 (term -> factor .)
    CONTINUE        reduce using rule 95 (term -> factor .)
    IDENTIFIER      reduce using rule 95 (term -> factor .)
    RETURN          reduce using rule 95 (term -> factor .)
    DEL             reduce using rule 95 (term -> factor .)
    GLOBAL          reduce using rule 95 (term -> factor .)
    TRUE            reduce using rule 95 (term -> factor .)
    FALSE           reduce using rule 95 (term -> factor .)
    NONE            reduce using rule 95 (term -> factor .)
    NUMBER          reduce using rule 95 (term -> factor .)
    F_NUMBER        reduce using rule 95 (term -> factor .)
    STRING          reduce using rule 95 (term -> factor .)
    TRIPLE_STRING   reduce using rule 95 (term -> factor .)
    ELIF            reduce using rule 95 (term -> factor .)
    ELSE            reduce using rule 95 (term -> factor .)
    DEDENT          reduce using rule 95 (term -> factor .)
    R_SQB           reduce using rule 95 (term -> factor .)
    R_PARENTHESIS   reduce using rule 95 (term -> factor .)


state 44

    (98) factor -> power .

    STAR            reduce using rule 98 (factor -> power .)
    DIVISION        reduce using rule 98 (factor -> power .)
    INTEGER_DIVISION reduce using rule 98 (factor -> power .)
    MODULUS         reduce using rule 98 (factor -> power .)
    PLUS            reduce using rule 98 (factor -> power .)
    MINUS           reduce using rule 98 (factor -> power .)
    L_SHIFT         reduce using rule 98 (factor -> power .)
    R_SHIFT         reduce using rule 98 (factor -> power .)
    BITWISE_AND     reduce using rule 98 (factor -> power .)
    BITWISE_XOR     reduce using rule 98 (factor -> power .)
    BITWISE_OR      reduce using rule 98 (factor -> power .)
    EQUALITY        reduce using rule 98 (factor -> power .)
    INEQUALITY      reduce using rule 98 (factor -> power .)
    GREATER_EQUAL   reduce using rule 98 (factor -> power .)
    LESSER_EQUAL    reduce using rule 98 (factor -> power .)
    GREATER         reduce using rule 98 (factor -> power .)
    LESSER          reduce using rule 98 (factor -> power .)
    NOT             reduce using rule 98 (factor -> power .)
    IS              reduce using rule 98 (factor -> power .)
    IN              reduce using rule 98 (factor -> power .)
    AND             reduce using rule 98 (factor -> power .)
    OR              reduce using rule 98 (factor -> power .)
    IF              reduce using rule 98 (factor -> power .)
    COMMA           reduce using rule 98 (factor -> power .)
    NEWLINE         reduce using rule 98 (factor -> power .)
    COLON           reduce using rule 98 (factor -> power .)
    SEMICOLON       reduce using rule 98 (factor -> power .)
    ENDMARKER       reduce using rule 98 (factor -> power .)
    DEF             reduce using rule 98 (factor -> power .)
    CLASS           reduce using rule 98 (factor -> power .)
    FOR             reduce using rule 98 (factor -> power .)
    WHILE           reduce using rule 98 (factor -> power .)
    PASS            reduce using rule 98 (factor -> power .)
    BREAK           reduce using rule 98 (factor -> power .)
    CONTINUE        reduce using rule 98 (factor -> power .)
    IDENTIFIER      reduce using rule 98 (factor -> power .)
    RETURN          reduce using rule 98 (factor -> power .)
    DEL             reduce using rule 98 (factor -> power .)
    GLOBAL          reduce using rule 98 (factor -> power .)
    TRUE            reduce using rule 98 (factor -> power .)
    FALSE           reduce using rule 98 (factor -> power .)
    NONE            reduce using rule 98 (factor -> power .)
    NUMBER          reduce using rule 98 (factor -> power .)
    F_NUMBER        reduce using rule 98 (factor -> power .)
    STRING          reduce using rule 98 (factor -> power .)
    TRIPLE_STRING   reduce using rule 98 (factor -> power .)
    ELIF            reduce using rule 98 (factor -> power .)
    ELSE            reduce using rule 98 (factor -> power .)
    DEDENT          reduce using rule 98 (factor -> power .)
    R_SQB           reduce using rule 98 (factor -> power .)
    R_PARENTHESIS   reduce using rule 98 (factor -> power .)


state 45

    (99) power -> primary . EXPONENTIATION target
    (100) power -> primary .
    (101) primary -> primary . L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> primary . L_SQB slices R_SQB
    (103) primary -> primary . DOT IDENTIFIER

    EXPONENTIATION  shift and go to state 109
    STAR            reduce using rule 100 (power -> primary .)
    DIVISION        reduce using rule 100 (power -> primary .)
    INTEGER_DIVISION reduce using rule 100 (power -> primary .)
    MODULUS         reduce using rule 100 (power -> primary .)
    PLUS            reduce using rule 100 (power -> primary .)
    MINUS           reduce using rule 100 (power -> primary .)
    L_SHIFT         reduce using rule 100 (power -> primary .)
    R_SHIFT         reduce using rule 100 (power -> primary .)
    BITWISE_AND     reduce using rule 100 (power -> primary .)
    BITWISE_XOR     reduce using rule 100 (power -> primary .)
    BITWISE_OR      reduce using rule 100 (power -> primary .)
    EQUALITY        reduce using rule 100 (power -> primary .)
    INEQUALITY      reduce using rule 100 (power -> primary .)
    GREATER_EQUAL   reduce using rule 100 (power -> primary .)
    LESSER_EQUAL    reduce using rule 100 (power -> primary .)
    GREATER         reduce using rule 100 (power -> primary .)
    LESSER          reduce using rule 100 (power -> primary .)
    NOT             reduce using rule 100 (power -> primary .)
    IS              reduce using rule 100 (power -> primary .)
    IN              reduce using rule 100 (power -> primary .)
    AND             reduce using rule 100 (power -> primary .)
    OR              reduce using rule 100 (power -> primary .)
    IF              reduce using rule 100 (power -> primary .)
    COMMA           reduce using rule 100 (power -> primary .)
    NEWLINE         reduce using rule 100 (power -> primary .)
    COLON           reduce using rule 100 (power -> primary .)
    SEMICOLON       reduce using rule 100 (power -> primary .)
    ENDMARKER       reduce using rule 100 (power -> primary .)
    DEF             reduce using rule 100 (power -> primary .)
    CLASS           reduce using rule 100 (power -> primary .)
    FOR             reduce using rule 100 (power -> primary .)
    WHILE           reduce using rule 100 (power -> primary .)
    PASS            reduce using rule 100 (power -> primary .)
    BREAK           reduce using rule 100 (power -> primary .)
    CONTINUE        reduce using rule 100 (power -> primary .)
    IDENTIFIER      reduce using rule 100 (power -> primary .)
    RETURN          reduce using rule 100 (power -> primary .)
    DEL             reduce using rule 100 (power -> primary .)
    GLOBAL          reduce using rule 100 (power -> primary .)
    TRUE            reduce using rule 100 (power -> primary .)
    FALSE           reduce using rule 100 (power -> primary .)
    NONE            reduce using rule 100 (power -> primary .)
    NUMBER          reduce using rule 100 (power -> primary .)
    F_NUMBER        reduce using rule 100 (power -> primary .)
    STRING          reduce using rule 100 (power -> primary .)
    TRIPLE_STRING   reduce using rule 100 (power -> primary .)
    ELIF            reduce using rule 100 (power -> primary .)
    ELSE            reduce using rule 100 (power -> primary .)
    DEDENT          reduce using rule 100 (power -> primary .)
    R_SQB           reduce using rule 100 (power -> primary .)
    R_PARENTHESIS   reduce using rule 100 (power -> primary .)
    L_PARENTHESIS   shift and go to state 110
    L_SQB           shift and go to state 111
    DOT             shift and go to state 112


state 46

    (104) primary -> atomic .

    EXPONENTIATION  reduce using rule 104 (primary -> atomic .)
    L_PARENTHESIS   reduce using rule 104 (primary -> atomic .)
    L_SQB           reduce using rule 104 (primary -> atomic .)
    DOT             reduce using rule 104 (primary -> atomic .)
    STAR            reduce using rule 104 (primary -> atomic .)
    DIVISION        reduce using rule 104 (primary -> atomic .)
    INTEGER_DIVISION reduce using rule 104 (primary -> atomic .)
    MODULUS         reduce using rule 104 (primary -> atomic .)
    PLUS            reduce using rule 104 (primary -> atomic .)
    MINUS           reduce using rule 104 (primary -> atomic .)
    L_SHIFT         reduce using rule 104 (primary -> atomic .)
    R_SHIFT         reduce using rule 104 (primary -> atomic .)
    BITWISE_AND     reduce using rule 104 (primary -> atomic .)
    BITWISE_XOR     reduce using rule 104 (primary -> atomic .)
    BITWISE_OR      reduce using rule 104 (primary -> atomic .)
    EQUALITY        reduce using rule 104 (primary -> atomic .)
    INEQUALITY      reduce using rule 104 (primary -> atomic .)
    GREATER_EQUAL   reduce using rule 104 (primary -> atomic .)
    LESSER_EQUAL    reduce using rule 104 (primary -> atomic .)
    GREATER         reduce using rule 104 (primary -> atomic .)
    LESSER          reduce using rule 104 (primary -> atomic .)
    NOT             reduce using rule 104 (primary -> atomic .)
    IS              reduce using rule 104 (primary -> atomic .)
    IN              reduce using rule 104 (primary -> atomic .)
    AND             reduce using rule 104 (primary -> atomic .)
    OR              reduce using rule 104 (primary -> atomic .)
    IF              reduce using rule 104 (primary -> atomic .)
    COMMA           reduce using rule 104 (primary -> atomic .)
    NEWLINE         reduce using rule 104 (primary -> atomic .)
    COLON           reduce using rule 104 (primary -> atomic .)
    SEMICOLON       reduce using rule 104 (primary -> atomic .)
    ENDMARKER       reduce using rule 104 (primary -> atomic .)
    DEF             reduce using rule 104 (primary -> atomic .)
    CLASS           reduce using rule 104 (primary -> atomic .)
    FOR             reduce using rule 104 (primary -> atomic .)
    WHILE           reduce using rule 104 (primary -> atomic .)
    PASS            reduce using rule 104 (primary -> atomic .)
    BREAK           reduce using rule 104 (primary -> atomic .)
    CONTINUE        reduce using rule 104 (primary -> atomic .)
    IDENTIFIER      reduce using rule 104 (primary -> atomic .)
    RETURN          reduce using rule 104 (primary -> atomic .)
    DEL             reduce using rule 104 (primary -> atomic .)
    GLOBAL          reduce using rule 104 (primary -> atomic .)
    TRUE            reduce using rule 104 (primary -> atomic .)
    FALSE           reduce using rule 104 (primary -> atomic .)
    NONE            reduce using rule 104 (primary -> atomic .)
    NUMBER          reduce using rule 104 (primary -> atomic .)
    F_NUMBER        reduce using rule 104 (primary -> atomic .)
    STRING          reduce using rule 104 (primary -> atomic .)
    TRIPLE_STRING   reduce using rule 104 (primary -> atomic .)
    ELIF            reduce using rule 104 (primary -> atomic .)
    ELSE            reduce using rule 104 (primary -> atomic .)
    DEDENT          reduce using rule 104 (primary -> atomic .)
    R_SQB           reduce using rule 104 (primary -> atomic .)
    R_PARENTHESIS   reduce using rule 104 (primary -> atomic .)


state 47

    (109) atomic -> TRUE .

    EXPONENTIATION  reduce using rule 109 (atomic -> TRUE .)
    L_PARENTHESIS   reduce using rule 109 (atomic -> TRUE .)
    L_SQB           reduce using rule 109 (atomic -> TRUE .)
    DOT             reduce using rule 109 (atomic -> TRUE .)
    STAR            reduce using rule 109 (atomic -> TRUE .)
    DIVISION        reduce using rule 109 (atomic -> TRUE .)
    INTEGER_DIVISION reduce using rule 109 (atomic -> TRUE .)
    MODULUS         reduce using rule 109 (atomic -> TRUE .)
    PLUS            reduce using rule 109 (atomic -> TRUE .)
    MINUS           reduce using rule 109 (atomic -> TRUE .)
    L_SHIFT         reduce using rule 109 (atomic -> TRUE .)
    R_SHIFT         reduce using rule 109 (atomic -> TRUE .)
    BITWISE_AND     reduce using rule 109 (atomic -> TRUE .)
    BITWISE_XOR     reduce using rule 109 (atomic -> TRUE .)
    BITWISE_OR      reduce using rule 109 (atomic -> TRUE .)
    EQUALITY        reduce using rule 109 (atomic -> TRUE .)
    INEQUALITY      reduce using rule 109 (atomic -> TRUE .)
    GREATER_EQUAL   reduce using rule 109 (atomic -> TRUE .)
    LESSER_EQUAL    reduce using rule 109 (atomic -> TRUE .)
    GREATER         reduce using rule 109 (atomic -> TRUE .)
    LESSER          reduce using rule 109 (atomic -> TRUE .)
    NOT             reduce using rule 109 (atomic -> TRUE .)
    IS              reduce using rule 109 (atomic -> TRUE .)
    IN              reduce using rule 109 (atomic -> TRUE .)
    AND             reduce using rule 109 (atomic -> TRUE .)
    OR              reduce using rule 109 (atomic -> TRUE .)
    IF              reduce using rule 109 (atomic -> TRUE .)
    COMMA           reduce using rule 109 (atomic -> TRUE .)
    NEWLINE         reduce using rule 109 (atomic -> TRUE .)
    COLON           reduce using rule 109 (atomic -> TRUE .)
    SEMICOLON       reduce using rule 109 (atomic -> TRUE .)
    ENDMARKER       reduce using rule 109 (atomic -> TRUE .)
    DEF             reduce using rule 109 (atomic -> TRUE .)
    CLASS           reduce using rule 109 (atomic -> TRUE .)
    FOR             reduce using rule 109 (atomic -> TRUE .)
    WHILE           reduce using rule 109 (atomic -> TRUE .)
    PASS            reduce using rule 109 (atomic -> TRUE .)
    BREAK           reduce using rule 109 (atomic -> TRUE .)
    CONTINUE        reduce using rule 109 (atomic -> TRUE .)
    IDENTIFIER      reduce using rule 109 (atomic -> TRUE .)
    RETURN          reduce using rule 109 (atomic -> TRUE .)
    DEL             reduce using rule 109 (atomic -> TRUE .)
    GLOBAL          reduce using rule 109 (atomic -> TRUE .)
    TRUE            reduce using rule 109 (atomic -> TRUE .)
    FALSE           reduce using rule 109 (atomic -> TRUE .)
    NONE            reduce using rule 109 (atomic -> TRUE .)
    NUMBER          reduce using rule 109 (atomic -> TRUE .)
    F_NUMBER        reduce using rule 109 (atomic -> TRUE .)
    STRING          reduce using rule 109 (atomic -> TRUE .)
    TRIPLE_STRING   reduce using rule 109 (atomic -> TRUE .)
    ELIF            reduce using rule 109 (atomic -> TRUE .)
    ELSE            reduce using rule 109 (atomic -> TRUE .)
    DEDENT          reduce using rule 109 (atomic -> TRUE .)
    R_SQB           reduce using rule 109 (atomic -> TRUE .)
    R_PARENTHESIS   reduce using rule 109 (atomic -> TRUE .)


state 48

    (110) atomic -> FALSE .

    EXPONENTIATION  reduce using rule 110 (atomic -> FALSE .)
    L_PARENTHESIS   reduce using rule 110 (atomic -> FALSE .)
    L_SQB           reduce using rule 110 (atomic -> FALSE .)
    DOT             reduce using rule 110 (atomic -> FALSE .)
    STAR            reduce using rule 110 (atomic -> FALSE .)
    DIVISION        reduce using rule 110 (atomic -> FALSE .)
    INTEGER_DIVISION reduce using rule 110 (atomic -> FALSE .)
    MODULUS         reduce using rule 110 (atomic -> FALSE .)
    PLUS            reduce using rule 110 (atomic -> FALSE .)
    MINUS           reduce using rule 110 (atomic -> FALSE .)
    L_SHIFT         reduce using rule 110 (atomic -> FALSE .)
    R_SHIFT         reduce using rule 110 (atomic -> FALSE .)
    BITWISE_AND     reduce using rule 110 (atomic -> FALSE .)
    BITWISE_XOR     reduce using rule 110 (atomic -> FALSE .)
    BITWISE_OR      reduce using rule 110 (atomic -> FALSE .)
    EQUALITY        reduce using rule 110 (atomic -> FALSE .)
    INEQUALITY      reduce using rule 110 (atomic -> FALSE .)
    GREATER_EQUAL   reduce using rule 110 (atomic -> FALSE .)
    LESSER_EQUAL    reduce using rule 110 (atomic -> FALSE .)
    GREATER         reduce using rule 110 (atomic -> FALSE .)
    LESSER          reduce using rule 110 (atomic -> FALSE .)
    NOT             reduce using rule 110 (atomic -> FALSE .)
    IS              reduce using rule 110 (atomic -> FALSE .)
    IN              reduce using rule 110 (atomic -> FALSE .)
    AND             reduce using rule 110 (atomic -> FALSE .)
    OR              reduce using rule 110 (atomic -> FALSE .)
    IF              reduce using rule 110 (atomic -> FALSE .)
    COMMA           reduce using rule 110 (atomic -> FALSE .)
    NEWLINE         reduce using rule 110 (atomic -> FALSE .)
    COLON           reduce using rule 110 (atomic -> FALSE .)
    SEMICOLON       reduce using rule 110 (atomic -> FALSE .)
    ENDMARKER       reduce using rule 110 (atomic -> FALSE .)
    DEF             reduce using rule 110 (atomic -> FALSE .)
    CLASS           reduce using rule 110 (atomic -> FALSE .)
    FOR             reduce using rule 110 (atomic -> FALSE .)
    WHILE           reduce using rule 110 (atomic -> FALSE .)
    PASS            reduce using rule 110 (atomic -> FALSE .)
    BREAK           reduce using rule 110 (atomic -> FALSE .)
    CONTINUE        reduce using rule 110 (atomic -> FALSE .)
    IDENTIFIER      reduce using rule 110 (atomic -> FALSE .)
    RETURN          reduce using rule 110 (atomic -> FALSE .)
    DEL             reduce using rule 110 (atomic -> FALSE .)
    GLOBAL          reduce using rule 110 (atomic -> FALSE .)
    TRUE            reduce using rule 110 (atomic -> FALSE .)
    FALSE           reduce using rule 110 (atomic -> FALSE .)
    NONE            reduce using rule 110 (atomic -> FALSE .)
    NUMBER          reduce using rule 110 (atomic -> FALSE .)
    F_NUMBER        reduce using rule 110 (atomic -> FALSE .)
    STRING          reduce using rule 110 (atomic -> FALSE .)
    TRIPLE_STRING   reduce using rule 110 (atomic -> FALSE .)
    ELIF            reduce using rule 110 (atomic -> FALSE .)
    ELSE            reduce using rule 110 (atomic -> FALSE .)
    DEDENT          reduce using rule 110 (atomic -> FALSE .)
    R_SQB           reduce using rule 110 (atomic -> FALSE .)
    R_PARENTHESIS   reduce using rule 110 (atomic -> FALSE .)


state 49

    (111) atomic -> NONE .

    EXPONENTIATION  reduce using rule 111 (atomic -> NONE .)
    L_PARENTHESIS   reduce using rule 111 (atomic -> NONE .)
    L_SQB           reduce using rule 111 (atomic -> NONE .)
    DOT             reduce using rule 111 (atomic -> NONE .)
    STAR            reduce using rule 111 (atomic -> NONE .)
    DIVISION        reduce using rule 111 (atomic -> NONE .)
    INTEGER_DIVISION reduce using rule 111 (atomic -> NONE .)
    MODULUS         reduce using rule 111 (atomic -> NONE .)
    PLUS            reduce using rule 111 (atomic -> NONE .)
    MINUS           reduce using rule 111 (atomic -> NONE .)
    L_SHIFT         reduce using rule 111 (atomic -> NONE .)
    R_SHIFT         reduce using rule 111 (atomic -> NONE .)
    BITWISE_AND     reduce using rule 111 (atomic -> NONE .)
    BITWISE_XOR     reduce using rule 111 (atomic -> NONE .)
    BITWISE_OR      reduce using rule 111 (atomic -> NONE .)
    EQUALITY        reduce using rule 111 (atomic -> NONE .)
    INEQUALITY      reduce using rule 111 (atomic -> NONE .)
    GREATER_EQUAL   reduce using rule 111 (atomic -> NONE .)
    LESSER_EQUAL    reduce using rule 111 (atomic -> NONE .)
    GREATER         reduce using rule 111 (atomic -> NONE .)
    LESSER          reduce using rule 111 (atomic -> NONE .)
    NOT             reduce using rule 111 (atomic -> NONE .)
    IS              reduce using rule 111 (atomic -> NONE .)
    IN              reduce using rule 111 (atomic -> NONE .)
    AND             reduce using rule 111 (atomic -> NONE .)
    OR              reduce using rule 111 (atomic -> NONE .)
    IF              reduce using rule 111 (atomic -> NONE .)
    COMMA           reduce using rule 111 (atomic -> NONE .)
    NEWLINE         reduce using rule 111 (atomic -> NONE .)
    COLON           reduce using rule 111 (atomic -> NONE .)
    SEMICOLON       reduce using rule 111 (atomic -> NONE .)
    ENDMARKER       reduce using rule 111 (atomic -> NONE .)
    DEF             reduce using rule 111 (atomic -> NONE .)
    CLASS           reduce using rule 111 (atomic -> NONE .)
    FOR             reduce using rule 111 (atomic -> NONE .)
    WHILE           reduce using rule 111 (atomic -> NONE .)
    PASS            reduce using rule 111 (atomic -> NONE .)
    BREAK           reduce using rule 111 (atomic -> NONE .)
    CONTINUE        reduce using rule 111 (atomic -> NONE .)
    IDENTIFIER      reduce using rule 111 (atomic -> NONE .)
    RETURN          reduce using rule 111 (atomic -> NONE .)
    DEL             reduce using rule 111 (atomic -> NONE .)
    GLOBAL          reduce using rule 111 (atomic -> NONE .)
    TRUE            reduce using rule 111 (atomic -> NONE .)
    FALSE           reduce using rule 111 (atomic -> NONE .)
    NONE            reduce using rule 111 (atomic -> NONE .)
    NUMBER          reduce using rule 111 (atomic -> NONE .)
    F_NUMBER        reduce using rule 111 (atomic -> NONE .)
    STRING          reduce using rule 111 (atomic -> NONE .)
    TRIPLE_STRING   reduce using rule 111 (atomic -> NONE .)
    ELIF            reduce using rule 111 (atomic -> NONE .)
    ELSE            reduce using rule 111 (atomic -> NONE .)
    DEDENT          reduce using rule 111 (atomic -> NONE .)
    R_SQB           reduce using rule 111 (atomic -> NONE .)
    R_PARENTHESIS   reduce using rule 111 (atomic -> NONE .)


state 50

    (112) atomic -> strings .

    EXPONENTIATION  reduce using rule 112 (atomic -> strings .)
    L_PARENTHESIS   reduce using rule 112 (atomic -> strings .)
    L_SQB           reduce using rule 112 (atomic -> strings .)
    DOT             reduce using rule 112 (atomic -> strings .)
    STAR            reduce using rule 112 (atomic -> strings .)
    DIVISION        reduce using rule 112 (atomic -> strings .)
    INTEGER_DIVISION reduce using rule 112 (atomic -> strings .)
    MODULUS         reduce using rule 112 (atomic -> strings .)
    PLUS            reduce using rule 112 (atomic -> strings .)
    MINUS           reduce using rule 112 (atomic -> strings .)
    L_SHIFT         reduce using rule 112 (atomic -> strings .)
    R_SHIFT         reduce using rule 112 (atomic -> strings .)
    BITWISE_AND     reduce using rule 112 (atomic -> strings .)
    BITWISE_XOR     reduce using rule 112 (atomic -> strings .)
    BITWISE_OR      reduce using rule 112 (atomic -> strings .)
    EQUALITY        reduce using rule 112 (atomic -> strings .)
    INEQUALITY      reduce using rule 112 (atomic -> strings .)
    GREATER_EQUAL   reduce using rule 112 (atomic -> strings .)
    LESSER_EQUAL    reduce using rule 112 (atomic -> strings .)
    GREATER         reduce using rule 112 (atomic -> strings .)
    LESSER          reduce using rule 112 (atomic -> strings .)
    NOT             reduce using rule 112 (atomic -> strings .)
    IS              reduce using rule 112 (atomic -> strings .)
    IN              reduce using rule 112 (atomic -> strings .)
    AND             reduce using rule 112 (atomic -> strings .)
    OR              reduce using rule 112 (atomic -> strings .)
    IF              reduce using rule 112 (atomic -> strings .)
    COMMA           reduce using rule 112 (atomic -> strings .)
    NEWLINE         reduce using rule 112 (atomic -> strings .)
    COLON           reduce using rule 112 (atomic -> strings .)
    SEMICOLON       reduce using rule 112 (atomic -> strings .)
    ENDMARKER       reduce using rule 112 (atomic -> strings .)
    DEF             reduce using rule 112 (atomic -> strings .)
    CLASS           reduce using rule 112 (atomic -> strings .)
    FOR             reduce using rule 112 (atomic -> strings .)
    WHILE           reduce using rule 112 (atomic -> strings .)
    PASS            reduce using rule 112 (atomic -> strings .)
    BREAK           reduce using rule 112 (atomic -> strings .)
    CONTINUE        reduce using rule 112 (atomic -> strings .)
    IDENTIFIER      reduce using rule 112 (atomic -> strings .)
    RETURN          reduce using rule 112 (atomic -> strings .)
    DEL             reduce using rule 112 (atomic -> strings .)
    GLOBAL          reduce using rule 112 (atomic -> strings .)
    TRUE            reduce using rule 112 (atomic -> strings .)
    FALSE           reduce using rule 112 (atomic -> strings .)
    NONE            reduce using rule 112 (atomic -> strings .)
    NUMBER          reduce using rule 112 (atomic -> strings .)
    F_NUMBER        reduce using rule 112 (atomic -> strings .)
    STRING          reduce using rule 112 (atomic -> strings .)
    TRIPLE_STRING   reduce using rule 112 (atomic -> strings .)
    ELIF            reduce using rule 112 (atomic -> strings .)
    ELSE            reduce using rule 112 (atomic -> strings .)
    DEDENT          reduce using rule 112 (atomic -> strings .)
    R_SQB           reduce using rule 112 (atomic -> strings .)
    R_PARENTHESIS   reduce using rule 112 (atomic -> strings .)


state 51

    (113) atomic -> NUMBER .

    EXPONENTIATION  reduce using rule 113 (atomic -> NUMBER .)
    L_PARENTHESIS   reduce using rule 113 (atomic -> NUMBER .)
    L_SQB           reduce using rule 113 (atomic -> NUMBER .)
    DOT             reduce using rule 113 (atomic -> NUMBER .)
    STAR            reduce using rule 113 (atomic -> NUMBER .)
    DIVISION        reduce using rule 113 (atomic -> NUMBER .)
    INTEGER_DIVISION reduce using rule 113 (atomic -> NUMBER .)
    MODULUS         reduce using rule 113 (atomic -> NUMBER .)
    PLUS            reduce using rule 113 (atomic -> NUMBER .)
    MINUS           reduce using rule 113 (atomic -> NUMBER .)
    L_SHIFT         reduce using rule 113 (atomic -> NUMBER .)
    R_SHIFT         reduce using rule 113 (atomic -> NUMBER .)
    BITWISE_AND     reduce using rule 113 (atomic -> NUMBER .)
    BITWISE_XOR     reduce using rule 113 (atomic -> NUMBER .)
    BITWISE_OR      reduce using rule 113 (atomic -> NUMBER .)
    EQUALITY        reduce using rule 113 (atomic -> NUMBER .)
    INEQUALITY      reduce using rule 113 (atomic -> NUMBER .)
    GREATER_EQUAL   reduce using rule 113 (atomic -> NUMBER .)
    LESSER_EQUAL    reduce using rule 113 (atomic -> NUMBER .)
    GREATER         reduce using rule 113 (atomic -> NUMBER .)
    LESSER          reduce using rule 113 (atomic -> NUMBER .)
    NOT             reduce using rule 113 (atomic -> NUMBER .)
    IS              reduce using rule 113 (atomic -> NUMBER .)
    IN              reduce using rule 113 (atomic -> NUMBER .)
    AND             reduce using rule 113 (atomic -> NUMBER .)
    OR              reduce using rule 113 (atomic -> NUMBER .)
    IF              reduce using rule 113 (atomic -> NUMBER .)
    COMMA           reduce using rule 113 (atomic -> NUMBER .)
    NEWLINE         reduce using rule 113 (atomic -> NUMBER .)
    COLON           reduce using rule 113 (atomic -> NUMBER .)
    SEMICOLON       reduce using rule 113 (atomic -> NUMBER .)
    ENDMARKER       reduce using rule 113 (atomic -> NUMBER .)
    DEF             reduce using rule 113 (atomic -> NUMBER .)
    CLASS           reduce using rule 113 (atomic -> NUMBER .)
    FOR             reduce using rule 113 (atomic -> NUMBER .)
    WHILE           reduce using rule 113 (atomic -> NUMBER .)
    PASS            reduce using rule 113 (atomic -> NUMBER .)
    BREAK           reduce using rule 113 (atomic -> NUMBER .)
    CONTINUE        reduce using rule 113 (atomic -> NUMBER .)
    IDENTIFIER      reduce using rule 113 (atomic -> NUMBER .)
    RETURN          reduce using rule 113 (atomic -> NUMBER .)
    DEL             reduce using rule 113 (atomic -> NUMBER .)
    GLOBAL          reduce using rule 113 (atomic -> NUMBER .)
    TRUE            reduce using rule 113 (atomic -> NUMBER .)
    FALSE           reduce using rule 113 (atomic -> NUMBER .)
    NONE            reduce using rule 113 (atomic -> NUMBER .)
    NUMBER          reduce using rule 113 (atomic -> NUMBER .)
    F_NUMBER        reduce using rule 113 (atomic -> NUMBER .)
    STRING          reduce using rule 113 (atomic -> NUMBER .)
    TRIPLE_STRING   reduce using rule 113 (atomic -> NUMBER .)
    ELIF            reduce using rule 113 (atomic -> NUMBER .)
    ELSE            reduce using rule 113 (atomic -> NUMBER .)
    DEDENT          reduce using rule 113 (atomic -> NUMBER .)
    R_SQB           reduce using rule 113 (atomic -> NUMBER .)
    R_PARENTHESIS   reduce using rule 113 (atomic -> NUMBER .)


state 52

    (114) atomic -> F_NUMBER .

    EXPONENTIATION  reduce using rule 114 (atomic -> F_NUMBER .)
    L_PARENTHESIS   reduce using rule 114 (atomic -> F_NUMBER .)
    L_SQB           reduce using rule 114 (atomic -> F_NUMBER .)
    DOT             reduce using rule 114 (atomic -> F_NUMBER .)
    STAR            reduce using rule 114 (atomic -> F_NUMBER .)
    DIVISION        reduce using rule 114 (atomic -> F_NUMBER .)
    INTEGER_DIVISION reduce using rule 114 (atomic -> F_NUMBER .)
    MODULUS         reduce using rule 114 (atomic -> F_NUMBER .)
    PLUS            reduce using rule 114 (atomic -> F_NUMBER .)
    MINUS           reduce using rule 114 (atomic -> F_NUMBER .)
    L_SHIFT         reduce using rule 114 (atomic -> F_NUMBER .)
    R_SHIFT         reduce using rule 114 (atomic -> F_NUMBER .)
    BITWISE_AND     reduce using rule 114 (atomic -> F_NUMBER .)
    BITWISE_XOR     reduce using rule 114 (atomic -> F_NUMBER .)
    BITWISE_OR      reduce using rule 114 (atomic -> F_NUMBER .)
    EQUALITY        reduce using rule 114 (atomic -> F_NUMBER .)
    INEQUALITY      reduce using rule 114 (atomic -> F_NUMBER .)
    GREATER_EQUAL   reduce using rule 114 (atomic -> F_NUMBER .)
    LESSER_EQUAL    reduce using rule 114 (atomic -> F_NUMBER .)
    GREATER         reduce using rule 114 (atomic -> F_NUMBER .)
    LESSER          reduce using rule 114 (atomic -> F_NUMBER .)
    NOT             reduce using rule 114 (atomic -> F_NUMBER .)
    IS              reduce using rule 114 (atomic -> F_NUMBER .)
    IN              reduce using rule 114 (atomic -> F_NUMBER .)
    AND             reduce using rule 114 (atomic -> F_NUMBER .)
    OR              reduce using rule 114 (atomic -> F_NUMBER .)
    IF              reduce using rule 114 (atomic -> F_NUMBER .)
    COMMA           reduce using rule 114 (atomic -> F_NUMBER .)
    NEWLINE         reduce using rule 114 (atomic -> F_NUMBER .)
    COLON           reduce using rule 114 (atomic -> F_NUMBER .)
    SEMICOLON       reduce using rule 114 (atomic -> F_NUMBER .)
    ENDMARKER       reduce using rule 114 (atomic -> F_NUMBER .)
    DEF             reduce using rule 114 (atomic -> F_NUMBER .)
    CLASS           reduce using rule 114 (atomic -> F_NUMBER .)
    FOR             reduce using rule 114 (atomic -> F_NUMBER .)
    WHILE           reduce using rule 114 (atomic -> F_NUMBER .)
    PASS            reduce using rule 114 (atomic -> F_NUMBER .)
    BREAK           reduce using rule 114 (atomic -> F_NUMBER .)
    CONTINUE        reduce using rule 114 (atomic -> F_NUMBER .)
    IDENTIFIER      reduce using rule 114 (atomic -> F_NUMBER .)
    RETURN          reduce using rule 114 (atomic -> F_NUMBER .)
    DEL             reduce using rule 114 (atomic -> F_NUMBER .)
    GLOBAL          reduce using rule 114 (atomic -> F_NUMBER .)
    TRUE            reduce using rule 114 (atomic -> F_NUMBER .)
    FALSE           reduce using rule 114 (atomic -> F_NUMBER .)
    NONE            reduce using rule 114 (atomic -> F_NUMBER .)
    NUMBER          reduce using rule 114 (atomic -> F_NUMBER .)
    F_NUMBER        reduce using rule 114 (atomic -> F_NUMBER .)
    STRING          reduce using rule 114 (atomic -> F_NUMBER .)
    TRIPLE_STRING   reduce using rule 114 (atomic -> F_NUMBER .)
    ELIF            reduce using rule 114 (atomic -> F_NUMBER .)
    ELSE            reduce using rule 114 (atomic -> F_NUMBER .)
    DEDENT          reduce using rule 114 (atomic -> F_NUMBER .)
    R_SQB           reduce using rule 114 (atomic -> F_NUMBER .)
    R_PARENTHESIS   reduce using rule 114 (atomic -> F_NUMBER .)


state 53

    (116) strings -> STRING .

    EXPONENTIATION  reduce using rule 116 (strings -> STRING .)
    L_PARENTHESIS   reduce using rule 116 (strings -> STRING .)
    L_SQB           reduce using rule 116 (strings -> STRING .)
    DOT             reduce using rule 116 (strings -> STRING .)
    STAR            reduce using rule 116 (strings -> STRING .)
    DIVISION        reduce using rule 116 (strings -> STRING .)
    INTEGER_DIVISION reduce using rule 116 (strings -> STRING .)
    MODULUS         reduce using rule 116 (strings -> STRING .)
    PLUS            reduce using rule 116 (strings -> STRING .)
    MINUS           reduce using rule 116 (strings -> STRING .)
    L_SHIFT         reduce using rule 116 (strings -> STRING .)
    R_SHIFT         reduce using rule 116 (strings -> STRING .)
    BITWISE_AND     reduce using rule 116 (strings -> STRING .)
    BITWISE_XOR     reduce using rule 116 (strings -> STRING .)
    BITWISE_OR      reduce using rule 116 (strings -> STRING .)
    EQUALITY        reduce using rule 116 (strings -> STRING .)
    INEQUALITY      reduce using rule 116 (strings -> STRING .)
    GREATER_EQUAL   reduce using rule 116 (strings -> STRING .)
    LESSER_EQUAL    reduce using rule 116 (strings -> STRING .)
    GREATER         reduce using rule 116 (strings -> STRING .)
    LESSER          reduce using rule 116 (strings -> STRING .)
    NOT             reduce using rule 116 (strings -> STRING .)
    IS              reduce using rule 116 (strings -> STRING .)
    IN              reduce using rule 116 (strings -> STRING .)
    AND             reduce using rule 116 (strings -> STRING .)
    OR              reduce using rule 116 (strings -> STRING .)
    IF              reduce using rule 116 (strings -> STRING .)
    COMMA           reduce using rule 116 (strings -> STRING .)
    NEWLINE         reduce using rule 116 (strings -> STRING .)
    COLON           reduce using rule 116 (strings -> STRING .)
    SEMICOLON       reduce using rule 116 (strings -> STRING .)
    ENDMARKER       reduce using rule 116 (strings -> STRING .)
    DEF             reduce using rule 116 (strings -> STRING .)
    CLASS           reduce using rule 116 (strings -> STRING .)
    FOR             reduce using rule 116 (strings -> STRING .)
    WHILE           reduce using rule 116 (strings -> STRING .)
    PASS            reduce using rule 116 (strings -> STRING .)
    BREAK           reduce using rule 116 (strings -> STRING .)
    CONTINUE        reduce using rule 116 (strings -> STRING .)
    IDENTIFIER      reduce using rule 116 (strings -> STRING .)
    RETURN          reduce using rule 116 (strings -> STRING .)
    DEL             reduce using rule 116 (strings -> STRING .)
    GLOBAL          reduce using rule 116 (strings -> STRING .)
    TRUE            reduce using rule 116 (strings -> STRING .)
    FALSE           reduce using rule 116 (strings -> STRING .)
    NONE            reduce using rule 116 (strings -> STRING .)
    NUMBER          reduce using rule 116 (strings -> STRING .)
    F_NUMBER        reduce using rule 116 (strings -> STRING .)
    STRING          reduce using rule 116 (strings -> STRING .)
    TRIPLE_STRING   reduce using rule 116 (strings -> STRING .)
    ELIF            reduce using rule 116 (strings -> STRING .)
    ELSE            reduce using rule 116 (strings -> STRING .)
    DEDENT          reduce using rule 116 (strings -> STRING .)
    R_SQB           reduce using rule 116 (strings -> STRING .)
    R_PARENTHESIS   reduce using rule 116 (strings -> STRING .)


state 54

    (117) strings -> TRIPLE_STRING .

    EXPONENTIATION  reduce using rule 117 (strings -> TRIPLE_STRING .)
    L_PARENTHESIS   reduce using rule 117 (strings -> TRIPLE_STRING .)
    L_SQB           reduce using rule 117 (strings -> TRIPLE_STRING .)
    DOT             reduce using rule 117 (strings -> TRIPLE_STRING .)
    STAR            reduce using rule 117 (strings -> TRIPLE_STRING .)
    DIVISION        reduce using rule 117 (strings -> TRIPLE_STRING .)
    INTEGER_DIVISION reduce using rule 117 (strings -> TRIPLE_STRING .)
    MODULUS         reduce using rule 117 (strings -> TRIPLE_STRING .)
    PLUS            reduce using rule 117 (strings -> TRIPLE_STRING .)
    MINUS           reduce using rule 117 (strings -> TRIPLE_STRING .)
    L_SHIFT         reduce using rule 117 (strings -> TRIPLE_STRING .)
    R_SHIFT         reduce using rule 117 (strings -> TRIPLE_STRING .)
    BITWISE_AND     reduce using rule 117 (strings -> TRIPLE_STRING .)
    BITWISE_XOR     reduce using rule 117 (strings -> TRIPLE_STRING .)
    BITWISE_OR      reduce using rule 117 (strings -> TRIPLE_STRING .)
    EQUALITY        reduce using rule 117 (strings -> TRIPLE_STRING .)
    INEQUALITY      reduce using rule 117 (strings -> TRIPLE_STRING .)
    GREATER_EQUAL   reduce using rule 117 (strings -> TRIPLE_STRING .)
    LESSER_EQUAL    reduce using rule 117 (strings -> TRIPLE_STRING .)
    GREATER         reduce using rule 117 (strings -> TRIPLE_STRING .)
    LESSER          reduce using rule 117 (strings -> TRIPLE_STRING .)
    NOT             reduce using rule 117 (strings -> TRIPLE_STRING .)
    IS              reduce using rule 117 (strings -> TRIPLE_STRING .)
    IN              reduce using rule 117 (strings -> TRIPLE_STRING .)
    AND             reduce using rule 117 (strings -> TRIPLE_STRING .)
    OR              reduce using rule 117 (strings -> TRIPLE_STRING .)
    IF              reduce using rule 117 (strings -> TRIPLE_STRING .)
    COMMA           reduce using rule 117 (strings -> TRIPLE_STRING .)
    NEWLINE         reduce using rule 117 (strings -> TRIPLE_STRING .)
    COLON           reduce using rule 117 (strings -> TRIPLE_STRING .)
    SEMICOLON       reduce using rule 117 (strings -> TRIPLE_STRING .)
    ENDMARKER       reduce using rule 117 (strings -> TRIPLE_STRING .)
    DEF             reduce using rule 117 (strings -> TRIPLE_STRING .)
    CLASS           reduce using rule 117 (strings -> TRIPLE_STRING .)
    FOR             reduce using rule 117 (strings -> TRIPLE_STRING .)
    WHILE           reduce using rule 117 (strings -> TRIPLE_STRING .)
    PASS            reduce using rule 117 (strings -> TRIPLE_STRING .)
    BREAK           reduce using rule 117 (strings -> TRIPLE_STRING .)
    CONTINUE        reduce using rule 117 (strings -> TRIPLE_STRING .)
    IDENTIFIER      reduce using rule 117 (strings -> TRIPLE_STRING .)
    RETURN          reduce using rule 117 (strings -> TRIPLE_STRING .)
    DEL             reduce using rule 117 (strings -> TRIPLE_STRING .)
    GLOBAL          reduce using rule 117 (strings -> TRIPLE_STRING .)
    TRUE            reduce using rule 117 (strings -> TRIPLE_STRING .)
    FALSE           reduce using rule 117 (strings -> TRIPLE_STRING .)
    NONE            reduce using rule 117 (strings -> TRIPLE_STRING .)
    NUMBER          reduce using rule 117 (strings -> TRIPLE_STRING .)
    F_NUMBER        reduce using rule 117 (strings -> TRIPLE_STRING .)
    STRING          reduce using rule 117 (strings -> TRIPLE_STRING .)
    TRIPLE_STRING   reduce using rule 117 (strings -> TRIPLE_STRING .)
    ELIF            reduce using rule 117 (strings -> TRIPLE_STRING .)
    ELSE            reduce using rule 117 (strings -> TRIPLE_STRING .)
    DEDENT          reduce using rule 117 (strings -> TRIPLE_STRING .)
    R_SQB           reduce using rule 117 (strings -> TRIPLE_STRING .)
    R_PARENTHESIS   reduce using rule 117 (strings -> TRIPLE_STRING .)


state 55

    (1) file -> statements ENDMARKER .

    $end            reduce using rule 1 (file -> statements ENDMARKER .)


state 56

    (2) statements -> statements statement .

    ENDMARKER       reduce using rule 2 (statements -> statements statement .)
    DEF             reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    CLASS           reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    WHILE           reduce using rule 2 (statements -> statements statement .)
    PASS            reduce using rule 2 (statements -> statements statement .)
    BREAK           reduce using rule 2 (statements -> statements statement .)
    CONTINUE        reduce using rule 2 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 2 (statements -> statements statement .)
    RETURN          reduce using rule 2 (statements -> statements statement .)
    DEL             reduce using rule 2 (statements -> statements statement .)
    GLOBAL          reduce using rule 2 (statements -> statements statement .)
    NOT             reduce using rule 2 (statements -> statements statement .)
    PLUS            reduce using rule 2 (statements -> statements statement .)
    MINUS           reduce using rule 2 (statements -> statements statement .)
    TRUE            reduce using rule 2 (statements -> statements statement .)
    FALSE           reduce using rule 2 (statements -> statements statement .)
    NONE            reduce using rule 2 (statements -> statements statement .)
    NUMBER          reduce using rule 2 (statements -> statements statement .)
    F_NUMBER        reduce using rule 2 (statements -> statements statement .)
    STRING          reduce using rule 2 (statements -> statements statement .)
    TRIPLE_STRING   reduce using rule 2 (statements -> statements statement .)
    DEDENT          reduce using rule 2 (statements -> statements statement .)


state 57

    (6) simple_stmts -> simple_stmts SEMICOLON . simple_stmt
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    simple_stmt                    shift and go to state 113
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 58

    (7) simple_stmts -> simple_stmt NEWLINE .

    SEMICOLON       reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ENDMARKER       reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEF             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    IF              reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    CLASS           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    FOR             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    WHILE           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    PASS            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    BREAK           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    CONTINUE        reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    IDENTIFIER      reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    RETURN          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEL             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    GLOBAL          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    NOT             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    PLUS            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    MINUS           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    TRUE            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    FALSE           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    NONE            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    NUMBER          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    F_NUMBER        reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    STRING          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    TRIPLE_STRING   reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ELIF            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ELSE            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEDENT          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)


state 59

    (40) function_def -> DEF IDENTIFIER . L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (41) function_def -> DEF IDENTIFIER . L_PARENTHESIS R_PARENTHESIS COLON block

    L_PARENTHESIS   shift and go to state 114


state 60

    (21) assignment -> IDENTIFIER augmentation_assignment . expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expressions                    shift and go to state 115
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 61

    (22) augmentation_assignment -> ASSIGNMENT .

    NOT             reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    PLUS            reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    MINUS           reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    IDENTIFIER      reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    TRUE            reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    FALSE           reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    NONE            reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    NUMBER          reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    F_NUMBER        reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    STRING          reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 22 (augmentation_assignment -> ASSIGNMENT .)


state 62

    (23) augmentation_assignment -> SUM_ASSIGNMENT .

    NOT             reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    PLUS            reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    MINUS           reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    TRUE            reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    FALSE           reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    NONE            reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    NUMBER          reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    F_NUMBER        reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    STRING          reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 23 (augmentation_assignment -> SUM_ASSIGNMENT .)


state 63

    (24) augmentation_assignment -> SUBTRACTION_ASSIGNMENT .

    NOT             reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    PLUS            reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    MINUS           reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    TRUE            reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    FALSE           reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    NONE            reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    NUMBER          reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    STRING          reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 24 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)


state 64

    (25) augmentation_assignment -> PRODUCT_ASSIGNMENT .

    NOT             reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    PLUS            reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    MINUS           reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    TRUE            reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    FALSE           reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    NONE            reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    NUMBER          reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    F_NUMBER        reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    STRING          reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 25 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)


state 65

    (26) augmentation_assignment -> DIVISION_ASSIGNMENT .

    NOT             reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    PLUS            reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    MINUS           reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    TRUE            reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    FALSE           reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    NONE            reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    NUMBER          reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    STRING          reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 26 (augmentation_assignment -> DIVISION_ASSIGNMENT .)


state 66

    (27) augmentation_assignment -> MODULUS_ASSIGNMENT .

    NOT             reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    PLUS            reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    MINUS           reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    TRUE            reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    FALSE           reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    NONE            reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    NUMBER          reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    F_NUMBER        reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    STRING          reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 27 (augmentation_assignment -> MODULUS_ASSIGNMENT .)


state 67

    (28) augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .

    NOT             reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    PLUS            reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    MINUS           reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    TRUE            reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    FALSE           reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    NONE            reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    NUMBER          reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    STRING          reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 28 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)


state 68

    (29) augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .

    NOT             reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    PLUS            reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    MINUS           reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    IDENTIFIER      reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    TRUE            reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    FALSE           reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    NONE            reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    NUMBER          reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    F_NUMBER        reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    STRING          reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    TRIPLE_STRING   reduce using rule 29 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)


state 69

    (44) if_stmt -> IF expression . COLON block elif_stmt
    (45) if_stmt -> IF expression . COLON block else_block
    (46) if_stmt -> IF expression . COLON block

    COLON           shift and go to state 116


state 70

    (108) atomic -> IDENTIFIER .

    EXPONENTIATION  reduce using rule 108 (atomic -> IDENTIFIER .)
    L_PARENTHESIS   reduce using rule 108 (atomic -> IDENTIFIER .)
    L_SQB           reduce using rule 108 (atomic -> IDENTIFIER .)
    DOT             reduce using rule 108 (atomic -> IDENTIFIER .)
    STAR            reduce using rule 108 (atomic -> IDENTIFIER .)
    DIVISION        reduce using rule 108 (atomic -> IDENTIFIER .)
    INTEGER_DIVISION reduce using rule 108 (atomic -> IDENTIFIER .)
    MODULUS         reduce using rule 108 (atomic -> IDENTIFIER .)
    PLUS            reduce using rule 108 (atomic -> IDENTIFIER .)
    MINUS           reduce using rule 108 (atomic -> IDENTIFIER .)
    L_SHIFT         reduce using rule 108 (atomic -> IDENTIFIER .)
    R_SHIFT         reduce using rule 108 (atomic -> IDENTIFIER .)
    BITWISE_AND     reduce using rule 108 (atomic -> IDENTIFIER .)
    BITWISE_XOR     reduce using rule 108 (atomic -> IDENTIFIER .)
    BITWISE_OR      reduce using rule 108 (atomic -> IDENTIFIER .)
    EQUALITY        reduce using rule 108 (atomic -> IDENTIFIER .)
    INEQUALITY      reduce using rule 108 (atomic -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 108 (atomic -> IDENTIFIER .)
    LESSER_EQUAL    reduce using rule 108 (atomic -> IDENTIFIER .)
    GREATER         reduce using rule 108 (atomic -> IDENTIFIER .)
    LESSER          reduce using rule 108 (atomic -> IDENTIFIER .)
    NOT             reduce using rule 108 (atomic -> IDENTIFIER .)
    IS              reduce using rule 108 (atomic -> IDENTIFIER .)
    IN              reduce using rule 108 (atomic -> IDENTIFIER .)
    AND             reduce using rule 108 (atomic -> IDENTIFIER .)
    OR              reduce using rule 108 (atomic -> IDENTIFIER .)
    IF              reduce using rule 108 (atomic -> IDENTIFIER .)
    COLON           reduce using rule 108 (atomic -> IDENTIFIER .)
    COMMA           reduce using rule 108 (atomic -> IDENTIFIER .)
    NEWLINE         reduce using rule 108 (atomic -> IDENTIFIER .)
    SEMICOLON       reduce using rule 108 (atomic -> IDENTIFIER .)
    ENDMARKER       reduce using rule 108 (atomic -> IDENTIFIER .)
    DEF             reduce using rule 108 (atomic -> IDENTIFIER .)
    CLASS           reduce using rule 108 (atomic -> IDENTIFIER .)
    FOR             reduce using rule 108 (atomic -> IDENTIFIER .)
    WHILE           reduce using rule 108 (atomic -> IDENTIFIER .)
    PASS            reduce using rule 108 (atomic -> IDENTIFIER .)
    BREAK           reduce using rule 108 (atomic -> IDENTIFIER .)
    CONTINUE        reduce using rule 108 (atomic -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 108 (atomic -> IDENTIFIER .)
    RETURN          reduce using rule 108 (atomic -> IDENTIFIER .)
    DEL             reduce using rule 108 (atomic -> IDENTIFIER .)
    GLOBAL          reduce using rule 108 (atomic -> IDENTIFIER .)
    TRUE            reduce using rule 108 (atomic -> IDENTIFIER .)
    FALSE           reduce using rule 108 (atomic -> IDENTIFIER .)
    NONE            reduce using rule 108 (atomic -> IDENTIFIER .)
    NUMBER          reduce using rule 108 (atomic -> IDENTIFIER .)
    F_NUMBER        reduce using rule 108 (atomic -> IDENTIFIER .)
    STRING          reduce using rule 108 (atomic -> IDENTIFIER .)
    TRIPLE_STRING   reduce using rule 108 (atomic -> IDENTIFIER .)
    ELIF            reduce using rule 108 (atomic -> IDENTIFIER .)
    ELSE            reduce using rule 108 (atomic -> IDENTIFIER .)
    DEDENT          reduce using rule 108 (atomic -> IDENTIFIER .)
    R_SQB           reduce using rule 108 (atomic -> IDENTIFIER .)
    R_PARENTHESIS   reduce using rule 108 (atomic -> IDENTIFIER .)


state 71

    (37) class_def -> CLASS IDENTIFIER . L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (38) class_def -> CLASS IDENTIFIER . L_PARENTHESIS R_PARENTHESIS COLON block
    (39) class_def -> CLASS IDENTIFIER . COLON block

    L_PARENTHESIS   shift and go to state 117
    COLON           shift and go to state 118


state 72

    (53) for_stmt -> FOR targets . IN expressions COLON else_block
    (54) for_stmt -> FOR targets . IN expressions COLON block
    (118) targets -> targets . COMMA target

    IN              shift and go to state 119
    COMMA           shift and go to state 120


state 73

    (119) targets -> target .

    IN              reduce using rule 119 (targets -> target .)
    COMMA           reduce using rule 119 (targets -> target .)


state 74

    (120) target -> empty .

    IN              reduce using rule 120 (target -> empty .)
    COMMA           reduce using rule 120 (target -> empty .)
    STAR            reduce using rule 120 (target -> empty .)
    DIVISION        reduce using rule 120 (target -> empty .)
    INTEGER_DIVISION reduce using rule 120 (target -> empty .)
    MODULUS         reduce using rule 120 (target -> empty .)
    PLUS            reduce using rule 120 (target -> empty .)
    MINUS           reduce using rule 120 (target -> empty .)
    L_SHIFT         reduce using rule 120 (target -> empty .)
    R_SHIFT         reduce using rule 120 (target -> empty .)
    BITWISE_AND     reduce using rule 120 (target -> empty .)
    BITWISE_XOR     reduce using rule 120 (target -> empty .)
    BITWISE_OR      reduce using rule 120 (target -> empty .)
    EQUALITY        reduce using rule 120 (target -> empty .)
    INEQUALITY      reduce using rule 120 (target -> empty .)
    GREATER_EQUAL   reduce using rule 120 (target -> empty .)
    LESSER_EQUAL    reduce using rule 120 (target -> empty .)
    GREATER         reduce using rule 120 (target -> empty .)
    LESSER          reduce using rule 120 (target -> empty .)
    NOT             reduce using rule 120 (target -> empty .)
    IS              reduce using rule 120 (target -> empty .)
    AND             reduce using rule 120 (target -> empty .)
    OR              reduce using rule 120 (target -> empty .)
    IF              reduce using rule 120 (target -> empty .)
    NEWLINE         reduce using rule 120 (target -> empty .)
    COLON           reduce using rule 120 (target -> empty .)
    SEMICOLON       reduce using rule 120 (target -> empty .)
    ENDMARKER       reduce using rule 120 (target -> empty .)
    DEF             reduce using rule 120 (target -> empty .)
    CLASS           reduce using rule 120 (target -> empty .)
    FOR             reduce using rule 120 (target -> empty .)
    WHILE           reduce using rule 120 (target -> empty .)
    PASS            reduce using rule 120 (target -> empty .)
    BREAK           reduce using rule 120 (target -> empty .)
    CONTINUE        reduce using rule 120 (target -> empty .)
    IDENTIFIER      reduce using rule 120 (target -> empty .)
    RETURN          reduce using rule 120 (target -> empty .)
    DEL             reduce using rule 120 (target -> empty .)
    GLOBAL          reduce using rule 120 (target -> empty .)
    TRUE            reduce using rule 120 (target -> empty .)
    FALSE           reduce using rule 120 (target -> empty .)
    NONE            reduce using rule 120 (target -> empty .)
    NUMBER          reduce using rule 120 (target -> empty .)
    F_NUMBER        reduce using rule 120 (target -> empty .)
    STRING          reduce using rule 120 (target -> empty .)
    TRIPLE_STRING   reduce using rule 120 (target -> empty .)
    ELIF            reduce using rule 120 (target -> empty .)
    ELSE            reduce using rule 120 (target -> empty .)
    DEDENT          reduce using rule 120 (target -> empty .)
    R_SQB           reduce using rule 120 (target -> empty .)
    R_PARENTHESIS   reduce using rule 120 (target -> empty .)


state 75

    (55) expressions -> expressions COMMA . expression
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expression                     shift and go to state 121
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 76

    (51) while_stmt -> WHILE expression . COLON block else_block
    (52) while_stmt -> WHILE expression . COLON block

    COLON           shift and go to state 122


state 77

    (30) return_stmt -> RETURN expressions .
    (55) expressions -> expressions . COMMA expression

    NEWLINE         reduce using rule 30 (return_stmt -> RETURN expressions .)
    SEMICOLON       reduce using rule 30 (return_stmt -> RETURN expressions .)
    ENDMARKER       reduce using rule 30 (return_stmt -> RETURN expressions .)
    DEF             reduce using rule 30 (return_stmt -> RETURN expressions .)
    IF              reduce using rule 30 (return_stmt -> RETURN expressions .)
    CLASS           reduce using rule 30 (return_stmt -> RETURN expressions .)
    FOR             reduce using rule 30 (return_stmt -> RETURN expressions .)
    WHILE           reduce using rule 30 (return_stmt -> RETURN expressions .)
    PASS            reduce using rule 30 (return_stmt -> RETURN expressions .)
    BREAK           reduce using rule 30 (return_stmt -> RETURN expressions .)
    CONTINUE        reduce using rule 30 (return_stmt -> RETURN expressions .)
    IDENTIFIER      reduce using rule 30 (return_stmt -> RETURN expressions .)
    RETURN          reduce using rule 30 (return_stmt -> RETURN expressions .)
    DEL             reduce using rule 30 (return_stmt -> RETURN expressions .)
    GLOBAL          reduce using rule 30 (return_stmt -> RETURN expressions .)
    NOT             reduce using rule 30 (return_stmt -> RETURN expressions .)
    PLUS            reduce using rule 30 (return_stmt -> RETURN expressions .)
    MINUS           reduce using rule 30 (return_stmt -> RETURN expressions .)
    TRUE            reduce using rule 30 (return_stmt -> RETURN expressions .)
    FALSE           reduce using rule 30 (return_stmt -> RETURN expressions .)
    NONE            reduce using rule 30 (return_stmt -> RETURN expressions .)
    NUMBER          reduce using rule 30 (return_stmt -> RETURN expressions .)
    F_NUMBER        reduce using rule 30 (return_stmt -> RETURN expressions .)
    STRING          reduce using rule 30 (return_stmt -> RETURN expressions .)
    TRIPLE_STRING   reduce using rule 30 (return_stmt -> RETURN expressions .)
    ELIF            reduce using rule 30 (return_stmt -> RETURN expressions .)
    ELSE            reduce using rule 30 (return_stmt -> RETURN expressions .)
    DEDENT          reduce using rule 30 (return_stmt -> RETURN expressions .)
    COMMA           shift and go to state 75


state 78

    (32) del_stmt -> DEL namelist .
    (33) namelist -> namelist . COMMA IDENTIFIER

    NEWLINE         reduce using rule 32 (del_stmt -> DEL namelist .)
    SEMICOLON       reduce using rule 32 (del_stmt -> DEL namelist .)
    ENDMARKER       reduce using rule 32 (del_stmt -> DEL namelist .)
    DEF             reduce using rule 32 (del_stmt -> DEL namelist .)
    IF              reduce using rule 32 (del_stmt -> DEL namelist .)
    CLASS           reduce using rule 32 (del_stmt -> DEL namelist .)
    FOR             reduce using rule 32 (del_stmt -> DEL namelist .)
    WHILE           reduce using rule 32 (del_stmt -> DEL namelist .)
    PASS            reduce using rule 32 (del_stmt -> DEL namelist .)
    BREAK           reduce using rule 32 (del_stmt -> DEL namelist .)
    CONTINUE        reduce using rule 32 (del_stmt -> DEL namelist .)
    IDENTIFIER      reduce using rule 32 (del_stmt -> DEL namelist .)
    RETURN          reduce using rule 32 (del_stmt -> DEL namelist .)
    DEL             reduce using rule 32 (del_stmt -> DEL namelist .)
    GLOBAL          reduce using rule 32 (del_stmt -> DEL namelist .)
    NOT             reduce using rule 32 (del_stmt -> DEL namelist .)
    PLUS            reduce using rule 32 (del_stmt -> DEL namelist .)
    MINUS           reduce using rule 32 (del_stmt -> DEL namelist .)
    TRUE            reduce using rule 32 (del_stmt -> DEL namelist .)
    FALSE           reduce using rule 32 (del_stmt -> DEL namelist .)
    NONE            reduce using rule 32 (del_stmt -> DEL namelist .)
    NUMBER          reduce using rule 32 (del_stmt -> DEL namelist .)
    F_NUMBER        reduce using rule 32 (del_stmt -> DEL namelist .)
    STRING          reduce using rule 32 (del_stmt -> DEL namelist .)
    TRIPLE_STRING   reduce using rule 32 (del_stmt -> DEL namelist .)
    ELIF            reduce using rule 32 (del_stmt -> DEL namelist .)
    ELSE            reduce using rule 32 (del_stmt -> DEL namelist .)
    DEDENT          reduce using rule 32 (del_stmt -> DEL namelist .)
    COMMA           shift and go to state 123


state 79

    (34) namelist -> IDENTIFIER .

    COMMA           reduce using rule 34 (namelist -> IDENTIFIER .)
    NEWLINE         reduce using rule 34 (namelist -> IDENTIFIER .)
    SEMICOLON       reduce using rule 34 (namelist -> IDENTIFIER .)
    ENDMARKER       reduce using rule 34 (namelist -> IDENTIFIER .)
    DEF             reduce using rule 34 (namelist -> IDENTIFIER .)
    IF              reduce using rule 34 (namelist -> IDENTIFIER .)
    CLASS           reduce using rule 34 (namelist -> IDENTIFIER .)
    FOR             reduce using rule 34 (namelist -> IDENTIFIER .)
    WHILE           reduce using rule 34 (namelist -> IDENTIFIER .)
    PASS            reduce using rule 34 (namelist -> IDENTIFIER .)
    BREAK           reduce using rule 34 (namelist -> IDENTIFIER .)
    CONTINUE        reduce using rule 34 (namelist -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 34 (namelist -> IDENTIFIER .)
    RETURN          reduce using rule 34 (namelist -> IDENTIFIER .)
    DEL             reduce using rule 34 (namelist -> IDENTIFIER .)
    GLOBAL          reduce using rule 34 (namelist -> IDENTIFIER .)
    NOT             reduce using rule 34 (namelist -> IDENTIFIER .)
    PLUS            reduce using rule 34 (namelist -> IDENTIFIER .)
    MINUS           reduce using rule 34 (namelist -> IDENTIFIER .)
    TRUE            reduce using rule 34 (namelist -> IDENTIFIER .)
    FALSE           reduce using rule 34 (namelist -> IDENTIFIER .)
    NONE            reduce using rule 34 (namelist -> IDENTIFIER .)
    NUMBER          reduce using rule 34 (namelist -> IDENTIFIER .)
    F_NUMBER        reduce using rule 34 (namelist -> IDENTIFIER .)
    STRING          reduce using rule 34 (namelist -> IDENTIFIER .)
    TRIPLE_STRING   reduce using rule 34 (namelist -> IDENTIFIER .)
    ELIF            reduce using rule 34 (namelist -> IDENTIFIER .)
    ELSE            reduce using rule 34 (namelist -> IDENTIFIER .)
    DEDENT          reduce using rule 34 (namelist -> IDENTIFIER .)


state 80

    (31) global_stmt -> GLOBAL namelist .
    (33) namelist -> namelist . COMMA IDENTIFIER

    NEWLINE         reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    SEMICOLON       reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    ENDMARKER       reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    DEF             reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    IF              reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    CLASS           reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    FOR             reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    WHILE           reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    PASS            reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    BREAK           reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    CONTINUE        reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    IDENTIFIER      reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    RETURN          reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    DEL             reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    GLOBAL          reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    NOT             reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    PLUS            reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    MINUS           reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    TRUE            reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    FALSE           reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    NONE            reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    NUMBER          reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    F_NUMBER        reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    STRING          reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    TRIPLE_STRING   reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    ELIF            reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    ELSE            reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    DEDENT          reduce using rule 31 (global_stmt -> GLOBAL namelist .)
    COMMA           shift and go to state 123


state 81

    (57) expression -> disjunction IF . disjunction ELSE expression
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    disjunction                    shift and go to state 124
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 82

    (59) disjunction -> conjunction OR . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    conjunction                    shift and go to state 31
    disjunction                    shift and go to state 125
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 83

    (61) conjunction -> inversion AND . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    inversion                      shift and go to state 126
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 84

    (63) inversion -> NOT inversion .

    AND             reduce using rule 63 (inversion -> NOT inversion .)
    OR              reduce using rule 63 (inversion -> NOT inversion .)
    IF              reduce using rule 63 (inversion -> NOT inversion .)
    COMMA           reduce using rule 63 (inversion -> NOT inversion .)
    NEWLINE         reduce using rule 63 (inversion -> NOT inversion .)
    COLON           reduce using rule 63 (inversion -> NOT inversion .)
    SEMICOLON       reduce using rule 63 (inversion -> NOT inversion .)
    ENDMARKER       reduce using rule 63 (inversion -> NOT inversion .)
    DEF             reduce using rule 63 (inversion -> NOT inversion .)
    CLASS           reduce using rule 63 (inversion -> NOT inversion .)
    FOR             reduce using rule 63 (inversion -> NOT inversion .)
    WHILE           reduce using rule 63 (inversion -> NOT inversion .)
    PASS            reduce using rule 63 (inversion -> NOT inversion .)
    BREAK           reduce using rule 63 (inversion -> NOT inversion .)
    CONTINUE        reduce using rule 63 (inversion -> NOT inversion .)
    IDENTIFIER      reduce using rule 63 (inversion -> NOT inversion .)
    RETURN          reduce using rule 63 (inversion -> NOT inversion .)
    DEL             reduce using rule 63 (inversion -> NOT inversion .)
    GLOBAL          reduce using rule 63 (inversion -> NOT inversion .)
    NOT             reduce using rule 63 (inversion -> NOT inversion .)
    PLUS            reduce using rule 63 (inversion -> NOT inversion .)
    MINUS           reduce using rule 63 (inversion -> NOT inversion .)
    TRUE            reduce using rule 63 (inversion -> NOT inversion .)
    FALSE           reduce using rule 63 (inversion -> NOT inversion .)
    NONE            reduce using rule 63 (inversion -> NOT inversion .)
    NUMBER          reduce using rule 63 (inversion -> NOT inversion .)
    F_NUMBER        reduce using rule 63 (inversion -> NOT inversion .)
    STRING          reduce using rule 63 (inversion -> NOT inversion .)
    TRIPLE_STRING   reduce using rule 63 (inversion -> NOT inversion .)
    ELIF            reduce using rule 63 (inversion -> NOT inversion .)
    ELSE            reduce using rule 63 (inversion -> NOT inversion .)
    DEDENT          reduce using rule 63 (inversion -> NOT inversion .)
    R_SQB           reduce using rule 63 (inversion -> NOT inversion .)
    R_PARENTHESIS   reduce using rule 63 (inversion -> NOT inversion .)


state 85

    (65) comparison -> bitwise_or compare_op_list .
    (67) compare_op_list -> compare_op_list . compare_op
    (69) compare_op -> . EQUALITY bitwise_or
    (70) compare_op -> . INEQUALITY bitwise_or
    (71) compare_op -> . GREATER_EQUAL bitwise_or
    (72) compare_op -> . LESSER_EQUAL bitwise_or
    (73) compare_op -> . GREATER bitwise_or
    (74) compare_op -> . LESSER bitwise_or
    (75) compare_op -> . NOT IN bitwise_or
    (76) compare_op -> . IS NOT bitwise_or
    (77) compare_op -> . IN bitwise_or
    (78) compare_op -> . IS bitwise_or

  ! shift/reduce conflict for NOT resolved as shift
    AND             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    OR              reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    IF              reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    COMMA           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    NEWLINE         reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    COLON           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    SEMICOLON       reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ENDMARKER       reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEF             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    CLASS           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    FOR             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    WHILE           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    PASS            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    BREAK           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    CONTINUE        reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    IDENTIFIER      reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    RETURN          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEL             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    GLOBAL          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    PLUS            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    MINUS           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    TRUE            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    FALSE           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    NONE            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    NUMBER          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    F_NUMBER        reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    STRING          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    TRIPLE_STRING   reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ELIF            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ELSE            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEDENT          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    R_SQB           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    R_PARENTHESIS   reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    EQUALITY        shift and go to state 88
    INEQUALITY      shift and go to state 89
    GREATER_EQUAL   shift and go to state 90
    LESSER_EQUAL    shift and go to state 91
    GREATER         shift and go to state 92
    LESSER          shift and go to state 93
    NOT             shift and go to state 94
    IS              shift and go to state 96
    IN              shift and go to state 95

  ! NOT             [ reduce using rule 65 (comparison -> bitwise_or compare_op_list .) ]

    compare_op                     shift and go to state 127

state 86

    (79) bitwise_or -> bitwise_or BITWISE_OR . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_xor                    shift and go to state 128
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 87

    (68) compare_op_list -> compare_op .

    EQUALITY        reduce using rule 68 (compare_op_list -> compare_op .)
    INEQUALITY      reduce using rule 68 (compare_op_list -> compare_op .)
    GREATER_EQUAL   reduce using rule 68 (compare_op_list -> compare_op .)
    LESSER_EQUAL    reduce using rule 68 (compare_op_list -> compare_op .)
    GREATER         reduce using rule 68 (compare_op_list -> compare_op .)
    LESSER          reduce using rule 68 (compare_op_list -> compare_op .)
    NOT             reduce using rule 68 (compare_op_list -> compare_op .)
    IS              reduce using rule 68 (compare_op_list -> compare_op .)
    IN              reduce using rule 68 (compare_op_list -> compare_op .)
    AND             reduce using rule 68 (compare_op_list -> compare_op .)
    OR              reduce using rule 68 (compare_op_list -> compare_op .)
    IF              reduce using rule 68 (compare_op_list -> compare_op .)
    COMMA           reduce using rule 68 (compare_op_list -> compare_op .)
    NEWLINE         reduce using rule 68 (compare_op_list -> compare_op .)
    COLON           reduce using rule 68 (compare_op_list -> compare_op .)
    SEMICOLON       reduce using rule 68 (compare_op_list -> compare_op .)
    ENDMARKER       reduce using rule 68 (compare_op_list -> compare_op .)
    DEF             reduce using rule 68 (compare_op_list -> compare_op .)
    CLASS           reduce using rule 68 (compare_op_list -> compare_op .)
    FOR             reduce using rule 68 (compare_op_list -> compare_op .)
    WHILE           reduce using rule 68 (compare_op_list -> compare_op .)
    PASS            reduce using rule 68 (compare_op_list -> compare_op .)
    BREAK           reduce using rule 68 (compare_op_list -> compare_op .)
    CONTINUE        reduce using rule 68 (compare_op_list -> compare_op .)
    IDENTIFIER      reduce using rule 68 (compare_op_list -> compare_op .)
    RETURN          reduce using rule 68 (compare_op_list -> compare_op .)
    DEL             reduce using rule 68 (compare_op_list -> compare_op .)
    GLOBAL          reduce using rule 68 (compare_op_list -> compare_op .)
    PLUS            reduce using rule 68 (compare_op_list -> compare_op .)
    MINUS           reduce using rule 68 (compare_op_list -> compare_op .)
    TRUE            reduce using rule 68 (compare_op_list -> compare_op .)
    FALSE           reduce using rule 68 (compare_op_list -> compare_op .)
    NONE            reduce using rule 68 (compare_op_list -> compare_op .)
    NUMBER          reduce using rule 68 (compare_op_list -> compare_op .)
    F_NUMBER        reduce using rule 68 (compare_op_list -> compare_op .)
    STRING          reduce using rule 68 (compare_op_list -> compare_op .)
    TRIPLE_STRING   reduce using rule 68 (compare_op_list -> compare_op .)
    ELIF            reduce using rule 68 (compare_op_list -> compare_op .)
    ELSE            reduce using rule 68 (compare_op_list -> compare_op .)
    DEDENT          reduce using rule 68 (compare_op_list -> compare_op .)
    R_SQB           reduce using rule 68 (compare_op_list -> compare_op .)
    R_PARENTHESIS   reduce using rule 68 (compare_op_list -> compare_op .)


state 88

    (69) compare_op -> EQUALITY . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 129
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 89

    (70) compare_op -> INEQUALITY . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 130
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 90

    (71) compare_op -> GREATER_EQUAL . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 131
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 91

    (72) compare_op -> LESSER_EQUAL . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 132
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 92

    (73) compare_op -> GREATER . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 133
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 93

    (74) compare_op -> LESSER . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 134
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 94

    (75) compare_op -> NOT . IN bitwise_or

    IN              shift and go to state 135


state 95

    (77) compare_op -> IN . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 136
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 96

    (76) compare_op -> IS . NOT bitwise_or
    (78) compare_op -> IS . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 137
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 138
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 97

    (81) bitwise_xor -> bitwise_xor BITWISE_XOR . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_and                    shift and go to state 139
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 98

    (83) bitwise_and -> bitwise_and BITWISE_AND . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    shift_expr                     shift and go to state 140
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 99

    (85) shift_expr -> shift_expr L_SHIFT . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    sum                            shift and go to state 141
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 100

    (86) shift_expr -> shift_expr R_SHIFT . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    sum                            shift and go to state 142
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 101

    (88) sum -> sum PLUS . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    term                           shift and go to state 143
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 102

    (89) sum -> sum MINUS . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    term                           shift and go to state 144
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 103

    (96) factor -> PLUS factor .

    STAR            reduce using rule 96 (factor -> PLUS factor .)
    DIVISION        reduce using rule 96 (factor -> PLUS factor .)
    INTEGER_DIVISION reduce using rule 96 (factor -> PLUS factor .)
    MODULUS         reduce using rule 96 (factor -> PLUS factor .)
    PLUS            reduce using rule 96 (factor -> PLUS factor .)
    MINUS           reduce using rule 96 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 96 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 96 (factor -> PLUS factor .)
    BITWISE_AND     reduce using rule 96 (factor -> PLUS factor .)
    BITWISE_XOR     reduce using rule 96 (factor -> PLUS factor .)
    BITWISE_OR      reduce using rule 96 (factor -> PLUS factor .)
    EQUALITY        reduce using rule 96 (factor -> PLUS factor .)
    INEQUALITY      reduce using rule 96 (factor -> PLUS factor .)
    GREATER_EQUAL   reduce using rule 96 (factor -> PLUS factor .)
    LESSER_EQUAL    reduce using rule 96 (factor -> PLUS factor .)
    GREATER         reduce using rule 96 (factor -> PLUS factor .)
    LESSER          reduce using rule 96 (factor -> PLUS factor .)
    NOT             reduce using rule 96 (factor -> PLUS factor .)
    IS              reduce using rule 96 (factor -> PLUS factor .)
    IN              reduce using rule 96 (factor -> PLUS factor .)
    AND             reduce using rule 96 (factor -> PLUS factor .)
    OR              reduce using rule 96 (factor -> PLUS factor .)
    IF              reduce using rule 96 (factor -> PLUS factor .)
    COMMA           reduce using rule 96 (factor -> PLUS factor .)
    NEWLINE         reduce using rule 96 (factor -> PLUS factor .)
    COLON           reduce using rule 96 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 96 (factor -> PLUS factor .)
    ENDMARKER       reduce using rule 96 (factor -> PLUS factor .)
    DEF             reduce using rule 96 (factor -> PLUS factor .)
    CLASS           reduce using rule 96 (factor -> PLUS factor .)
    FOR             reduce using rule 96 (factor -> PLUS factor .)
    WHILE           reduce using rule 96 (factor -> PLUS factor .)
    PASS            reduce using rule 96 (factor -> PLUS factor .)
    BREAK           reduce using rule 96 (factor -> PLUS factor .)
    CONTINUE        reduce using rule 96 (factor -> PLUS factor .)
    IDENTIFIER      reduce using rule 96 (factor -> PLUS factor .)
    RETURN          reduce using rule 96 (factor -> PLUS factor .)
    DEL             reduce using rule 96 (factor -> PLUS factor .)
    GLOBAL          reduce using rule 96 (factor -> PLUS factor .)
    TRUE            reduce using rule 96 (factor -> PLUS factor .)
    FALSE           reduce using rule 96 (factor -> PLUS factor .)
    NONE            reduce using rule 96 (factor -> PLUS factor .)
    NUMBER          reduce using rule 96 (factor -> PLUS factor .)
    F_NUMBER        reduce using rule 96 (factor -> PLUS factor .)
    STRING          reduce using rule 96 (factor -> PLUS factor .)
    TRIPLE_STRING   reduce using rule 96 (factor -> PLUS factor .)
    ELIF            reduce using rule 96 (factor -> PLUS factor .)
    ELSE            reduce using rule 96 (factor -> PLUS factor .)
    DEDENT          reduce using rule 96 (factor -> PLUS factor .)
    R_SQB           reduce using rule 96 (factor -> PLUS factor .)
    R_PARENTHESIS   reduce using rule 96 (factor -> PLUS factor .)


state 104

    (91) term -> term STAR . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    factor                         shift and go to state 145
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 105

    (92) term -> term DIVISION . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    factor                         shift and go to state 146
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 106

    (93) term -> term INTEGER_DIVISION . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    factor                         shift and go to state 147
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 107

    (94) term -> term MODULUS . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    factor                         shift and go to state 148
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 108

    (97) factor -> MINUS factor .

    STAR            reduce using rule 97 (factor -> MINUS factor .)
    DIVISION        reduce using rule 97 (factor -> MINUS factor .)
    INTEGER_DIVISION reduce using rule 97 (factor -> MINUS factor .)
    MODULUS         reduce using rule 97 (factor -> MINUS factor .)
    PLUS            reduce using rule 97 (factor -> MINUS factor .)
    MINUS           reduce using rule 97 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 97 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 97 (factor -> MINUS factor .)
    BITWISE_AND     reduce using rule 97 (factor -> MINUS factor .)
    BITWISE_XOR     reduce using rule 97 (factor -> MINUS factor .)
    BITWISE_OR      reduce using rule 97 (factor -> MINUS factor .)
    EQUALITY        reduce using rule 97 (factor -> MINUS factor .)
    INEQUALITY      reduce using rule 97 (factor -> MINUS factor .)
    GREATER_EQUAL   reduce using rule 97 (factor -> MINUS factor .)
    LESSER_EQUAL    reduce using rule 97 (factor -> MINUS factor .)
    GREATER         reduce using rule 97 (factor -> MINUS factor .)
    LESSER          reduce using rule 97 (factor -> MINUS factor .)
    NOT             reduce using rule 97 (factor -> MINUS factor .)
    IS              reduce using rule 97 (factor -> MINUS factor .)
    IN              reduce using rule 97 (factor -> MINUS factor .)
    AND             reduce using rule 97 (factor -> MINUS factor .)
    OR              reduce using rule 97 (factor -> MINUS factor .)
    IF              reduce using rule 97 (factor -> MINUS factor .)
    COMMA           reduce using rule 97 (factor -> MINUS factor .)
    NEWLINE         reduce using rule 97 (factor -> MINUS factor .)
    COLON           reduce using rule 97 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 97 (factor -> MINUS factor .)
    ENDMARKER       reduce using rule 97 (factor -> MINUS factor .)
    DEF             reduce using rule 97 (factor -> MINUS factor .)
    CLASS           reduce using rule 97 (factor -> MINUS factor .)
    FOR             reduce using rule 97 (factor -> MINUS factor .)
    WHILE           reduce using rule 97 (factor -> MINUS factor .)
    PASS            reduce using rule 97 (factor -> MINUS factor .)
    BREAK           reduce using rule 97 (factor -> MINUS factor .)
    CONTINUE        reduce using rule 97 (factor -> MINUS factor .)
    IDENTIFIER      reduce using rule 97 (factor -> MINUS factor .)
    RETURN          reduce using rule 97 (factor -> MINUS factor .)
    DEL             reduce using rule 97 (factor -> MINUS factor .)
    GLOBAL          reduce using rule 97 (factor -> MINUS factor .)
    TRUE            reduce using rule 97 (factor -> MINUS factor .)
    FALSE           reduce using rule 97 (factor -> MINUS factor .)
    NONE            reduce using rule 97 (factor -> MINUS factor .)
    NUMBER          reduce using rule 97 (factor -> MINUS factor .)
    F_NUMBER        reduce using rule 97 (factor -> MINUS factor .)
    STRING          reduce using rule 97 (factor -> MINUS factor .)
    TRIPLE_STRING   reduce using rule 97 (factor -> MINUS factor .)
    ELIF            reduce using rule 97 (factor -> MINUS factor .)
    ELSE            reduce using rule 97 (factor -> MINUS factor .)
    DEDENT          reduce using rule 97 (factor -> MINUS factor .)
    R_SQB           reduce using rule 97 (factor -> MINUS factor .)
    R_PARENTHESIS   reduce using rule 97 (factor -> MINUS factor .)


state 109

    (99) power -> primary EXPONENTIATION . target
    (120) target -> . empty
    (121) empty -> .

    STAR            reduce using rule 121 (empty -> .)
    DIVISION        reduce using rule 121 (empty -> .)
    INTEGER_DIVISION reduce using rule 121 (empty -> .)
    MODULUS         reduce using rule 121 (empty -> .)
    PLUS            reduce using rule 121 (empty -> .)
    MINUS           reduce using rule 121 (empty -> .)
    L_SHIFT         reduce using rule 121 (empty -> .)
    R_SHIFT         reduce using rule 121 (empty -> .)
    BITWISE_AND     reduce using rule 121 (empty -> .)
    BITWISE_XOR     reduce using rule 121 (empty -> .)
    BITWISE_OR      reduce using rule 121 (empty -> .)
    EQUALITY        reduce using rule 121 (empty -> .)
    INEQUALITY      reduce using rule 121 (empty -> .)
    GREATER_EQUAL   reduce using rule 121 (empty -> .)
    LESSER_EQUAL    reduce using rule 121 (empty -> .)
    GREATER         reduce using rule 121 (empty -> .)
    LESSER          reduce using rule 121 (empty -> .)
    NOT             reduce using rule 121 (empty -> .)
    IS              reduce using rule 121 (empty -> .)
    IN              reduce using rule 121 (empty -> .)
    AND             reduce using rule 121 (empty -> .)
    OR              reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)
    NEWLINE         reduce using rule 121 (empty -> .)
    COLON           reduce using rule 121 (empty -> .)
    SEMICOLON       reduce using rule 121 (empty -> .)
    ENDMARKER       reduce using rule 121 (empty -> .)
    DEF             reduce using rule 121 (empty -> .)
    CLASS           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    PASS            reduce using rule 121 (empty -> .)
    BREAK           reduce using rule 121 (empty -> .)
    CONTINUE        reduce using rule 121 (empty -> .)
    IDENTIFIER      reduce using rule 121 (empty -> .)
    RETURN          reduce using rule 121 (empty -> .)
    DEL             reduce using rule 121 (empty -> .)
    GLOBAL          reduce using rule 121 (empty -> .)
    TRUE            reduce using rule 121 (empty -> .)
    FALSE           reduce using rule 121 (empty -> .)
    NONE            reduce using rule 121 (empty -> .)
    NUMBER          reduce using rule 121 (empty -> .)
    F_NUMBER        reduce using rule 121 (empty -> .)
    STRING          reduce using rule 121 (empty -> .)
    TRIPLE_STRING   reduce using rule 121 (empty -> .)
    ELIF            reduce using rule 121 (empty -> .)
    ELSE            reduce using rule 121 (empty -> .)
    DEDENT          reduce using rule 121 (empty -> .)
    R_SQB           reduce using rule 121 (empty -> .)
    R_PARENTHESIS   reduce using rule 121 (empty -> .)

    target                         shift and go to state 149
    empty                          shift and go to state 74

state 110

    (101) primary -> primary L_PARENTHESIS . arguments R_PARENTHESIS
    (115) arguments -> . empty
    (121) empty -> .

    R_PARENTHESIS   reduce using rule 121 (empty -> .)

    arguments                      shift and go to state 150
    empty                          shift and go to state 151

state 111

    (102) primary -> primary L_SQB . slices R_SQB
    (105) slices -> . slices COMMA L_PARENTHESIS slice R_PARENTHESIS
    (106) slices -> . slice
    (107) slice -> . expression
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    primary                        shift and go to state 45
    slices                         shift and go to state 152
    slice                          shift and go to state 153
    expression                     shift and go to state 154
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 112

    (103) primary -> primary DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 155


state 113

    (6) simple_stmts -> simple_stmts SEMICOLON simple_stmt .

    SEMICOLON       reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ENDMARKER       reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEF             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    IF              reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    CLASS           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    FOR             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    WHILE           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    PASS            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    BREAK           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    CONTINUE        reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    IDENTIFIER      reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    RETURN          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEL             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    GLOBAL          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    NOT             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    PLUS            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    MINUS           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    TRUE            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    FALSE           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    NONE            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    NUMBER          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    F_NUMBER        reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    STRING          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    TRIPLE_STRING   reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ELIF            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ELSE            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEDENT          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)


state 114

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS . parameters R_PARENTHESIS COLON block
    (41) function_def -> DEF IDENTIFIER L_PARENTHESIS . R_PARENTHESIS COLON block
    (42) parameters -> . parameters COMMA IDENTIFIER
    (43) parameters -> . IDENTIFIER

    R_PARENTHESIS   shift and go to state 158
    IDENTIFIER      shift and go to state 156

    parameters                     shift and go to state 157

state 115

    (21) assignment -> IDENTIFIER augmentation_assignment expressions .
    (55) expressions -> expressions . COMMA expression

    NEWLINE         reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    SEMICOLON       reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ENDMARKER       reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEF             reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    IF              reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    CLASS           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    FOR             reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    WHILE           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    PASS            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    BREAK           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    CONTINUE        reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    IDENTIFIER      reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    RETURN          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEL             reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    GLOBAL          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    NOT             reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    PLUS            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    MINUS           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    TRUE            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    FALSE           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    NONE            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    NUMBER          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    F_NUMBER        reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    STRING          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    TRIPLE_STRING   reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ELIF            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ELSE            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEDENT          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    COMMA           shift and go to state 75


state 116

    (44) if_stmt -> IF expression COLON . block elif_stmt
    (45) if_stmt -> IF expression COLON . block else_block
    (46) if_stmt -> IF expression COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expression                     shift and go to state 15
    block                          shift and go to state 159
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 117

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS . arguments R_PARENTHESIS COLON block
    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS . R_PARENTHESIS COLON block
    (115) arguments -> . empty
    (121) empty -> .

  ! shift/reduce conflict for R_PARENTHESIS resolved as shift
    R_PARENTHESIS   shift and go to state 163

  ! R_PARENTHESIS   [ reduce using rule 121 (empty -> .) ]

    arguments                      shift and go to state 162
    empty                          shift and go to state 151

state 118

    (39) class_def -> CLASS IDENTIFIER COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    block                          shift and go to state 164
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 119

    (53) for_stmt -> FOR targets IN . expressions COLON else_block
    (54) for_stmt -> FOR targets IN . expressions COLON block
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expressions                    shift and go to state 165
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 120

    (118) targets -> targets COMMA . target
    (120) target -> . empty
    (121) empty -> .

    IN              reduce using rule 121 (empty -> .)
    COMMA           reduce using rule 121 (empty -> .)

    target                         shift and go to state 166
    empty                          shift and go to state 74

state 121

    (55) expressions -> expressions COMMA expression .

    COMMA           reduce using rule 55 (expressions -> expressions COMMA expression .)
    NEWLINE         reduce using rule 55 (expressions -> expressions COMMA expression .)
    SEMICOLON       reduce using rule 55 (expressions -> expressions COMMA expression .)
    ENDMARKER       reduce using rule 55 (expressions -> expressions COMMA expression .)
    DEF             reduce using rule 55 (expressions -> expressions COMMA expression .)
    IF              reduce using rule 55 (expressions -> expressions COMMA expression .)
    CLASS           reduce using rule 55 (expressions -> expressions COMMA expression .)
    FOR             reduce using rule 55 (expressions -> expressions COMMA expression .)
    WHILE           reduce using rule 55 (expressions -> expressions COMMA expression .)
    PASS            reduce using rule 55 (expressions -> expressions COMMA expression .)
    BREAK           reduce using rule 55 (expressions -> expressions COMMA expression .)
    CONTINUE        reduce using rule 55 (expressions -> expressions COMMA expression .)
    IDENTIFIER      reduce using rule 55 (expressions -> expressions COMMA expression .)
    RETURN          reduce using rule 55 (expressions -> expressions COMMA expression .)
    DEL             reduce using rule 55 (expressions -> expressions COMMA expression .)
    GLOBAL          reduce using rule 55 (expressions -> expressions COMMA expression .)
    NOT             reduce using rule 55 (expressions -> expressions COMMA expression .)
    PLUS            reduce using rule 55 (expressions -> expressions COMMA expression .)
    MINUS           reduce using rule 55 (expressions -> expressions COMMA expression .)
    TRUE            reduce using rule 55 (expressions -> expressions COMMA expression .)
    FALSE           reduce using rule 55 (expressions -> expressions COMMA expression .)
    NONE            reduce using rule 55 (expressions -> expressions COMMA expression .)
    NUMBER          reduce using rule 55 (expressions -> expressions COMMA expression .)
    F_NUMBER        reduce using rule 55 (expressions -> expressions COMMA expression .)
    STRING          reduce using rule 55 (expressions -> expressions COMMA expression .)
    TRIPLE_STRING   reduce using rule 55 (expressions -> expressions COMMA expression .)
    ELIF            reduce using rule 55 (expressions -> expressions COMMA expression .)
    ELSE            reduce using rule 55 (expressions -> expressions COMMA expression .)
    DEDENT          reduce using rule 55 (expressions -> expressions COMMA expression .)
    COLON           reduce using rule 55 (expressions -> expressions COMMA expression .)


state 122

    (51) while_stmt -> WHILE expression COLON . block else_block
    (52) while_stmt -> WHILE expression COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expression                     shift and go to state 15
    block                          shift and go to state 167
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 123

    (33) namelist -> namelist COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 168


state 124

    (57) expression -> disjunction IF disjunction . ELSE expression

    ELSE            shift and go to state 169


state 125

    (59) disjunction -> conjunction OR disjunction .

    IF              reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    COMMA           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    NEWLINE         reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    COLON           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    SEMICOLON       reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    ENDMARKER       reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    DEF             reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    CLASS           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    FOR             reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    WHILE           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    PASS            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    BREAK           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    CONTINUE        reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    IDENTIFIER      reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    RETURN          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    DEL             reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    GLOBAL          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    NOT             reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    PLUS            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    MINUS           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    TRUE            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    FALSE           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    NONE            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    NUMBER          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    F_NUMBER        reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    STRING          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    TRIPLE_STRING   reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    ELIF            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    ELSE            reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    DEDENT          reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    R_SQB           reduce using rule 59 (disjunction -> conjunction OR disjunction .)
    R_PARENTHESIS   reduce using rule 59 (disjunction -> conjunction OR disjunction .)


state 126

    (61) conjunction -> inversion AND inversion .

    OR              reduce using rule 61 (conjunction -> inversion AND inversion .)
    IF              reduce using rule 61 (conjunction -> inversion AND inversion .)
    COMMA           reduce using rule 61 (conjunction -> inversion AND inversion .)
    NEWLINE         reduce using rule 61 (conjunction -> inversion AND inversion .)
    COLON           reduce using rule 61 (conjunction -> inversion AND inversion .)
    SEMICOLON       reduce using rule 61 (conjunction -> inversion AND inversion .)
    ENDMARKER       reduce using rule 61 (conjunction -> inversion AND inversion .)
    DEF             reduce using rule 61 (conjunction -> inversion AND inversion .)
    CLASS           reduce using rule 61 (conjunction -> inversion AND inversion .)
    FOR             reduce using rule 61 (conjunction -> inversion AND inversion .)
    WHILE           reduce using rule 61 (conjunction -> inversion AND inversion .)
    PASS            reduce using rule 61 (conjunction -> inversion AND inversion .)
    BREAK           reduce using rule 61 (conjunction -> inversion AND inversion .)
    CONTINUE        reduce using rule 61 (conjunction -> inversion AND inversion .)
    IDENTIFIER      reduce using rule 61 (conjunction -> inversion AND inversion .)
    RETURN          reduce using rule 61 (conjunction -> inversion AND inversion .)
    DEL             reduce using rule 61 (conjunction -> inversion AND inversion .)
    GLOBAL          reduce using rule 61 (conjunction -> inversion AND inversion .)
    NOT             reduce using rule 61 (conjunction -> inversion AND inversion .)
    PLUS            reduce using rule 61 (conjunction -> inversion AND inversion .)
    MINUS           reduce using rule 61 (conjunction -> inversion AND inversion .)
    TRUE            reduce using rule 61 (conjunction -> inversion AND inversion .)
    FALSE           reduce using rule 61 (conjunction -> inversion AND inversion .)
    NONE            reduce using rule 61 (conjunction -> inversion AND inversion .)
    NUMBER          reduce using rule 61 (conjunction -> inversion AND inversion .)
    F_NUMBER        reduce using rule 61 (conjunction -> inversion AND inversion .)
    STRING          reduce using rule 61 (conjunction -> inversion AND inversion .)
    TRIPLE_STRING   reduce using rule 61 (conjunction -> inversion AND inversion .)
    ELIF            reduce using rule 61 (conjunction -> inversion AND inversion .)
    ELSE            reduce using rule 61 (conjunction -> inversion AND inversion .)
    DEDENT          reduce using rule 61 (conjunction -> inversion AND inversion .)
    R_SQB           reduce using rule 61 (conjunction -> inversion AND inversion .)
    R_PARENTHESIS   reduce using rule 61 (conjunction -> inversion AND inversion .)


state 127

    (67) compare_op_list -> compare_op_list compare_op .

    EQUALITY        reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    INEQUALITY      reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GREATER_EQUAL   reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    LESSER_EQUAL    reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GREATER         reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    LESSER          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NOT             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IS              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IN              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    AND             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    OR              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IF              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    COMMA           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NEWLINE         reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    COLON           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    SEMICOLON       reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ENDMARKER       reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEF             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    CLASS           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    FOR             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    WHILE           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    PASS            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    BREAK           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    CONTINUE        reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IDENTIFIER      reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    RETURN          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEL             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GLOBAL          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    PLUS            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    MINUS           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    TRUE            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    FALSE           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NONE            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NUMBER          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    F_NUMBER        reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    STRING          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    TRIPLE_STRING   reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ELIF            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ELSE            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEDENT          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    R_SQB           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    R_PARENTHESIS   reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)


state 128

    (79) bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .
    (81) bitwise_xor -> bitwise_xor . BITWISE_XOR bitwise_and

    BITWISE_OR      reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    EQUALITY        reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    INEQUALITY      reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GREATER_EQUAL   reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    LESSER_EQUAL    reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GREATER         reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    LESSER          reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NOT             reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IS              reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IN              reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    AND             reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    OR              reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IF              reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    COMMA           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NEWLINE         reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    COLON           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    SEMICOLON       reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ENDMARKER       reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEF             reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    CLASS           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    FOR             reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    WHILE           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    PASS            reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    BREAK           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    CONTINUE        reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IDENTIFIER      reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    RETURN          reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEL             reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GLOBAL          reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    PLUS            reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    MINUS           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    TRUE            reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    FALSE           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NONE            reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NUMBER          reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    F_NUMBER        reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    STRING          reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    TRIPLE_STRING   reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ELIF            reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ELSE            reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEDENT          reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    R_SQB           reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    R_PARENTHESIS   reduce using rule 79 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    BITWISE_XOR     shift and go to state 97


state 129

    (69) compare_op -> EQUALITY bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    INEQUALITY      reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    GREATER_EQUAL   reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    LESSER_EQUAL    reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    GREATER         reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    LESSER          reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    NOT             reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    IS              reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    IN              reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    AND             reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    OR              reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    IF              reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    COMMA           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    NEWLINE         reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    COLON           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    SEMICOLON       reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    ENDMARKER       reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    DEF             reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    CLASS           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    FOR             reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    WHILE           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    PASS            reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    BREAK           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    CONTINUE        reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    IDENTIFIER      reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    RETURN          reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    DEL             reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    GLOBAL          reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    PLUS            reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    MINUS           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    TRUE            reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    FALSE           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    NONE            reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    NUMBER          reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    F_NUMBER        reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    STRING          reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    TRIPLE_STRING   reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    ELIF            reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    ELSE            reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    DEDENT          reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    R_SQB           reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    R_PARENTHESIS   reduce using rule 69 (compare_op -> EQUALITY bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 130

    (70) compare_op -> INEQUALITY bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    INEQUALITY      reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    GREATER_EQUAL   reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    LESSER_EQUAL    reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    GREATER         reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    LESSER          reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    NOT             reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    IS              reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    IN              reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    AND             reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    OR              reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    IF              reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    COMMA           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    NEWLINE         reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    COLON           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    SEMICOLON       reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    ENDMARKER       reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    DEF             reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    CLASS           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    FOR             reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    WHILE           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    PASS            reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    BREAK           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    CONTINUE        reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    IDENTIFIER      reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    RETURN          reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    DEL             reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    GLOBAL          reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    PLUS            reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    MINUS           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    TRUE            reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    FALSE           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    NONE            reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    NUMBER          reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    F_NUMBER        reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    STRING          reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    TRIPLE_STRING   reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    ELIF            reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    ELSE            reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    DEDENT          reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    R_SQB           reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    R_PARENTHESIS   reduce using rule 70 (compare_op -> INEQUALITY bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 131

    (71) compare_op -> GREATER_EQUAL bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    INEQUALITY      reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    GREATER_EQUAL   reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    LESSER_EQUAL    reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    GREATER         reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    LESSER          reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    NOT             reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    IS              reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    IN              reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    AND             reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    OR              reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    IF              reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    COMMA           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    NEWLINE         reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    COLON           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    SEMICOLON       reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    ENDMARKER       reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEF             reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    CLASS           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    FOR             reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    WHILE           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    PASS            reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    BREAK           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    CONTINUE        reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    IDENTIFIER      reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    RETURN          reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEL             reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    GLOBAL          reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    PLUS            reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    MINUS           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    TRUE            reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    FALSE           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    NONE            reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    NUMBER          reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    F_NUMBER        reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    STRING          reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    TRIPLE_STRING   reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    ELIF            reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    ELSE            reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEDENT          reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    R_SQB           reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    R_PARENTHESIS   reduce using rule 71 (compare_op -> GREATER_EQUAL bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 132

    (72) compare_op -> LESSER_EQUAL bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    INEQUALITY      reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    GREATER_EQUAL   reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    LESSER_EQUAL    reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    GREATER         reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    LESSER          reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    NOT             reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    IS              reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    IN              reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    AND             reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    OR              reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    IF              reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    COMMA           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    NEWLINE         reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    COLON           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    SEMICOLON       reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    ENDMARKER       reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEF             reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    CLASS           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    FOR             reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    WHILE           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    PASS            reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    BREAK           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    CONTINUE        reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    IDENTIFIER      reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    RETURN          reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEL             reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    GLOBAL          reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    PLUS            reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    MINUS           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    TRUE            reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    FALSE           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    NONE            reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    NUMBER          reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    F_NUMBER        reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    STRING          reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    TRIPLE_STRING   reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    ELIF            reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    ELSE            reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEDENT          reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    R_SQB           reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    R_PARENTHESIS   reduce using rule 72 (compare_op -> LESSER_EQUAL bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 133

    (73) compare_op -> GREATER bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    INEQUALITY      reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    GREATER_EQUAL   reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    LESSER_EQUAL    reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    GREATER         reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    LESSER          reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    NOT             reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    IS              reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    IN              reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    AND             reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    OR              reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    IF              reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    COMMA           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    NEWLINE         reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    COLON           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    SEMICOLON       reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    ENDMARKER       reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    DEF             reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    CLASS           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    FOR             reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    WHILE           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    PASS            reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    BREAK           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    CONTINUE        reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    IDENTIFIER      reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    RETURN          reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    DEL             reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    GLOBAL          reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    PLUS            reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    MINUS           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    TRUE            reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    FALSE           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    NONE            reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    NUMBER          reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    F_NUMBER        reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    STRING          reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    TRIPLE_STRING   reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    ELIF            reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    ELSE            reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    DEDENT          reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    R_SQB           reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    R_PARENTHESIS   reduce using rule 73 (compare_op -> GREATER bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 134

    (74) compare_op -> LESSER bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    INEQUALITY      reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    GREATER_EQUAL   reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    LESSER_EQUAL    reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    GREATER         reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    LESSER          reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    NOT             reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    IS              reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    IN              reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    AND             reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    OR              reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    IF              reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    COMMA           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    NEWLINE         reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    COLON           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    SEMICOLON       reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    ENDMARKER       reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    DEF             reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    CLASS           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    FOR             reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    WHILE           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    PASS            reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    BREAK           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    CONTINUE        reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    IDENTIFIER      reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    RETURN          reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    DEL             reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    GLOBAL          reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    PLUS            reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    MINUS           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    TRUE            reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    FALSE           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    NONE            reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    NUMBER          reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    F_NUMBER        reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    STRING          reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    TRIPLE_STRING   reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    ELIF            reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    ELSE            reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    DEDENT          reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    R_SQB           reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    R_PARENTHESIS   reduce using rule 74 (compare_op -> LESSER bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 135

    (75) compare_op -> NOT IN . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 170
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 136

    (77) compare_op -> IN bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 77 (compare_op -> IN bitwise_or .)
    INEQUALITY      reduce using rule 77 (compare_op -> IN bitwise_or .)
    GREATER_EQUAL   reduce using rule 77 (compare_op -> IN bitwise_or .)
    LESSER_EQUAL    reduce using rule 77 (compare_op -> IN bitwise_or .)
    GREATER         reduce using rule 77 (compare_op -> IN bitwise_or .)
    LESSER          reduce using rule 77 (compare_op -> IN bitwise_or .)
    NOT             reduce using rule 77 (compare_op -> IN bitwise_or .)
    IS              reduce using rule 77 (compare_op -> IN bitwise_or .)
    IN              reduce using rule 77 (compare_op -> IN bitwise_or .)
    AND             reduce using rule 77 (compare_op -> IN bitwise_or .)
    OR              reduce using rule 77 (compare_op -> IN bitwise_or .)
    IF              reduce using rule 77 (compare_op -> IN bitwise_or .)
    COMMA           reduce using rule 77 (compare_op -> IN bitwise_or .)
    NEWLINE         reduce using rule 77 (compare_op -> IN bitwise_or .)
    COLON           reduce using rule 77 (compare_op -> IN bitwise_or .)
    SEMICOLON       reduce using rule 77 (compare_op -> IN bitwise_or .)
    ENDMARKER       reduce using rule 77 (compare_op -> IN bitwise_or .)
    DEF             reduce using rule 77 (compare_op -> IN bitwise_or .)
    CLASS           reduce using rule 77 (compare_op -> IN bitwise_or .)
    FOR             reduce using rule 77 (compare_op -> IN bitwise_or .)
    WHILE           reduce using rule 77 (compare_op -> IN bitwise_or .)
    PASS            reduce using rule 77 (compare_op -> IN bitwise_or .)
    BREAK           reduce using rule 77 (compare_op -> IN bitwise_or .)
    CONTINUE        reduce using rule 77 (compare_op -> IN bitwise_or .)
    IDENTIFIER      reduce using rule 77 (compare_op -> IN bitwise_or .)
    RETURN          reduce using rule 77 (compare_op -> IN bitwise_or .)
    DEL             reduce using rule 77 (compare_op -> IN bitwise_or .)
    GLOBAL          reduce using rule 77 (compare_op -> IN bitwise_or .)
    PLUS            reduce using rule 77 (compare_op -> IN bitwise_or .)
    MINUS           reduce using rule 77 (compare_op -> IN bitwise_or .)
    TRUE            reduce using rule 77 (compare_op -> IN bitwise_or .)
    FALSE           reduce using rule 77 (compare_op -> IN bitwise_or .)
    NONE            reduce using rule 77 (compare_op -> IN bitwise_or .)
    NUMBER          reduce using rule 77 (compare_op -> IN bitwise_or .)
    F_NUMBER        reduce using rule 77 (compare_op -> IN bitwise_or .)
    STRING          reduce using rule 77 (compare_op -> IN bitwise_or .)
    TRIPLE_STRING   reduce using rule 77 (compare_op -> IN bitwise_or .)
    ELIF            reduce using rule 77 (compare_op -> IN bitwise_or .)
    ELSE            reduce using rule 77 (compare_op -> IN bitwise_or .)
    DEDENT          reduce using rule 77 (compare_op -> IN bitwise_or .)
    R_SQB           reduce using rule 77 (compare_op -> IN bitwise_or .)
    R_PARENTHESIS   reduce using rule 77 (compare_op -> IN bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 137

    (76) compare_op -> IS NOT . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    bitwise_or                     shift and go to state 171
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 138

    (78) compare_op -> IS bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 78 (compare_op -> IS bitwise_or .)
    INEQUALITY      reduce using rule 78 (compare_op -> IS bitwise_or .)
    GREATER_EQUAL   reduce using rule 78 (compare_op -> IS bitwise_or .)
    LESSER_EQUAL    reduce using rule 78 (compare_op -> IS bitwise_or .)
    GREATER         reduce using rule 78 (compare_op -> IS bitwise_or .)
    LESSER          reduce using rule 78 (compare_op -> IS bitwise_or .)
    NOT             reduce using rule 78 (compare_op -> IS bitwise_or .)
    IS              reduce using rule 78 (compare_op -> IS bitwise_or .)
    IN              reduce using rule 78 (compare_op -> IS bitwise_or .)
    AND             reduce using rule 78 (compare_op -> IS bitwise_or .)
    OR              reduce using rule 78 (compare_op -> IS bitwise_or .)
    IF              reduce using rule 78 (compare_op -> IS bitwise_or .)
    COMMA           reduce using rule 78 (compare_op -> IS bitwise_or .)
    NEWLINE         reduce using rule 78 (compare_op -> IS bitwise_or .)
    COLON           reduce using rule 78 (compare_op -> IS bitwise_or .)
    SEMICOLON       reduce using rule 78 (compare_op -> IS bitwise_or .)
    ENDMARKER       reduce using rule 78 (compare_op -> IS bitwise_or .)
    DEF             reduce using rule 78 (compare_op -> IS bitwise_or .)
    CLASS           reduce using rule 78 (compare_op -> IS bitwise_or .)
    FOR             reduce using rule 78 (compare_op -> IS bitwise_or .)
    WHILE           reduce using rule 78 (compare_op -> IS bitwise_or .)
    PASS            reduce using rule 78 (compare_op -> IS bitwise_or .)
    BREAK           reduce using rule 78 (compare_op -> IS bitwise_or .)
    CONTINUE        reduce using rule 78 (compare_op -> IS bitwise_or .)
    IDENTIFIER      reduce using rule 78 (compare_op -> IS bitwise_or .)
    RETURN          reduce using rule 78 (compare_op -> IS bitwise_or .)
    DEL             reduce using rule 78 (compare_op -> IS bitwise_or .)
    GLOBAL          reduce using rule 78 (compare_op -> IS bitwise_or .)
    PLUS            reduce using rule 78 (compare_op -> IS bitwise_or .)
    MINUS           reduce using rule 78 (compare_op -> IS bitwise_or .)
    TRUE            reduce using rule 78 (compare_op -> IS bitwise_or .)
    FALSE           reduce using rule 78 (compare_op -> IS bitwise_or .)
    NONE            reduce using rule 78 (compare_op -> IS bitwise_or .)
    NUMBER          reduce using rule 78 (compare_op -> IS bitwise_or .)
    F_NUMBER        reduce using rule 78 (compare_op -> IS bitwise_or .)
    STRING          reduce using rule 78 (compare_op -> IS bitwise_or .)
    TRIPLE_STRING   reduce using rule 78 (compare_op -> IS bitwise_or .)
    ELIF            reduce using rule 78 (compare_op -> IS bitwise_or .)
    ELSE            reduce using rule 78 (compare_op -> IS bitwise_or .)
    DEDENT          reduce using rule 78 (compare_op -> IS bitwise_or .)
    R_SQB           reduce using rule 78 (compare_op -> IS bitwise_or .)
    R_PARENTHESIS   reduce using rule 78 (compare_op -> IS bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 139

    (81) bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .
    (83) bitwise_and -> bitwise_and . BITWISE_AND shift_expr

    BITWISE_XOR     reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    BITWISE_OR      reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    EQUALITY        reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    INEQUALITY      reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    GREATER_EQUAL   reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    LESSER_EQUAL    reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    GREATER         reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    LESSER          reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    NOT             reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IS              reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IN              reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    AND             reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    OR              reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IF              reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    COMMA           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    NEWLINE         reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    COLON           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    SEMICOLON       reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    ENDMARKER       reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    DEF             reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    CLASS           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    FOR             reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    WHILE           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    PASS            reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    BREAK           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    CONTINUE        reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    IDENTIFIER      reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    RETURN          reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    DEL             reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    GLOBAL          reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    PLUS            reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    MINUS           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    TRUE            reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    FALSE           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    NONE            reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    NUMBER          reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    F_NUMBER        reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    STRING          reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    TRIPLE_STRING   reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    ELIF            reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    ELSE            reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    DEDENT          reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    R_SQB           reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    R_PARENTHESIS   reduce using rule 81 (bitwise_xor -> bitwise_xor BITWISE_XOR bitwise_and .)
    BITWISE_AND     shift and go to state 98


state 140

    (83) bitwise_and -> bitwise_and BITWISE_AND shift_expr .
    (85) shift_expr -> shift_expr . L_SHIFT sum
    (86) shift_expr -> shift_expr . R_SHIFT sum

    BITWISE_AND     reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BITWISE_XOR     reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BITWISE_OR      reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    EQUALITY        reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    INEQUALITY      reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GREATER_EQUAL   reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    LESSER_EQUAL    reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GREATER         reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    LESSER          reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NOT             reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IS              reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IN              reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    AND             reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    OR              reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IF              reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    COMMA           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NEWLINE         reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    COLON           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    SEMICOLON       reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ENDMARKER       reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEF             reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    CLASS           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    FOR             reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    WHILE           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    PASS            reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BREAK           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    CONTINUE        reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IDENTIFIER      reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    RETURN          reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEL             reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GLOBAL          reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    PLUS            reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    MINUS           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    TRUE            reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    FALSE           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NONE            reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NUMBER          reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    F_NUMBER        reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    STRING          reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    TRIPLE_STRING   reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ELIF            reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ELSE            reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEDENT          reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    R_SQB           reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    R_PARENTHESIS   reduce using rule 83 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    L_SHIFT         shift and go to state 99
    R_SHIFT         shift and go to state 100


state 141

    (85) shift_expr -> shift_expr L_SHIFT sum .
    (88) sum -> sum . PLUS term
    (89) sum -> sum . MINUS term

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    L_SHIFT         reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    R_SHIFT         reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_AND     reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_XOR     reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_OR      reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    EQUALITY        reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    INEQUALITY      reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    GREATER_EQUAL   reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    LESSER_EQUAL    reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    GREATER         reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    LESSER          reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    NOT             reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    IS              reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    IN              reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    AND             reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    OR              reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    IF              reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    COMMA           reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    NEWLINE         reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    COLON           reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    SEMICOLON       reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    ENDMARKER       reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    DEF             reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    CLASS           reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    FOR             reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    WHILE           reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    PASS            reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    BREAK           reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    CONTINUE        reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    IDENTIFIER      reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    RETURN          reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    DEL             reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    GLOBAL          reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    TRUE            reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    FALSE           reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    NONE            reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    NUMBER          reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    F_NUMBER        reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    STRING          reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    TRIPLE_STRING   reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    ELIF            reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    ELSE            reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    DEDENT          reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    R_SQB           reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    R_PARENTHESIS   reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102

  ! PLUS            [ reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .) ]
  ! MINUS           [ reduce using rule 85 (shift_expr -> shift_expr L_SHIFT sum .) ]


state 142

    (86) shift_expr -> shift_expr R_SHIFT sum .
    (88) sum -> sum . PLUS term
    (89) sum -> sum . MINUS term

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    L_SHIFT         reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    R_SHIFT         reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_AND     reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_XOR     reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_OR      reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    EQUALITY        reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    INEQUALITY      reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    GREATER_EQUAL   reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    LESSER_EQUAL    reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    GREATER         reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    LESSER          reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    NOT             reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    IS              reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    IN              reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    AND             reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    OR              reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    IF              reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    COMMA           reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    NEWLINE         reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    COLON           reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    SEMICOLON       reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    ENDMARKER       reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    DEF             reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    CLASS           reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    FOR             reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    WHILE           reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    PASS            reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    BREAK           reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    CONTINUE        reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    IDENTIFIER      reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    RETURN          reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    DEL             reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    GLOBAL          reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    TRUE            reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    FALSE           reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    NONE            reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    NUMBER          reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    F_NUMBER        reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    STRING          reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    TRIPLE_STRING   reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    ELIF            reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    ELSE            reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    DEDENT          reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    R_SQB           reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    R_PARENTHESIS   reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102

  ! PLUS            [ reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .) ]
  ! MINUS           [ reduce using rule 86 (shift_expr -> shift_expr R_SHIFT sum .) ]


state 143

    (88) sum -> sum PLUS term .
    (91) term -> term . STAR factor
    (92) term -> term . DIVISION factor
    (93) term -> term . INTEGER_DIVISION factor
    (94) term -> term . MODULUS factor

    PLUS            reduce using rule 88 (sum -> sum PLUS term .)
    MINUS           reduce using rule 88 (sum -> sum PLUS term .)
    L_SHIFT         reduce using rule 88 (sum -> sum PLUS term .)
    R_SHIFT         reduce using rule 88 (sum -> sum PLUS term .)
    BITWISE_AND     reduce using rule 88 (sum -> sum PLUS term .)
    BITWISE_XOR     reduce using rule 88 (sum -> sum PLUS term .)
    BITWISE_OR      reduce using rule 88 (sum -> sum PLUS term .)
    EQUALITY        reduce using rule 88 (sum -> sum PLUS term .)
    INEQUALITY      reduce using rule 88 (sum -> sum PLUS term .)
    GREATER_EQUAL   reduce using rule 88 (sum -> sum PLUS term .)
    LESSER_EQUAL    reduce using rule 88 (sum -> sum PLUS term .)
    GREATER         reduce using rule 88 (sum -> sum PLUS term .)
    LESSER          reduce using rule 88 (sum -> sum PLUS term .)
    NOT             reduce using rule 88 (sum -> sum PLUS term .)
    IS              reduce using rule 88 (sum -> sum PLUS term .)
    IN              reduce using rule 88 (sum -> sum PLUS term .)
    AND             reduce using rule 88 (sum -> sum PLUS term .)
    OR              reduce using rule 88 (sum -> sum PLUS term .)
    IF              reduce using rule 88 (sum -> sum PLUS term .)
    COMMA           reduce using rule 88 (sum -> sum PLUS term .)
    NEWLINE         reduce using rule 88 (sum -> sum PLUS term .)
    COLON           reduce using rule 88 (sum -> sum PLUS term .)
    SEMICOLON       reduce using rule 88 (sum -> sum PLUS term .)
    ENDMARKER       reduce using rule 88 (sum -> sum PLUS term .)
    DEF             reduce using rule 88 (sum -> sum PLUS term .)
    CLASS           reduce using rule 88 (sum -> sum PLUS term .)
    FOR             reduce using rule 88 (sum -> sum PLUS term .)
    WHILE           reduce using rule 88 (sum -> sum PLUS term .)
    PASS            reduce using rule 88 (sum -> sum PLUS term .)
    BREAK           reduce using rule 88 (sum -> sum PLUS term .)
    CONTINUE        reduce using rule 88 (sum -> sum PLUS term .)
    IDENTIFIER      reduce using rule 88 (sum -> sum PLUS term .)
    RETURN          reduce using rule 88 (sum -> sum PLUS term .)
    DEL             reduce using rule 88 (sum -> sum PLUS term .)
    GLOBAL          reduce using rule 88 (sum -> sum PLUS term .)
    TRUE            reduce using rule 88 (sum -> sum PLUS term .)
    FALSE           reduce using rule 88 (sum -> sum PLUS term .)
    NONE            reduce using rule 88 (sum -> sum PLUS term .)
    NUMBER          reduce using rule 88 (sum -> sum PLUS term .)
    F_NUMBER        reduce using rule 88 (sum -> sum PLUS term .)
    STRING          reduce using rule 88 (sum -> sum PLUS term .)
    TRIPLE_STRING   reduce using rule 88 (sum -> sum PLUS term .)
    ELIF            reduce using rule 88 (sum -> sum PLUS term .)
    ELSE            reduce using rule 88 (sum -> sum PLUS term .)
    DEDENT          reduce using rule 88 (sum -> sum PLUS term .)
    R_SQB           reduce using rule 88 (sum -> sum PLUS term .)
    R_PARENTHESIS   reduce using rule 88 (sum -> sum PLUS term .)
    STAR            shift and go to state 104
    DIVISION        shift and go to state 105
    INTEGER_DIVISION shift and go to state 106
    MODULUS         shift and go to state 107


state 144

    (89) sum -> sum MINUS term .
    (91) term -> term . STAR factor
    (92) term -> term . DIVISION factor
    (93) term -> term . INTEGER_DIVISION factor
    (94) term -> term . MODULUS factor

    PLUS            reduce using rule 89 (sum -> sum MINUS term .)
    MINUS           reduce using rule 89 (sum -> sum MINUS term .)
    L_SHIFT         reduce using rule 89 (sum -> sum MINUS term .)
    R_SHIFT         reduce using rule 89 (sum -> sum MINUS term .)
    BITWISE_AND     reduce using rule 89 (sum -> sum MINUS term .)
    BITWISE_XOR     reduce using rule 89 (sum -> sum MINUS term .)
    BITWISE_OR      reduce using rule 89 (sum -> sum MINUS term .)
    EQUALITY        reduce using rule 89 (sum -> sum MINUS term .)
    INEQUALITY      reduce using rule 89 (sum -> sum MINUS term .)
    GREATER_EQUAL   reduce using rule 89 (sum -> sum MINUS term .)
    LESSER_EQUAL    reduce using rule 89 (sum -> sum MINUS term .)
    GREATER         reduce using rule 89 (sum -> sum MINUS term .)
    LESSER          reduce using rule 89 (sum -> sum MINUS term .)
    NOT             reduce using rule 89 (sum -> sum MINUS term .)
    IS              reduce using rule 89 (sum -> sum MINUS term .)
    IN              reduce using rule 89 (sum -> sum MINUS term .)
    AND             reduce using rule 89 (sum -> sum MINUS term .)
    OR              reduce using rule 89 (sum -> sum MINUS term .)
    IF              reduce using rule 89 (sum -> sum MINUS term .)
    COMMA           reduce using rule 89 (sum -> sum MINUS term .)
    NEWLINE         reduce using rule 89 (sum -> sum MINUS term .)
    COLON           reduce using rule 89 (sum -> sum MINUS term .)
    SEMICOLON       reduce using rule 89 (sum -> sum MINUS term .)
    ENDMARKER       reduce using rule 89 (sum -> sum MINUS term .)
    DEF             reduce using rule 89 (sum -> sum MINUS term .)
    CLASS           reduce using rule 89 (sum -> sum MINUS term .)
    FOR             reduce using rule 89 (sum -> sum MINUS term .)
    WHILE           reduce using rule 89 (sum -> sum MINUS term .)
    PASS            reduce using rule 89 (sum -> sum MINUS term .)
    BREAK           reduce using rule 89 (sum -> sum MINUS term .)
    CONTINUE        reduce using rule 89 (sum -> sum MINUS term .)
    IDENTIFIER      reduce using rule 89 (sum -> sum MINUS term .)
    RETURN          reduce using rule 89 (sum -> sum MINUS term .)
    DEL             reduce using rule 89 (sum -> sum MINUS term .)
    GLOBAL          reduce using rule 89 (sum -> sum MINUS term .)
    TRUE            reduce using rule 89 (sum -> sum MINUS term .)
    FALSE           reduce using rule 89 (sum -> sum MINUS term .)
    NONE            reduce using rule 89 (sum -> sum MINUS term .)
    NUMBER          reduce using rule 89 (sum -> sum MINUS term .)
    F_NUMBER        reduce using rule 89 (sum -> sum MINUS term .)
    STRING          reduce using rule 89 (sum -> sum MINUS term .)
    TRIPLE_STRING   reduce using rule 89 (sum -> sum MINUS term .)
    ELIF            reduce using rule 89 (sum -> sum MINUS term .)
    ELSE            reduce using rule 89 (sum -> sum MINUS term .)
    DEDENT          reduce using rule 89 (sum -> sum MINUS term .)
    R_SQB           reduce using rule 89 (sum -> sum MINUS term .)
    R_PARENTHESIS   reduce using rule 89 (sum -> sum MINUS term .)
    STAR            shift and go to state 104
    DIVISION        shift and go to state 105
    INTEGER_DIVISION shift and go to state 106
    MODULUS         shift and go to state 107


state 145

    (91) term -> term STAR factor .

    STAR            reduce using rule 91 (term -> term STAR factor .)
    DIVISION        reduce using rule 91 (term -> term STAR factor .)
    INTEGER_DIVISION reduce using rule 91 (term -> term STAR factor .)
    MODULUS         reduce using rule 91 (term -> term STAR factor .)
    PLUS            reduce using rule 91 (term -> term STAR factor .)
    MINUS           reduce using rule 91 (term -> term STAR factor .)
    L_SHIFT         reduce using rule 91 (term -> term STAR factor .)
    R_SHIFT         reduce using rule 91 (term -> term STAR factor .)
    BITWISE_AND     reduce using rule 91 (term -> term STAR factor .)
    BITWISE_XOR     reduce using rule 91 (term -> term STAR factor .)
    BITWISE_OR      reduce using rule 91 (term -> term STAR factor .)
    EQUALITY        reduce using rule 91 (term -> term STAR factor .)
    INEQUALITY      reduce using rule 91 (term -> term STAR factor .)
    GREATER_EQUAL   reduce using rule 91 (term -> term STAR factor .)
    LESSER_EQUAL    reduce using rule 91 (term -> term STAR factor .)
    GREATER         reduce using rule 91 (term -> term STAR factor .)
    LESSER          reduce using rule 91 (term -> term STAR factor .)
    NOT             reduce using rule 91 (term -> term STAR factor .)
    IS              reduce using rule 91 (term -> term STAR factor .)
    IN              reduce using rule 91 (term -> term STAR factor .)
    AND             reduce using rule 91 (term -> term STAR factor .)
    OR              reduce using rule 91 (term -> term STAR factor .)
    IF              reduce using rule 91 (term -> term STAR factor .)
    COMMA           reduce using rule 91 (term -> term STAR factor .)
    NEWLINE         reduce using rule 91 (term -> term STAR factor .)
    COLON           reduce using rule 91 (term -> term STAR factor .)
    SEMICOLON       reduce using rule 91 (term -> term STAR factor .)
    ENDMARKER       reduce using rule 91 (term -> term STAR factor .)
    DEF             reduce using rule 91 (term -> term STAR factor .)
    CLASS           reduce using rule 91 (term -> term STAR factor .)
    FOR             reduce using rule 91 (term -> term STAR factor .)
    WHILE           reduce using rule 91 (term -> term STAR factor .)
    PASS            reduce using rule 91 (term -> term STAR factor .)
    BREAK           reduce using rule 91 (term -> term STAR factor .)
    CONTINUE        reduce using rule 91 (term -> term STAR factor .)
    IDENTIFIER      reduce using rule 91 (term -> term STAR factor .)
    RETURN          reduce using rule 91 (term -> term STAR factor .)
    DEL             reduce using rule 91 (term -> term STAR factor .)
    GLOBAL          reduce using rule 91 (term -> term STAR factor .)
    TRUE            reduce using rule 91 (term -> term STAR factor .)
    FALSE           reduce using rule 91 (term -> term STAR factor .)
    NONE            reduce using rule 91 (term -> term STAR factor .)
    NUMBER          reduce using rule 91 (term -> term STAR factor .)
    F_NUMBER        reduce using rule 91 (term -> term STAR factor .)
    STRING          reduce using rule 91 (term -> term STAR factor .)
    TRIPLE_STRING   reduce using rule 91 (term -> term STAR factor .)
    ELIF            reduce using rule 91 (term -> term STAR factor .)
    ELSE            reduce using rule 91 (term -> term STAR factor .)
    DEDENT          reduce using rule 91 (term -> term STAR factor .)
    R_SQB           reduce using rule 91 (term -> term STAR factor .)
    R_PARENTHESIS   reduce using rule 91 (term -> term STAR factor .)


state 146

    (92) term -> term DIVISION factor .

    STAR            reduce using rule 92 (term -> term DIVISION factor .)
    DIVISION        reduce using rule 92 (term -> term DIVISION factor .)
    INTEGER_DIVISION reduce using rule 92 (term -> term DIVISION factor .)
    MODULUS         reduce using rule 92 (term -> term DIVISION factor .)
    PLUS            reduce using rule 92 (term -> term DIVISION factor .)
    MINUS           reduce using rule 92 (term -> term DIVISION factor .)
    L_SHIFT         reduce using rule 92 (term -> term DIVISION factor .)
    R_SHIFT         reduce using rule 92 (term -> term DIVISION factor .)
    BITWISE_AND     reduce using rule 92 (term -> term DIVISION factor .)
    BITWISE_XOR     reduce using rule 92 (term -> term DIVISION factor .)
    BITWISE_OR      reduce using rule 92 (term -> term DIVISION factor .)
    EQUALITY        reduce using rule 92 (term -> term DIVISION factor .)
    INEQUALITY      reduce using rule 92 (term -> term DIVISION factor .)
    GREATER_EQUAL   reduce using rule 92 (term -> term DIVISION factor .)
    LESSER_EQUAL    reduce using rule 92 (term -> term DIVISION factor .)
    GREATER         reduce using rule 92 (term -> term DIVISION factor .)
    LESSER          reduce using rule 92 (term -> term DIVISION factor .)
    NOT             reduce using rule 92 (term -> term DIVISION factor .)
    IS              reduce using rule 92 (term -> term DIVISION factor .)
    IN              reduce using rule 92 (term -> term DIVISION factor .)
    AND             reduce using rule 92 (term -> term DIVISION factor .)
    OR              reduce using rule 92 (term -> term DIVISION factor .)
    IF              reduce using rule 92 (term -> term DIVISION factor .)
    COMMA           reduce using rule 92 (term -> term DIVISION factor .)
    NEWLINE         reduce using rule 92 (term -> term DIVISION factor .)
    COLON           reduce using rule 92 (term -> term DIVISION factor .)
    SEMICOLON       reduce using rule 92 (term -> term DIVISION factor .)
    ENDMARKER       reduce using rule 92 (term -> term DIVISION factor .)
    DEF             reduce using rule 92 (term -> term DIVISION factor .)
    CLASS           reduce using rule 92 (term -> term DIVISION factor .)
    FOR             reduce using rule 92 (term -> term DIVISION factor .)
    WHILE           reduce using rule 92 (term -> term DIVISION factor .)
    PASS            reduce using rule 92 (term -> term DIVISION factor .)
    BREAK           reduce using rule 92 (term -> term DIVISION factor .)
    CONTINUE        reduce using rule 92 (term -> term DIVISION factor .)
    IDENTIFIER      reduce using rule 92 (term -> term DIVISION factor .)
    RETURN          reduce using rule 92 (term -> term DIVISION factor .)
    DEL             reduce using rule 92 (term -> term DIVISION factor .)
    GLOBAL          reduce using rule 92 (term -> term DIVISION factor .)
    TRUE            reduce using rule 92 (term -> term DIVISION factor .)
    FALSE           reduce using rule 92 (term -> term DIVISION factor .)
    NONE            reduce using rule 92 (term -> term DIVISION factor .)
    NUMBER          reduce using rule 92 (term -> term DIVISION factor .)
    F_NUMBER        reduce using rule 92 (term -> term DIVISION factor .)
    STRING          reduce using rule 92 (term -> term DIVISION factor .)
    TRIPLE_STRING   reduce using rule 92 (term -> term DIVISION factor .)
    ELIF            reduce using rule 92 (term -> term DIVISION factor .)
    ELSE            reduce using rule 92 (term -> term DIVISION factor .)
    DEDENT          reduce using rule 92 (term -> term DIVISION factor .)
    R_SQB           reduce using rule 92 (term -> term DIVISION factor .)
    R_PARENTHESIS   reduce using rule 92 (term -> term DIVISION factor .)


state 147

    (93) term -> term INTEGER_DIVISION factor .

    STAR            reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    DIVISION        reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    INTEGER_DIVISION reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    MODULUS         reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    PLUS            reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    MINUS           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    L_SHIFT         reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    R_SHIFT         reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    BITWISE_AND     reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    BITWISE_XOR     reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    BITWISE_OR      reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    EQUALITY        reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    INEQUALITY      reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    GREATER_EQUAL   reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    LESSER_EQUAL    reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    GREATER         reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    LESSER          reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    NOT             reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    IS              reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    IN              reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    AND             reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    OR              reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    IF              reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    COMMA           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    NEWLINE         reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    COLON           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    SEMICOLON       reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    ENDMARKER       reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    DEF             reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    CLASS           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    FOR             reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    WHILE           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    PASS            reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    BREAK           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    CONTINUE        reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    IDENTIFIER      reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    RETURN          reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    DEL             reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    GLOBAL          reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    TRUE            reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    FALSE           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    NONE            reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    NUMBER          reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    F_NUMBER        reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    STRING          reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    TRIPLE_STRING   reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    ELIF            reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    ELSE            reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    DEDENT          reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    R_SQB           reduce using rule 93 (term -> term INTEGER_DIVISION factor .)
    R_PARENTHESIS   reduce using rule 93 (term -> term INTEGER_DIVISION factor .)


state 148

    (94) term -> term MODULUS factor .

    STAR            reduce using rule 94 (term -> term MODULUS factor .)
    DIVISION        reduce using rule 94 (term -> term MODULUS factor .)
    INTEGER_DIVISION reduce using rule 94 (term -> term MODULUS factor .)
    MODULUS         reduce using rule 94 (term -> term MODULUS factor .)
    PLUS            reduce using rule 94 (term -> term MODULUS factor .)
    MINUS           reduce using rule 94 (term -> term MODULUS factor .)
    L_SHIFT         reduce using rule 94 (term -> term MODULUS factor .)
    R_SHIFT         reduce using rule 94 (term -> term MODULUS factor .)
    BITWISE_AND     reduce using rule 94 (term -> term MODULUS factor .)
    BITWISE_XOR     reduce using rule 94 (term -> term MODULUS factor .)
    BITWISE_OR      reduce using rule 94 (term -> term MODULUS factor .)
    EQUALITY        reduce using rule 94 (term -> term MODULUS factor .)
    INEQUALITY      reduce using rule 94 (term -> term MODULUS factor .)
    GREATER_EQUAL   reduce using rule 94 (term -> term MODULUS factor .)
    LESSER_EQUAL    reduce using rule 94 (term -> term MODULUS factor .)
    GREATER         reduce using rule 94 (term -> term MODULUS factor .)
    LESSER          reduce using rule 94 (term -> term MODULUS factor .)
    NOT             reduce using rule 94 (term -> term MODULUS factor .)
    IS              reduce using rule 94 (term -> term MODULUS factor .)
    IN              reduce using rule 94 (term -> term MODULUS factor .)
    AND             reduce using rule 94 (term -> term MODULUS factor .)
    OR              reduce using rule 94 (term -> term MODULUS factor .)
    IF              reduce using rule 94 (term -> term MODULUS factor .)
    COMMA           reduce using rule 94 (term -> term MODULUS factor .)
    NEWLINE         reduce using rule 94 (term -> term MODULUS factor .)
    COLON           reduce using rule 94 (term -> term MODULUS factor .)
    SEMICOLON       reduce using rule 94 (term -> term MODULUS factor .)
    ENDMARKER       reduce using rule 94 (term -> term MODULUS factor .)
    DEF             reduce using rule 94 (term -> term MODULUS factor .)
    CLASS           reduce using rule 94 (term -> term MODULUS factor .)
    FOR             reduce using rule 94 (term -> term MODULUS factor .)
    WHILE           reduce using rule 94 (term -> term MODULUS factor .)
    PASS            reduce using rule 94 (term -> term MODULUS factor .)
    BREAK           reduce using rule 94 (term -> term MODULUS factor .)
    CONTINUE        reduce using rule 94 (term -> term MODULUS factor .)
    IDENTIFIER      reduce using rule 94 (term -> term MODULUS factor .)
    RETURN          reduce using rule 94 (term -> term MODULUS factor .)
    DEL             reduce using rule 94 (term -> term MODULUS factor .)
    GLOBAL          reduce using rule 94 (term -> term MODULUS factor .)
    TRUE            reduce using rule 94 (term -> term MODULUS factor .)
    FALSE           reduce using rule 94 (term -> term MODULUS factor .)
    NONE            reduce using rule 94 (term -> term MODULUS factor .)
    NUMBER          reduce using rule 94 (term -> term MODULUS factor .)
    F_NUMBER        reduce using rule 94 (term -> term MODULUS factor .)
    STRING          reduce using rule 94 (term -> term MODULUS factor .)
    TRIPLE_STRING   reduce using rule 94 (term -> term MODULUS factor .)
    ELIF            reduce using rule 94 (term -> term MODULUS factor .)
    ELSE            reduce using rule 94 (term -> term MODULUS factor .)
    DEDENT          reduce using rule 94 (term -> term MODULUS factor .)
    R_SQB           reduce using rule 94 (term -> term MODULUS factor .)
    R_PARENTHESIS   reduce using rule 94 (term -> term MODULUS factor .)


state 149

    (99) power -> primary EXPONENTIATION target .

    STAR            reduce using rule 99 (power -> primary EXPONENTIATION target .)
    DIVISION        reduce using rule 99 (power -> primary EXPONENTIATION target .)
    INTEGER_DIVISION reduce using rule 99 (power -> primary EXPONENTIATION target .)
    MODULUS         reduce using rule 99 (power -> primary EXPONENTIATION target .)
    PLUS            reduce using rule 99 (power -> primary EXPONENTIATION target .)
    MINUS           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    L_SHIFT         reduce using rule 99 (power -> primary EXPONENTIATION target .)
    R_SHIFT         reduce using rule 99 (power -> primary EXPONENTIATION target .)
    BITWISE_AND     reduce using rule 99 (power -> primary EXPONENTIATION target .)
    BITWISE_XOR     reduce using rule 99 (power -> primary EXPONENTIATION target .)
    BITWISE_OR      reduce using rule 99 (power -> primary EXPONENTIATION target .)
    EQUALITY        reduce using rule 99 (power -> primary EXPONENTIATION target .)
    INEQUALITY      reduce using rule 99 (power -> primary EXPONENTIATION target .)
    GREATER_EQUAL   reduce using rule 99 (power -> primary EXPONENTIATION target .)
    LESSER_EQUAL    reduce using rule 99 (power -> primary EXPONENTIATION target .)
    GREATER         reduce using rule 99 (power -> primary EXPONENTIATION target .)
    LESSER          reduce using rule 99 (power -> primary EXPONENTIATION target .)
    NOT             reduce using rule 99 (power -> primary EXPONENTIATION target .)
    IS              reduce using rule 99 (power -> primary EXPONENTIATION target .)
    IN              reduce using rule 99 (power -> primary EXPONENTIATION target .)
    AND             reduce using rule 99 (power -> primary EXPONENTIATION target .)
    OR              reduce using rule 99 (power -> primary EXPONENTIATION target .)
    IF              reduce using rule 99 (power -> primary EXPONENTIATION target .)
    COMMA           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    NEWLINE         reduce using rule 99 (power -> primary EXPONENTIATION target .)
    COLON           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    SEMICOLON       reduce using rule 99 (power -> primary EXPONENTIATION target .)
    ENDMARKER       reduce using rule 99 (power -> primary EXPONENTIATION target .)
    DEF             reduce using rule 99 (power -> primary EXPONENTIATION target .)
    CLASS           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    FOR             reduce using rule 99 (power -> primary EXPONENTIATION target .)
    WHILE           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    PASS            reduce using rule 99 (power -> primary EXPONENTIATION target .)
    BREAK           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    CONTINUE        reduce using rule 99 (power -> primary EXPONENTIATION target .)
    IDENTIFIER      reduce using rule 99 (power -> primary EXPONENTIATION target .)
    RETURN          reduce using rule 99 (power -> primary EXPONENTIATION target .)
    DEL             reduce using rule 99 (power -> primary EXPONENTIATION target .)
    GLOBAL          reduce using rule 99 (power -> primary EXPONENTIATION target .)
    TRUE            reduce using rule 99 (power -> primary EXPONENTIATION target .)
    FALSE           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    NONE            reduce using rule 99 (power -> primary EXPONENTIATION target .)
    NUMBER          reduce using rule 99 (power -> primary EXPONENTIATION target .)
    F_NUMBER        reduce using rule 99 (power -> primary EXPONENTIATION target .)
    STRING          reduce using rule 99 (power -> primary EXPONENTIATION target .)
    TRIPLE_STRING   reduce using rule 99 (power -> primary EXPONENTIATION target .)
    ELIF            reduce using rule 99 (power -> primary EXPONENTIATION target .)
    ELSE            reduce using rule 99 (power -> primary EXPONENTIATION target .)
    DEDENT          reduce using rule 99 (power -> primary EXPONENTIATION target .)
    R_SQB           reduce using rule 99 (power -> primary EXPONENTIATION target .)
    R_PARENTHESIS   reduce using rule 99 (power -> primary EXPONENTIATION target .)


state 150

    (101) primary -> primary L_PARENTHESIS arguments . R_PARENTHESIS

    R_PARENTHESIS   shift and go to state 172


state 151

    (115) arguments -> empty .

    R_PARENTHESIS   reduce using rule 115 (arguments -> empty .)


state 152

    (102) primary -> primary L_SQB slices . R_SQB
    (105) slices -> slices . COMMA L_PARENTHESIS slice R_PARENTHESIS

    R_SQB           shift and go to state 173
    COMMA           shift and go to state 174


state 153

    (106) slices -> slice .

    R_SQB           reduce using rule 106 (slices -> slice .)
    COMMA           reduce using rule 106 (slices -> slice .)


state 154

    (107) slice -> expression .

    R_SQB           reduce using rule 107 (slice -> expression .)
    COMMA           reduce using rule 107 (slice -> expression .)
    R_PARENTHESIS   reduce using rule 107 (slice -> expression .)


state 155

    (103) primary -> primary DOT IDENTIFIER .

    EXPONENTIATION  reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    L_PARENTHESIS   reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    L_SQB           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    DOT             reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    STAR            reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    DIVISION        reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    INTEGER_DIVISION reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    MODULUS         reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    PLUS            reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    MINUS           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    L_SHIFT         reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    R_SHIFT         reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    BITWISE_AND     reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    BITWISE_XOR     reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    BITWISE_OR      reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    EQUALITY        reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    INEQUALITY      reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    LESSER_EQUAL    reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    GREATER         reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    LESSER          reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    NOT             reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    IS              reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    IN              reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    AND             reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    OR              reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    IF              reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    COMMA           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    NEWLINE         reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    COLON           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    ENDMARKER       reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    DEF             reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    CLASS           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    FOR             reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    WHILE           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    PASS            reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    BREAK           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    CONTINUE        reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    RETURN          reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    DEL             reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    GLOBAL          reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    TRUE            reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    FALSE           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    NONE            reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    NUMBER          reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    F_NUMBER        reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    STRING          reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    TRIPLE_STRING   reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    ELIF            reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    ELSE            reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    DEDENT          reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    R_SQB           reduce using rule 103 (primary -> primary DOT IDENTIFIER .)
    R_PARENTHESIS   reduce using rule 103 (primary -> primary DOT IDENTIFIER .)


state 156

    (43) parameters -> IDENTIFIER .

    R_PARENTHESIS   reduce using rule 43 (parameters -> IDENTIFIER .)
    COMMA           reduce using rule 43 (parameters -> IDENTIFIER .)


state 157

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters . R_PARENTHESIS COLON block
    (42) parameters -> parameters . COMMA IDENTIFIER

    R_PARENTHESIS   shift and go to state 175
    COMMA           shift and go to state 176


state 158

    (41) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS . COLON block

    COLON           shift and go to state 177


state 159

    (44) if_stmt -> IF expression COLON block . elif_stmt
    (45) if_stmt -> IF expression COLON block . else_block
    (46) if_stmt -> IF expression COLON block .
    (47) elif_stmt -> . ELIF expression COLON block elif_stmt
    (48) elif_stmt -> . ELIF expression COLON block else_block
    (49) elif_stmt -> . ELIF expression COLON block
    (50) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 46 (if_stmt -> IF expression COLON block .)
    DEF             reduce using rule 46 (if_stmt -> IF expression COLON block .)
    IF              reduce using rule 46 (if_stmt -> IF expression COLON block .)
    CLASS           reduce using rule 46 (if_stmt -> IF expression COLON block .)
    FOR             reduce using rule 46 (if_stmt -> IF expression COLON block .)
    WHILE           reduce using rule 46 (if_stmt -> IF expression COLON block .)
    PASS            reduce using rule 46 (if_stmt -> IF expression COLON block .)
    BREAK           reduce using rule 46 (if_stmt -> IF expression COLON block .)
    CONTINUE        reduce using rule 46 (if_stmt -> IF expression COLON block .)
    IDENTIFIER      reduce using rule 46 (if_stmt -> IF expression COLON block .)
    RETURN          reduce using rule 46 (if_stmt -> IF expression COLON block .)
    DEL             reduce using rule 46 (if_stmt -> IF expression COLON block .)
    GLOBAL          reduce using rule 46 (if_stmt -> IF expression COLON block .)
    NOT             reduce using rule 46 (if_stmt -> IF expression COLON block .)
    PLUS            reduce using rule 46 (if_stmt -> IF expression COLON block .)
    MINUS           reduce using rule 46 (if_stmt -> IF expression COLON block .)
    TRUE            reduce using rule 46 (if_stmt -> IF expression COLON block .)
    FALSE           reduce using rule 46 (if_stmt -> IF expression COLON block .)
    NONE            reduce using rule 46 (if_stmt -> IF expression COLON block .)
    NUMBER          reduce using rule 46 (if_stmt -> IF expression COLON block .)
    F_NUMBER        reduce using rule 46 (if_stmt -> IF expression COLON block .)
    STRING          reduce using rule 46 (if_stmt -> IF expression COLON block .)
    TRIPLE_STRING   reduce using rule 46 (if_stmt -> IF expression COLON block .)
    DEDENT          reduce using rule 46 (if_stmt -> IF expression COLON block .)
    ELIF            shift and go to state 180
    ELSE            shift and go to state 181

    elif_stmt                      shift and go to state 178
    else_block                     shift and go to state 179

state 160

    (35) block -> NEWLINE . INDENT statements DEDENT

    INDENT          shift and go to state 182


state 161

    (36) block -> simple_stmts .
    (6) simple_stmts -> simple_stmts . SEMICOLON simple_stmt

    ELIF            reduce using rule 36 (block -> simple_stmts .)
    ELSE            reduce using rule 36 (block -> simple_stmts .)
    ENDMARKER       reduce using rule 36 (block -> simple_stmts .)
    DEF             reduce using rule 36 (block -> simple_stmts .)
    IF              reduce using rule 36 (block -> simple_stmts .)
    CLASS           reduce using rule 36 (block -> simple_stmts .)
    FOR             reduce using rule 36 (block -> simple_stmts .)
    WHILE           reduce using rule 36 (block -> simple_stmts .)
    PASS            reduce using rule 36 (block -> simple_stmts .)
    BREAK           reduce using rule 36 (block -> simple_stmts .)
    CONTINUE        reduce using rule 36 (block -> simple_stmts .)
    IDENTIFIER      reduce using rule 36 (block -> simple_stmts .)
    RETURN          reduce using rule 36 (block -> simple_stmts .)
    DEL             reduce using rule 36 (block -> simple_stmts .)
    GLOBAL          reduce using rule 36 (block -> simple_stmts .)
    NOT             reduce using rule 36 (block -> simple_stmts .)
    PLUS            reduce using rule 36 (block -> simple_stmts .)
    MINUS           reduce using rule 36 (block -> simple_stmts .)
    TRUE            reduce using rule 36 (block -> simple_stmts .)
    FALSE           reduce using rule 36 (block -> simple_stmts .)
    NONE            reduce using rule 36 (block -> simple_stmts .)
    NUMBER          reduce using rule 36 (block -> simple_stmts .)
    F_NUMBER        reduce using rule 36 (block -> simple_stmts .)
    STRING          reduce using rule 36 (block -> simple_stmts .)
    TRIPLE_STRING   reduce using rule 36 (block -> simple_stmts .)
    DEDENT          reduce using rule 36 (block -> simple_stmts .)
    SEMICOLON       shift and go to state 57


state 162

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments . R_PARENTHESIS COLON block

    R_PARENTHESIS   shift and go to state 183


state 163

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS . COLON block

    COLON           shift and go to state 184


state 164

    (39) class_def -> CLASS IDENTIFIER COLON block .

    ENDMARKER       reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    DEF             reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    IF              reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    CLASS           reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    FOR             reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    WHILE           reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    PASS            reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    BREAK           reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    CONTINUE        reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    IDENTIFIER      reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    RETURN          reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    DEL             reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    GLOBAL          reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    NOT             reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    PLUS            reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    MINUS           reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    TRUE            reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    FALSE           reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    NONE            reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    NUMBER          reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    F_NUMBER        reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    STRING          reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    TRIPLE_STRING   reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)
    DEDENT          reduce using rule 39 (class_def -> CLASS IDENTIFIER COLON block .)


state 165

    (53) for_stmt -> FOR targets IN expressions . COLON else_block
    (54) for_stmt -> FOR targets IN expressions . COLON block
    (55) expressions -> expressions . COMMA expression

    COLON           shift and go to state 185
    COMMA           shift and go to state 75


state 166

    (118) targets -> targets COMMA target .

    IN              reduce using rule 118 (targets -> targets COMMA target .)
    COMMA           reduce using rule 118 (targets -> targets COMMA target .)


state 167

    (51) while_stmt -> WHILE expression COLON block . else_block
    (52) while_stmt -> WHILE expression COLON block .
    (50) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    DEF             reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    IF              reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    CLASS           reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    FOR             reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    WHILE           reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    PASS            reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    BREAK           reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    CONTINUE        reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    IDENTIFIER      reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    RETURN          reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    DEL             reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    GLOBAL          reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    NOT             reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    PLUS            reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    MINUS           reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    TRUE            reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    FALSE           reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    NONE            reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    NUMBER          reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    F_NUMBER        reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    STRING          reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    TRIPLE_STRING   reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    DEDENT          reduce using rule 52 (while_stmt -> WHILE expression COLON block .)
    ELSE            shift and go to state 181

    else_block                     shift and go to state 186

state 168

    (33) namelist -> namelist COMMA IDENTIFIER .

    COMMA           reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    NEWLINE         reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    ENDMARKER       reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    DEF             reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    IF              reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    CLASS           reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    FOR             reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    WHILE           reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    PASS            reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    BREAK           reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    CONTINUE        reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    IDENTIFIER      reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    RETURN          reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    DEL             reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    GLOBAL          reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    NOT             reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    PLUS            reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    MINUS           reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    TRUE            reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    FALSE           reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    NONE            reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    NUMBER          reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    F_NUMBER        reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    STRING          reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    TRIPLE_STRING   reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    ELIF            reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    ELSE            reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)
    DEDENT          reduce using rule 33 (namelist -> namelist COMMA IDENTIFIER .)


state 169

    (57) expression -> disjunction IF disjunction ELSE . expression
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    disjunction                    shift and go to state 30
    expression                     shift and go to state 187
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 170

    (75) compare_op -> NOT IN bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    INEQUALITY      reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    GREATER_EQUAL   reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    LESSER_EQUAL    reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    GREATER         reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    LESSER          reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    NOT             reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    IS              reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    IN              reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    AND             reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    OR              reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    IF              reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    COMMA           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    NEWLINE         reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    COLON           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    SEMICOLON       reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    ENDMARKER       reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    DEF             reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    CLASS           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    FOR             reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    WHILE           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    PASS            reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    BREAK           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    CONTINUE        reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    IDENTIFIER      reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    RETURN          reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    DEL             reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    GLOBAL          reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    PLUS            reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    MINUS           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    TRUE            reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    FALSE           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    NONE            reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    NUMBER          reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    F_NUMBER        reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    STRING          reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    TRIPLE_STRING   reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    ELIF            reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    ELSE            reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    DEDENT          reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    R_SQB           reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    R_PARENTHESIS   reduce using rule 75 (compare_op -> NOT IN bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 171

    (76) compare_op -> IS NOT bitwise_or .
    (79) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    INEQUALITY      reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    GREATER_EQUAL   reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    LESSER_EQUAL    reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    GREATER         reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    LESSER          reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    NOT             reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    IS              reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    IN              reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    AND             reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    OR              reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    IF              reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    COMMA           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    NEWLINE         reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    COLON           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    SEMICOLON       reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    ENDMARKER       reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    DEF             reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    CLASS           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    FOR             reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    WHILE           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    PASS            reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    BREAK           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    CONTINUE        reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    IDENTIFIER      reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    RETURN          reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    DEL             reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    GLOBAL          reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    PLUS            reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    MINUS           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    TRUE            reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    FALSE           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    NONE            reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    NUMBER          reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    F_NUMBER        reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    STRING          reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    TRIPLE_STRING   reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    ELIF            reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    ELSE            reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    DEDENT          reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    R_SQB           reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    R_PARENTHESIS   reduce using rule 76 (compare_op -> IS NOT bitwise_or .)
    BITWISE_OR      shift and go to state 86


state 172

    (101) primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .

    EXPONENTIATION  reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    L_PARENTHESIS   reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    L_SQB           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DOT             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    STAR            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DIVISION        reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    INTEGER_DIVISION reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    MODULUS         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    PLUS            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    MINUS           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    L_SHIFT         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    R_SHIFT         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BITWISE_AND     reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BITWISE_XOR     reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BITWISE_OR      reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    EQUALITY        reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    INEQUALITY      reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    GREATER_EQUAL   reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    LESSER_EQUAL    reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    GREATER         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    LESSER          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    NOT             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IS              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IN              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    AND             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    OR              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IF              reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    COMMA           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    NEWLINE         reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    COLON           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    SEMICOLON       reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    ENDMARKER       reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DEF             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    CLASS           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    FOR             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    WHILE           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    PASS            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    BREAK           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    CONTINUE        reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    IDENTIFIER      reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    RETURN          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DEL             reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    GLOBAL          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    TRUE            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    FALSE           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    NONE            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    NUMBER          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    F_NUMBER        reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    STRING          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    TRIPLE_STRING   reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    ELIF            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    ELSE            reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    DEDENT          reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    R_SQB           reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)
    R_PARENTHESIS   reduce using rule 101 (primary -> primary L_PARENTHESIS arguments R_PARENTHESIS .)


state 173

    (102) primary -> primary L_SQB slices R_SQB .

    EXPONENTIATION  reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    L_PARENTHESIS   reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    L_SQB           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DOT             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    STAR            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DIVISION        reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    INTEGER_DIVISION reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    MODULUS         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    PLUS            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    MINUS           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    L_SHIFT         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    R_SHIFT         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BITWISE_AND     reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BITWISE_XOR     reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BITWISE_OR      reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    EQUALITY        reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    INEQUALITY      reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    GREATER_EQUAL   reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    LESSER_EQUAL    reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    GREATER         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    LESSER          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    NOT             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IS              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IN              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    AND             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    OR              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IF              reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    COMMA           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    NEWLINE         reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    COLON           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    SEMICOLON       reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    ENDMARKER       reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DEF             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    CLASS           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    FOR             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    WHILE           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    PASS            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    BREAK           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    CONTINUE        reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    IDENTIFIER      reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    RETURN          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DEL             reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    GLOBAL          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    TRUE            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    FALSE           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    NONE            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    NUMBER          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    F_NUMBER        reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    STRING          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    TRIPLE_STRING   reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    ELIF            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    ELSE            reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    DEDENT          reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    R_SQB           reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)
    R_PARENTHESIS   reduce using rule 102 (primary -> primary L_SQB slices R_SQB .)


state 174

    (105) slices -> slices COMMA . L_PARENTHESIS slice R_PARENTHESIS

    L_PARENTHESIS   shift and go to state 188


state 175

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS . COLON block

    COLON           shift and go to state 189


state 176

    (42) parameters -> parameters COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 190


state 177

    (41) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    block                          shift and go to state 191
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 178

    (44) if_stmt -> IF expression COLON block elif_stmt .

    ENDMARKER       reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    DEF             reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    IF              reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    CLASS           reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    FOR             reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    WHILE           reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    PASS            reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    BREAK           reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    CONTINUE        reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    IDENTIFIER      reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    RETURN          reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    DEL             reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    GLOBAL          reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    NOT             reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    PLUS            reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    MINUS           reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    TRUE            reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    FALSE           reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    NONE            reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    NUMBER          reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    F_NUMBER        reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    STRING          reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    TRIPLE_STRING   reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)
    DEDENT          reduce using rule 44 (if_stmt -> IF expression COLON block elif_stmt .)


state 179

    (45) if_stmt -> IF expression COLON block else_block .

    ENDMARKER       reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    DEF             reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    IF              reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    CLASS           reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    FOR             reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    WHILE           reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    PASS            reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    BREAK           reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    CONTINUE        reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    IDENTIFIER      reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    RETURN          reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    DEL             reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    GLOBAL          reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    NOT             reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    PLUS            reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    MINUS           reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    TRUE            reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    FALSE           reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    NONE            reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    NUMBER          reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    F_NUMBER        reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    STRING          reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    TRIPLE_STRING   reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)
    DEDENT          reduce using rule 45 (if_stmt -> IF expression COLON block else_block .)


state 180

    (47) elif_stmt -> ELIF . expression COLON block elif_stmt
    (48) elif_stmt -> ELIF . expression COLON block else_block
    (49) elif_stmt -> ELIF . expression COLON block
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expression                     shift and go to state 192
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 181

    (50) else_block -> ELSE . COLON block

    COLON           shift and go to state 193


state 182

    (35) block -> NEWLINE INDENT . statements DEDENT
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (16) compound_stmt -> . function_def
    (17) compound_stmt -> . if_stmt
    (18) compound_stmt -> . class_def
    (19) compound_stmt -> . for_stmt
    (20) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (41) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (44) if_stmt -> . IF expression COLON block elif_stmt
    (45) if_stmt -> . IF expression COLON block else_block
    (46) if_stmt -> . IF expression COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (39) class_def -> . CLASS IDENTIFIER COLON block
    (53) for_stmt -> . FOR targets IN expressions COLON else_block
    (54) for_stmt -> . FOR targets IN expressions COLON block
    (51) while_stmt -> . WHILE expression COLON block else_block
    (52) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 16
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    statements                     shift and go to state 194
    statement                      shift and go to state 3
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    expression                     shift and go to state 15
    expressions                    shift and go to state 18
    assignment                     shift and go to state 20
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 183

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS . COLON block

    COLON           shift and go to state 195


state 184

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    block                          shift and go to state 196
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 185

    (53) for_stmt -> FOR targets IN expressions COLON . else_block
    (54) for_stmt -> FOR targets IN expressions COLON . block
    (50) else_block -> . ELSE COLON block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    ELSE            shift and go to state 181
    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expressions                    shift and go to state 18
    else_block                     shift and go to state 197
    block                          shift and go to state 198
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 186

    (51) while_stmt -> WHILE expression COLON block else_block .

    ENDMARKER       reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    DEF             reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    IF              reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    CLASS           reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    FOR             reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    WHILE           reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    PASS            reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    BREAK           reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    CONTINUE        reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    IDENTIFIER      reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    RETURN          reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    DEL             reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    GLOBAL          reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    NOT             reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    PLUS            reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    MINUS           reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    TRUE            reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    FALSE           reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    NONE            reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    NUMBER          reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    F_NUMBER        reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    STRING          reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    TRIPLE_STRING   reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)
    DEDENT          reduce using rule 51 (while_stmt -> WHILE expression COLON block else_block .)


state 187

    (57) expression -> disjunction IF disjunction ELSE expression .

    COMMA           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    NEWLINE         reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    COLON           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    SEMICOLON       reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    ENDMARKER       reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    DEF             reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    IF              reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    CLASS           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    FOR             reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    WHILE           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    PASS            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    BREAK           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    CONTINUE        reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    IDENTIFIER      reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    RETURN          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    DEL             reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    GLOBAL          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    NOT             reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    PLUS            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    MINUS           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    TRUE            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    FALSE           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    NONE            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    NUMBER          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    F_NUMBER        reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    STRING          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    TRIPLE_STRING   reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    ELIF            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    ELSE            reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    DEDENT          reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    R_SQB           reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)
    R_PARENTHESIS   reduce using rule 57 (expression -> disjunction IF disjunction ELSE expression .)


state 188

    (105) slices -> slices COMMA L_PARENTHESIS . slice R_PARENTHESIS
    (107) slice -> . expression
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    IDENTIFIER      shift and go to state 70
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    slice                          shift and go to state 199
    expression                     shift and go to state 154
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 189

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    block                          shift and go to state 200
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 190

    (42) parameters -> parameters COMMA IDENTIFIER .

    R_PARENTHESIS   reduce using rule 42 (parameters -> parameters COMMA IDENTIFIER .)
    COMMA           reduce using rule 42 (parameters -> parameters COMMA IDENTIFIER .)


state 191

    (41) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEF             reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IF              reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FOR             reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PASS            reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEL             reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    NOT             reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PLUS            reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    MINUS           reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    TRUE            reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FALSE           reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    NONE            reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    NUMBER          reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    F_NUMBER        reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    STRING          reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    TRIPLE_STRING   reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 41 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)


state 192

    (47) elif_stmt -> ELIF expression . COLON block elif_stmt
    (48) elif_stmt -> ELIF expression . COLON block else_block
    (49) elif_stmt -> ELIF expression . COLON block

    COLON           shift and go to state 201


state 193

    (50) else_block -> ELSE COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    block                          shift and go to state 202
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 194

    (35) block -> NEWLINE INDENT statements . DEDENT
    (2) statements -> statements . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (16) compound_stmt -> . function_def
    (17) compound_stmt -> . if_stmt
    (18) compound_stmt -> . class_def
    (19) compound_stmt -> . for_stmt
    (20) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (41) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (44) if_stmt -> . IF expression COLON block elif_stmt
    (45) if_stmt -> . IF expression COLON block else_block
    (46) if_stmt -> . IF expression COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (39) class_def -> . CLASS IDENTIFIER COLON block
    (53) for_stmt -> . FOR targets IN expressions COLON else_block
    (54) for_stmt -> . FOR targets IN expressions COLON block
    (51) while_stmt -> . WHILE expression COLON block else_block
    (52) while_stmt -> . WHILE expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    DEDENT          shift and go to state 203
    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 16
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    statement                      shift and go to state 56
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    expression                     shift and go to state 15
    expressions                    shift and go to state 18
    assignment                     shift and go to state 20
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 195

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    block                          shift and go to state 204
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    expression                     shift and go to state 15
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 196

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEF             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IF              reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FOR             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PASS            reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEL             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    NOT             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PLUS            reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    MINUS           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    TRUE            reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FALSE           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    NONE            reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    NUMBER          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    F_NUMBER        reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    STRING          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    TRIPLE_STRING   reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)


state 197

    (53) for_stmt -> FOR targets IN expressions COLON else_block .

    ENDMARKER       reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    DEF             reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    IF              reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    CLASS           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    FOR             reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    WHILE           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    PASS            reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    BREAK           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    CONTINUE        reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    IDENTIFIER      reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    RETURN          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    DEL             reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    GLOBAL          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    NOT             reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    PLUS            reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    MINUS           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    TRUE            reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    FALSE           reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    NONE            reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    NUMBER          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    F_NUMBER        reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    STRING          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    TRIPLE_STRING   reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)
    DEDENT          reduce using rule 53 (for_stmt -> FOR targets IN expressions COLON else_block .)


state 198

    (54) for_stmt -> FOR targets IN expressions COLON block .

    ENDMARKER       reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    DEF             reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    IF              reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    CLASS           reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    FOR             reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    WHILE           reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    PASS            reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    BREAK           reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    CONTINUE        reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    IDENTIFIER      reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    RETURN          reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    DEL             reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    GLOBAL          reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    NOT             reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    PLUS            reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    MINUS           reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    TRUE            reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    FALSE           reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    NONE            reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    NUMBER          reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    F_NUMBER        reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    STRING          reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    TRIPLE_STRING   reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)
    DEDENT          reduce using rule 54 (for_stmt -> FOR targets IN expressions COLON block .)


state 199

    (105) slices -> slices COMMA L_PARENTHESIS slice . R_PARENTHESIS

    R_PARENTHESIS   shift and go to state 205


state 200

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEF             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    IF              reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    FOR             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    PASS            reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEL             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    NOT             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    PLUS            reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    MINUS           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    TRUE            reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    FALSE           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    NONE            reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    NUMBER          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    F_NUMBER        reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    STRING          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    TRIPLE_STRING   reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)


state 201

    (47) elif_stmt -> ELIF expression COLON . block elif_stmt
    (48) elif_stmt -> ELIF expression COLON . block else_block
    (49) elif_stmt -> ELIF expression COLON . block
    (35) block -> . NEWLINE INDENT statements DEDENT
    (36) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . expressions
    (10) simple_stmt -> . return_stmt
    (11) simple_stmt -> . PASS
    (12) simple_stmt -> . del_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . CONTINUE
    (15) simple_stmt -> . global_stmt
    (21) assignment -> . IDENTIFIER augmentation_assignment expressions
    (55) expressions -> . expressions COMMA expression
    (56) expressions -> . expression
    (30) return_stmt -> . RETURN expressions
    (32) del_stmt -> . DEL namelist
    (31) global_stmt -> . GLOBAL namelist
    (57) expression -> . disjunction IF disjunction ELSE expression
    (58) expression -> . disjunction
    (59) disjunction -> . conjunction OR disjunction
    (60) disjunction -> . conjunction
    (61) conjunction -> . inversion AND inversion
    (62) conjunction -> . inversion
    (63) inversion -> . NOT inversion
    (64) inversion -> . comparison
    (65) comparison -> . bitwise_or compare_op_list
    (66) comparison -> . bitwise_or
    (79) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (80) bitwise_or -> . bitwise_xor
    (81) bitwise_xor -> . bitwise_xor BITWISE_XOR bitwise_and
    (82) bitwise_xor -> . bitwise_and
    (83) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (84) bitwise_and -> . shift_expr
    (85) shift_expr -> . shift_expr L_SHIFT sum
    (86) shift_expr -> . shift_expr R_SHIFT sum
    (87) shift_expr -> . sum
    (88) sum -> . sum PLUS term
    (89) sum -> . sum MINUS term
    (90) sum -> . term
    (91) term -> . term STAR factor
    (92) term -> . term DIVISION factor
    (93) term -> . term INTEGER_DIVISION factor
    (94) term -> . term MODULUS factor
    (95) term -> . factor
    (96) factor -> . PLUS factor
    (97) factor -> . MINUS factor
    (98) factor -> . power
    (99) power -> . primary EXPONENTIATION target
    (100) power -> . primary
    (101) primary -> . primary L_PARENTHESIS arguments R_PARENTHESIS
    (102) primary -> . primary L_SQB slices R_SQB
    (103) primary -> . primary DOT IDENTIFIER
    (104) primary -> . atomic
    (108) atomic -> . IDENTIFIER
    (109) atomic -> . TRUE
    (110) atomic -> . FALSE
    (111) atomic -> . NONE
    (112) atomic -> . strings
    (113) atomic -> . NUMBER
    (114) atomic -> . F_NUMBER
    (116) strings -> . STRING
    (117) strings -> . TRIPLE_STRING

    NEWLINE         shift and go to state 160
    PASS            shift and go to state 22
    BREAK           shift and go to state 24
    CONTINUE        shift and go to state 25
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 27
    DEL             shift and go to state 28
    GLOBAL          shift and go to state 29
    NOT             shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NONE            shift and go to state 49
    NUMBER          shift and go to state 51
    F_NUMBER        shift and go to state 52
    STRING          shift and go to state 53
    TRIPLE_STRING   shift and go to state 54

    expression                     shift and go to state 15
    block                          shift and go to state 206
    simple_stmts                   shift and go to state 161
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 20
    expressions                    shift and go to state 18
    return_stmt                    shift and go to state 21
    del_stmt                       shift and go to state 23
    global_stmt                    shift and go to state 26
    disjunction                    shift and go to state 30
    conjunction                    shift and go to state 31
    inversion                      shift and go to state 32
    comparison                     shift and go to state 34
    bitwise_or                     shift and go to state 35
    bitwise_xor                    shift and go to state 36
    bitwise_and                    shift and go to state 37
    shift_expr                     shift and go to state 38
    sum                            shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    power                          shift and go to state 44
    primary                        shift and go to state 45
    atomic                         shift and go to state 46
    strings                        shift and go to state 50

state 202

    (50) else_block -> ELSE COLON block .

    ENDMARKER       reduce using rule 50 (else_block -> ELSE COLON block .)
    DEF             reduce using rule 50 (else_block -> ELSE COLON block .)
    IF              reduce using rule 50 (else_block -> ELSE COLON block .)
    CLASS           reduce using rule 50 (else_block -> ELSE COLON block .)
    FOR             reduce using rule 50 (else_block -> ELSE COLON block .)
    WHILE           reduce using rule 50 (else_block -> ELSE COLON block .)
    PASS            reduce using rule 50 (else_block -> ELSE COLON block .)
    BREAK           reduce using rule 50 (else_block -> ELSE COLON block .)
    CONTINUE        reduce using rule 50 (else_block -> ELSE COLON block .)
    IDENTIFIER      reduce using rule 50 (else_block -> ELSE COLON block .)
    RETURN          reduce using rule 50 (else_block -> ELSE COLON block .)
    DEL             reduce using rule 50 (else_block -> ELSE COLON block .)
    GLOBAL          reduce using rule 50 (else_block -> ELSE COLON block .)
    NOT             reduce using rule 50 (else_block -> ELSE COLON block .)
    PLUS            reduce using rule 50 (else_block -> ELSE COLON block .)
    MINUS           reduce using rule 50 (else_block -> ELSE COLON block .)
    TRUE            reduce using rule 50 (else_block -> ELSE COLON block .)
    FALSE           reduce using rule 50 (else_block -> ELSE COLON block .)
    NONE            reduce using rule 50 (else_block -> ELSE COLON block .)
    NUMBER          reduce using rule 50 (else_block -> ELSE COLON block .)
    F_NUMBER        reduce using rule 50 (else_block -> ELSE COLON block .)
    STRING          reduce using rule 50 (else_block -> ELSE COLON block .)
    TRIPLE_STRING   reduce using rule 50 (else_block -> ELSE COLON block .)
    DEDENT          reduce using rule 50 (else_block -> ELSE COLON block .)


state 203

    (35) block -> NEWLINE INDENT statements DEDENT .

    ELIF            reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    ELSE            reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    ENDMARKER       reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    DEF             reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    IF              reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    CLASS           reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    FOR             reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    WHILE           reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    PASS            reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    BREAK           reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    CONTINUE        reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    IDENTIFIER      reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    RETURN          reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    DEL             reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    GLOBAL          reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    NOT             reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    PLUS            reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    MINUS           reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    TRUE            reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    FALSE           reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    NONE            reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    NUMBER          reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    F_NUMBER        reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    STRING          reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    TRIPLE_STRING   reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)
    DEDENT          reduce using rule 35 (block -> NEWLINE INDENT statements DEDENT .)


state 204

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEF             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    IF              reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    FOR             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    PASS            reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEL             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    NOT             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    PLUS            reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    MINUS           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    TRUE            reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    FALSE           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    NONE            reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    NUMBER          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    F_NUMBER        reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    STRING          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    TRIPLE_STRING   reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)


state 205

    (105) slices -> slices COMMA L_PARENTHESIS slice R_PARENTHESIS .

    R_SQB           reduce using rule 105 (slices -> slices COMMA L_PARENTHESIS slice R_PARENTHESIS .)
    COMMA           reduce using rule 105 (slices -> slices COMMA L_PARENTHESIS slice R_PARENTHESIS .)


state 206

    (47) elif_stmt -> ELIF expression COLON block . elif_stmt
    (48) elif_stmt -> ELIF expression COLON block . else_block
    (49) elif_stmt -> ELIF expression COLON block .
    (47) elif_stmt -> . ELIF expression COLON block elif_stmt
    (48) elif_stmt -> . ELIF expression COLON block else_block
    (49) elif_stmt -> . ELIF expression COLON block
    (50) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    DEF             reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    IF              reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    CLASS           reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    FOR             reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    WHILE           reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    PASS            reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    BREAK           reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    CONTINUE        reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    IDENTIFIER      reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    RETURN          reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    DEL             reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    GLOBAL          reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    NOT             reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    PLUS            reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    MINUS           reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    TRUE            reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    FALSE           reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    NONE            reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    NUMBER          reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    F_NUMBER        reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    STRING          reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    TRIPLE_STRING   reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    DEDENT          reduce using rule 49 (elif_stmt -> ELIF expression COLON block .)
    ELIF            shift and go to state 180
    ELSE            shift and go to state 181

    elif_stmt                      shift and go to state 207
    else_block                     shift and go to state 208

state 207

    (47) elif_stmt -> ELIF expression COLON block elif_stmt .

    ENDMARKER       reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    DEF             reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    IF              reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    CLASS           reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    FOR             reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    WHILE           reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    PASS            reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    BREAK           reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    CONTINUE        reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    IDENTIFIER      reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    RETURN          reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    DEL             reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    GLOBAL          reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    NOT             reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    PLUS            reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    MINUS           reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    TRUE            reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    FALSE           reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    NONE            reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    NUMBER          reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    F_NUMBER        reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    STRING          reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    TRIPLE_STRING   reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)
    DEDENT          reduce using rule 47 (elif_stmt -> ELIF expression COLON block elif_stmt .)


state 208

    (48) elif_stmt -> ELIF expression COLON block else_block .

    ENDMARKER       reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    DEF             reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    IF              reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    CLASS           reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    FOR             reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    WHILE           reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    PASS            reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    BREAK           reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    CONTINUE        reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    IDENTIFIER      reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    RETURN          reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    DEL             reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    GLOBAL          reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    NOT             reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    PLUS            reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    MINUS           reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    TRUE            reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    FALSE           reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    NONE            reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    NUMBER          reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    F_NUMBER        reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    STRING          reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    TRIPLE_STRING   reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)
    DEDENT          reduce using rule 48 (elif_stmt -> ELIF expression COLON block else_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 30 resolved as shift
WARNING: shift/reduce conflict for NOT in state 35 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 39 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 39 resolved as shift
WARNING: shift/reduce conflict for NOT in state 85 resolved as shift
WARNING: shift/reduce conflict for R_PARENTHESIS in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 141 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
