Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AS
    ASSIGNMENT
    AT
    BIN_NUMBER
    DOT
    EXPONENTIATION
    FALSE
    F_NUMBER
    HEX_NUMBER
    L_CB
    L_SQB
    NONE
    NUMBER
    OCT_NUMBER
    R_CB
    R_SQB
    STRING
    TRIPLE_STRING
    TRUE
    WHITESPACE

Grammar

Rule 0     S' -> file
Rule 1     file -> statements ENDMARKER
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> compound_stmt
Rule 5     statement -> simple_stmts
Rule 6     simple_stmts -> simple_stmts SEMICOLON simple_stmt
Rule 7     simple_stmts -> simple_stmt NEWLINE
Rule 8     simple_stmt -> assignment
Rule 9     simple_stmt -> return_stmt
Rule 10    simple_stmt -> PASS
Rule 11    simple_stmt -> del_stmt
Rule 12    simple_stmt -> BREAK
Rule 13    simple_stmt -> CONTINUE
Rule 14    simple_stmt -> global_stmt
Rule 15    compound_stmt -> function_def
Rule 16    compound_stmt -> if_stmt
Rule 17    compound_stmt -> class_def
Rule 18    compound_stmt -> for_stmt
Rule 19    compound_stmt -> while_stmt
Rule 20    assignment -> IDENTIFIER augmentation_assignment expressions
Rule 21    assignment -> IDENTIFIER augmentation_assignment IDENTIFIER
Rule 22    augmentation_assignment -> SUM_ASSIGNMENT
Rule 23    augmentation_assignment -> SUBTRACTION_ASSIGNMENT
Rule 24    augmentation_assignment -> PRODUCT_ASSIGNMENT
Rule 25    augmentation_assignment -> DIVISION_ASSIGNMENT
Rule 26    augmentation_assignment -> MODULUS_ASSIGNMENT
Rule 27    augmentation_assignment -> EXPONENTIATION_ASSIGNMENT
Rule 28    augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT
Rule 29    return_stmt -> RETURN expressions
Rule 30    global_stmt -> GLOBAL namelist
Rule 31    del_stmt -> DEL namelist
Rule 32    namelist -> namelist COMMA IDENTIFIER
Rule 33    namelist -> IDENTIFIER
Rule 34    block -> NEWLINE INDENT statements DEDENT
Rule 35    block -> simple_stmts
Rule 36    class_def -> CLASS IDENTIFIER COLON block
Rule 37    class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
Rule 38    class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
Rule 39    function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
Rule 40    function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
Rule 41    parameters -> parameters COMMA IDENTIFIER
Rule 42    parameters -> IDENTIFIER
Rule 43    if_stmt -> IF named_expression COLON block elif_stmt
Rule 44    if_stmt -> IF named_expression COLON block else_block
Rule 45    if_stmt -> IF named_expression COLON block
Rule 46    elif_stmt -> ELIF named_expression COLON block elif_stmt
Rule 47    elif_stmt -> ELIF named_expression COLON block else_block
Rule 48    elif_stmt -> ELIF named_expression COLON block
Rule 49    else_block -> ELSE COLON block
Rule 50    while_stmt -> WHILE named_expression COLON block
Rule 51    for_stmt -> FOR IDENTIFIER IN expressions COLON else_block
Rule 52    for_stmt -> FOR IDENTIFIER IN expressions COLON block
Rule 53    expressions -> expressions COMMA expression
Rule 54    expressions -> expression
Rule 55    expression -> disjunction
Rule 56    expression -> disjunction IF disjunction ELSE expression
Rule 57    disjunction -> conjunction
Rule 58    disjunction -> conjunction OR disjunction
Rule 59    conjunction -> inversion
Rule 60    conjunction -> inversion AND inversion
Rule 61    inversion -> NOT inversion
Rule 62    inversion -> comparison
Rule 63    named_expression -> expression
Rule 64    comparison -> bitwise_or
Rule 65    comparison -> bitwise_or compare_op_list
Rule 66    compare_op_list -> compare_op
Rule 67    compare_op_list -> compare_op_list compare_op
Rule 68    compare_op -> EQUALITY bitwise_or
Rule 69    compare_op -> INEQUALITY bitwise_or
Rule 70    compare_op -> GREATER_EQUAL bitwise_or
Rule 71    compare_op -> LESSER_EQUAL bitwise_or
Rule 72    compare_op -> GREATER bitwise_or
Rule 73    compare_op -> LESSER bitwise_or
Rule 74    compare_op -> NOT IN bitwise_or
Rule 75    compare_op -> IS NOT bitwise_or
Rule 76    compare_op -> IN bitwise_or
Rule 77    compare_op -> IS bitwise_or
Rule 78    bitwise_or -> bitwise_or BITWISE_OR bitwise_xor
Rule 79    bitwise_or -> bitwise_xor
Rule 80    bitwise_xor -> bitwise_xor empty bitwise_and
Rule 81    bitwise_xor -> bitwise_and
Rule 82    bitwise_and -> bitwise_and BITWISE_AND shift_expr
Rule 83    bitwise_and -> shift_expr
Rule 84    shift_expr -> shift_expr L_SHIFT sum
Rule 85    shift_expr -> shift_expr R_SHIFT sum
Rule 86    shift_expr -> sum
Rule 87    sum -> sum SUM term
Rule 88    sum -> sum SUBTRACTION term
Rule 89    sum -> term
Rule 90    term -> term PRODUCT factor
Rule 91    term -> term DIVISION factor
Rule 92    term -> term INTEGER_DIVISION factor
Rule 93    term -> term MODULUS factor
Rule 94    term -> factor
Rule 95    factor -> SUM factor
Rule 96    factor -> SUBTRACTION factor
Rule 97    factor -> power
Rule 98    power -> empty
Rule 99    arguments -> <empty>
Rule 100   empty -> <empty>

Terminals, with rules where they appear

AND                  : 60
AS                   : 
ASSIGNMENT           : 
AT                   : 
BIN_NUMBER           : 
BITWISE_AND          : 82
BITWISE_OR           : 78
BREAK                : 12
CLASS                : 36 37 38
COLON                : 36 37 38 39 40 43 44 45 46 47 48 49 50 51 52
COMMA                : 32 41 53
CONTINUE             : 13
DEDENT               : 34
DEF                  : 39 40
DEL                  : 31
DIVISION             : 91
DIVISION_ASSIGNMENT  : 25
DOT                  : 
ELIF                 : 46 47 48
ELSE                 : 49 56
ENDMARKER            : 1
EQUALITY             : 68
EXPONENTIATION       : 
EXPONENTIATION_ASSIGNMENT : 27
FALSE                : 
FOR                  : 51 52
F_NUMBER             : 
GLOBAL               : 30
GREATER              : 72
GREATER_EQUAL        : 70
HEX_NUMBER           : 
IDENTIFIER           : 20 21 21 32 33 36 37 38 39 40 41 42 51 52
IF                   : 43 44 45 56
IN                   : 51 52 74 76
INDENT               : 34
INEQUALITY           : 69
INTEGER_DIVISION     : 92
INTEGER_DIVISION_ASSIGNMENT : 28
IS                   : 75 77
LESSER               : 73
LESSER_EQUAL         : 71
L_CB                 : 
L_PARENTHESIS        : 37 38 39 40
L_SHIFT              : 84
L_SQB                : 
MODULUS              : 93
MODULUS_ASSIGNMENT   : 26
NEWLINE              : 7 34
NONE                 : 
NOT                  : 61 74 75
NUMBER               : 
OCT_NUMBER           : 
OR                   : 58
PASS                 : 10
PRODUCT              : 90
PRODUCT_ASSIGNMENT   : 24
RETURN               : 29
R_CB                 : 
R_PARENTHESIS        : 37 38 39 40
R_SHIFT              : 85
R_SQB                : 
SEMICOLON            : 6
STRING               : 
SUBTRACTION          : 88 96
SUBTRACTION_ASSIGNMENT : 23
SUM                  : 87 95
SUM_ASSIGNMENT       : 22
TRIPLE_STRING        : 
TRUE                 : 
WHILE                : 50
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

arguments            : 38
assignment           : 8
augmentation_assignment : 20 21
bitwise_and          : 80 81 82
bitwise_or           : 64 65 68 69 70 71 72 73 74 75 76 77 78
bitwise_xor          : 78 79 80
block                : 36 37 38 39 40 43 44 45 46 47 48 49 50 52
class_def            : 17
compare_op           : 66 67
compare_op_list      : 65 67
comparison           : 62
compound_stmt        : 4
conjunction          : 57 58
del_stmt             : 11
disjunction          : 55 56 56 58
elif_stmt            : 43 46
else_block           : 44 47 51
empty                : 80 98
expression           : 53 54 56 63
expressions          : 20 29 51 52 53
factor               : 90 91 92 93 94 95 96
file                 : 0
for_stmt             : 18
function_def         : 15
global_stmt          : 14
if_stmt              : 16
inversion            : 59 60 60 61
named_expression     : 43 44 45 46 47 48 50
namelist             : 30 31 32
parameters           : 39 41
power                : 97
return_stmt          : 9
shift_expr           : 82 83 84 85
simple_stmt          : 6 7
simple_stmts         : 5 6 35
statement            : 2 3
statements           : 1 2 34
sum                  : 84 85 86 87 88
term                 : 87 88 89 90 91 92 93
while_stmt           : 19

Parsing method: LALR

state 0

    (0) S' -> . file
    (1) file -> . statements ENDMARKER
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF named_expression COLON block elif_stmt
    (44) if_stmt -> . IF named_expression COLON block else_block
    (45) if_stmt -> . IF named_expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (51) for_stmt -> . FOR IDENTIFIER IN expressions COLON else_block
    (52) for_stmt -> . FOR IDENTIFIER IN expressions COLON block
    (50) while_stmt -> . WHILE named_expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    file                           shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 1

    (0) S' -> file .



state 2

    (1) file -> statements . ENDMARKER
    (2) statements -> statements . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF named_expression COLON block elif_stmt
    (44) if_stmt -> . IF named_expression COLON block else_block
    (45) if_stmt -> . IF named_expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (51) for_stmt -> . FOR IDENTIFIER IN expressions COLON else_block
    (52) for_stmt -> . FOR IDENTIFIER IN expressions COLON block
    (50) while_stmt -> . WHILE named_expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    ENDMARKER       shift and go to state 28
    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    statement                      shift and go to state 29
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 3

    (3) statements -> statement .

    ENDMARKER       reduce using rule 3 (statements -> statement .)
    DEF             reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    CLASS           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)
    PASS            reduce using rule 3 (statements -> statement .)
    BREAK           reduce using rule 3 (statements -> statement .)
    CONTINUE        reduce using rule 3 (statements -> statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    DEL             reduce using rule 3 (statements -> statement .)
    GLOBAL          reduce using rule 3 (statements -> statement .)
    DEDENT          reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> compound_stmt .

    ENDMARKER       reduce using rule 4 (statement -> compound_stmt .)
    DEF             reduce using rule 4 (statement -> compound_stmt .)
    IF              reduce using rule 4 (statement -> compound_stmt .)
    CLASS           reduce using rule 4 (statement -> compound_stmt .)
    FOR             reduce using rule 4 (statement -> compound_stmt .)
    WHILE           reduce using rule 4 (statement -> compound_stmt .)
    PASS            reduce using rule 4 (statement -> compound_stmt .)
    BREAK           reduce using rule 4 (statement -> compound_stmt .)
    CONTINUE        reduce using rule 4 (statement -> compound_stmt .)
    IDENTIFIER      reduce using rule 4 (statement -> compound_stmt .)
    RETURN          reduce using rule 4 (statement -> compound_stmt .)
    DEL             reduce using rule 4 (statement -> compound_stmt .)
    GLOBAL          reduce using rule 4 (statement -> compound_stmt .)
    DEDENT          reduce using rule 4 (statement -> compound_stmt .)


state 5

    (5) statement -> simple_stmts .
    (6) simple_stmts -> simple_stmts . SEMICOLON simple_stmt

    ENDMARKER       reduce using rule 5 (statement -> simple_stmts .)
    DEF             reduce using rule 5 (statement -> simple_stmts .)
    IF              reduce using rule 5 (statement -> simple_stmts .)
    CLASS           reduce using rule 5 (statement -> simple_stmts .)
    FOR             reduce using rule 5 (statement -> simple_stmts .)
    WHILE           reduce using rule 5 (statement -> simple_stmts .)
    PASS            reduce using rule 5 (statement -> simple_stmts .)
    BREAK           reduce using rule 5 (statement -> simple_stmts .)
    CONTINUE        reduce using rule 5 (statement -> simple_stmts .)
    IDENTIFIER      reduce using rule 5 (statement -> simple_stmts .)
    RETURN          reduce using rule 5 (statement -> simple_stmts .)
    DEL             reduce using rule 5 (statement -> simple_stmts .)
    GLOBAL          reduce using rule 5 (statement -> simple_stmts .)
    DEDENT          reduce using rule 5 (statement -> simple_stmts .)
    SEMICOLON       shift and go to state 30


state 6

    (15) compound_stmt -> function_def .

    ENDMARKER       reduce using rule 15 (compound_stmt -> function_def .)
    DEF             reduce using rule 15 (compound_stmt -> function_def .)
    IF              reduce using rule 15 (compound_stmt -> function_def .)
    CLASS           reduce using rule 15 (compound_stmt -> function_def .)
    FOR             reduce using rule 15 (compound_stmt -> function_def .)
    WHILE           reduce using rule 15 (compound_stmt -> function_def .)
    PASS            reduce using rule 15 (compound_stmt -> function_def .)
    BREAK           reduce using rule 15 (compound_stmt -> function_def .)
    CONTINUE        reduce using rule 15 (compound_stmt -> function_def .)
    IDENTIFIER      reduce using rule 15 (compound_stmt -> function_def .)
    RETURN          reduce using rule 15 (compound_stmt -> function_def .)
    DEL             reduce using rule 15 (compound_stmt -> function_def .)
    GLOBAL          reduce using rule 15 (compound_stmt -> function_def .)
    DEDENT          reduce using rule 15 (compound_stmt -> function_def .)


state 7

    (16) compound_stmt -> if_stmt .

    ENDMARKER       reduce using rule 16 (compound_stmt -> if_stmt .)
    DEF             reduce using rule 16 (compound_stmt -> if_stmt .)
    IF              reduce using rule 16 (compound_stmt -> if_stmt .)
    CLASS           reduce using rule 16 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 16 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 16 (compound_stmt -> if_stmt .)
    PASS            reduce using rule 16 (compound_stmt -> if_stmt .)
    BREAK           reduce using rule 16 (compound_stmt -> if_stmt .)
    CONTINUE        reduce using rule 16 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 16 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 16 (compound_stmt -> if_stmt .)
    DEL             reduce using rule 16 (compound_stmt -> if_stmt .)
    GLOBAL          reduce using rule 16 (compound_stmt -> if_stmt .)
    DEDENT          reduce using rule 16 (compound_stmt -> if_stmt .)


state 8

    (17) compound_stmt -> class_def .

    ENDMARKER       reduce using rule 17 (compound_stmt -> class_def .)
    DEF             reduce using rule 17 (compound_stmt -> class_def .)
    IF              reduce using rule 17 (compound_stmt -> class_def .)
    CLASS           reduce using rule 17 (compound_stmt -> class_def .)
    FOR             reduce using rule 17 (compound_stmt -> class_def .)
    WHILE           reduce using rule 17 (compound_stmt -> class_def .)
    PASS            reduce using rule 17 (compound_stmt -> class_def .)
    BREAK           reduce using rule 17 (compound_stmt -> class_def .)
    CONTINUE        reduce using rule 17 (compound_stmt -> class_def .)
    IDENTIFIER      reduce using rule 17 (compound_stmt -> class_def .)
    RETURN          reduce using rule 17 (compound_stmt -> class_def .)
    DEL             reduce using rule 17 (compound_stmt -> class_def .)
    GLOBAL          reduce using rule 17 (compound_stmt -> class_def .)
    DEDENT          reduce using rule 17 (compound_stmt -> class_def .)


state 9

    (18) compound_stmt -> for_stmt .

    ENDMARKER       reduce using rule 18 (compound_stmt -> for_stmt .)
    DEF             reduce using rule 18 (compound_stmt -> for_stmt .)
    IF              reduce using rule 18 (compound_stmt -> for_stmt .)
    CLASS           reduce using rule 18 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 18 (compound_stmt -> for_stmt .)
    WHILE           reduce using rule 18 (compound_stmt -> for_stmt .)
    PASS            reduce using rule 18 (compound_stmt -> for_stmt .)
    BREAK           reduce using rule 18 (compound_stmt -> for_stmt .)
    CONTINUE        reduce using rule 18 (compound_stmt -> for_stmt .)
    IDENTIFIER      reduce using rule 18 (compound_stmt -> for_stmt .)
    RETURN          reduce using rule 18 (compound_stmt -> for_stmt .)
    DEL             reduce using rule 18 (compound_stmt -> for_stmt .)
    GLOBAL          reduce using rule 18 (compound_stmt -> for_stmt .)
    DEDENT          reduce using rule 18 (compound_stmt -> for_stmt .)


state 10

    (19) compound_stmt -> while_stmt .

    ENDMARKER       reduce using rule 19 (compound_stmt -> while_stmt .)
    DEF             reduce using rule 19 (compound_stmt -> while_stmt .)
    IF              reduce using rule 19 (compound_stmt -> while_stmt .)
    CLASS           reduce using rule 19 (compound_stmt -> while_stmt .)
    FOR             reduce using rule 19 (compound_stmt -> while_stmt .)
    WHILE           reduce using rule 19 (compound_stmt -> while_stmt .)
    PASS            reduce using rule 19 (compound_stmt -> while_stmt .)
    BREAK           reduce using rule 19 (compound_stmt -> while_stmt .)
    CONTINUE        reduce using rule 19 (compound_stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 19 (compound_stmt -> while_stmt .)
    RETURN          reduce using rule 19 (compound_stmt -> while_stmt .)
    DEL             reduce using rule 19 (compound_stmt -> while_stmt .)
    GLOBAL          reduce using rule 19 (compound_stmt -> while_stmt .)
    DEDENT          reduce using rule 19 (compound_stmt -> while_stmt .)


state 11

    (7) simple_stmts -> simple_stmt . NEWLINE

    NEWLINE         shift and go to state 31


state 12

    (39) function_def -> DEF . IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> DEF . IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block

    IDENTIFIER      shift and go to state 32


state 13

    (20) assignment -> IDENTIFIER . augmentation_assignment expressions
    (21) assignment -> IDENTIFIER . augmentation_assignment IDENTIFIER
    (22) augmentation_assignment -> . SUM_ASSIGNMENT
    (23) augmentation_assignment -> . SUBTRACTION_ASSIGNMENT
    (24) augmentation_assignment -> . PRODUCT_ASSIGNMENT
    (25) augmentation_assignment -> . DIVISION_ASSIGNMENT
    (26) augmentation_assignment -> . MODULUS_ASSIGNMENT
    (27) augmentation_assignment -> . EXPONENTIATION_ASSIGNMENT
    (28) augmentation_assignment -> . INTEGER_DIVISION_ASSIGNMENT

    SUM_ASSIGNMENT  shift and go to state 34
    SUBTRACTION_ASSIGNMENT shift and go to state 35
    PRODUCT_ASSIGNMENT shift and go to state 36
    DIVISION_ASSIGNMENT shift and go to state 37
    MODULUS_ASSIGNMENT shift and go to state 38
    EXPONENTIATION_ASSIGNMENT shift and go to state 39
    INTEGER_DIVISION_ASSIGNMENT shift and go to state 40

    augmentation_assignment        shift and go to state 33

state 14

    (43) if_stmt -> IF . named_expression COLON block elif_stmt
    (44) if_stmt -> IF . named_expression COLON block else_block
    (45) if_stmt -> IF . named_expression COLON block
    (63) named_expression -> . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    named_expression               shift and go to state 41
    expression                     shift and go to state 42
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 15

    (36) class_def -> CLASS . IDENTIFIER COLON block
    (37) class_def -> CLASS . IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> CLASS . IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block

    IDENTIFIER      shift and go to state 59


state 16

    (51) for_stmt -> FOR . IDENTIFIER IN expressions COLON else_block
    (52) for_stmt -> FOR . IDENTIFIER IN expressions COLON block

    IDENTIFIER      shift and go to state 60


state 17

    (50) while_stmt -> WHILE . named_expression COLON block
    (63) named_expression -> . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    named_expression               shift and go to state 61
    expression                     shift and go to state 42
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 18

    (8) simple_stmt -> assignment .

    NEWLINE         reduce using rule 8 (simple_stmt -> assignment .)
    SEMICOLON       reduce using rule 8 (simple_stmt -> assignment .)
    ENDMARKER       reduce using rule 8 (simple_stmt -> assignment .)
    DEF             reduce using rule 8 (simple_stmt -> assignment .)
    IF              reduce using rule 8 (simple_stmt -> assignment .)
    CLASS           reduce using rule 8 (simple_stmt -> assignment .)
    FOR             reduce using rule 8 (simple_stmt -> assignment .)
    WHILE           reduce using rule 8 (simple_stmt -> assignment .)
    PASS            reduce using rule 8 (simple_stmt -> assignment .)
    BREAK           reduce using rule 8 (simple_stmt -> assignment .)
    CONTINUE        reduce using rule 8 (simple_stmt -> assignment .)
    IDENTIFIER      reduce using rule 8 (simple_stmt -> assignment .)
    RETURN          reduce using rule 8 (simple_stmt -> assignment .)
    DEL             reduce using rule 8 (simple_stmt -> assignment .)
    GLOBAL          reduce using rule 8 (simple_stmt -> assignment .)
    ELIF            reduce using rule 8 (simple_stmt -> assignment .)
    ELSE            reduce using rule 8 (simple_stmt -> assignment .)
    DEDENT          reduce using rule 8 (simple_stmt -> assignment .)


state 19

    (9) simple_stmt -> return_stmt .

    NEWLINE         reduce using rule 9 (simple_stmt -> return_stmt .)
    SEMICOLON       reduce using rule 9 (simple_stmt -> return_stmt .)
    ENDMARKER       reduce using rule 9 (simple_stmt -> return_stmt .)
    DEF             reduce using rule 9 (simple_stmt -> return_stmt .)
    IF              reduce using rule 9 (simple_stmt -> return_stmt .)
    CLASS           reduce using rule 9 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 9 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 9 (simple_stmt -> return_stmt .)
    PASS            reduce using rule 9 (simple_stmt -> return_stmt .)
    BREAK           reduce using rule 9 (simple_stmt -> return_stmt .)
    CONTINUE        reduce using rule 9 (simple_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 9 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 9 (simple_stmt -> return_stmt .)
    DEL             reduce using rule 9 (simple_stmt -> return_stmt .)
    GLOBAL          reduce using rule 9 (simple_stmt -> return_stmt .)
    ELIF            reduce using rule 9 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 9 (simple_stmt -> return_stmt .)
    DEDENT          reduce using rule 9 (simple_stmt -> return_stmt .)


state 20

    (10) simple_stmt -> PASS .

    NEWLINE         reduce using rule 10 (simple_stmt -> PASS .)
    SEMICOLON       reduce using rule 10 (simple_stmt -> PASS .)
    ENDMARKER       reduce using rule 10 (simple_stmt -> PASS .)
    DEF             reduce using rule 10 (simple_stmt -> PASS .)
    IF              reduce using rule 10 (simple_stmt -> PASS .)
    CLASS           reduce using rule 10 (simple_stmt -> PASS .)
    FOR             reduce using rule 10 (simple_stmt -> PASS .)
    WHILE           reduce using rule 10 (simple_stmt -> PASS .)
    PASS            reduce using rule 10 (simple_stmt -> PASS .)
    BREAK           reduce using rule 10 (simple_stmt -> PASS .)
    CONTINUE        reduce using rule 10 (simple_stmt -> PASS .)
    IDENTIFIER      reduce using rule 10 (simple_stmt -> PASS .)
    RETURN          reduce using rule 10 (simple_stmt -> PASS .)
    DEL             reduce using rule 10 (simple_stmt -> PASS .)
    GLOBAL          reduce using rule 10 (simple_stmt -> PASS .)
    ELIF            reduce using rule 10 (simple_stmt -> PASS .)
    ELSE            reduce using rule 10 (simple_stmt -> PASS .)
    DEDENT          reduce using rule 10 (simple_stmt -> PASS .)


state 21

    (11) simple_stmt -> del_stmt .

    NEWLINE         reduce using rule 11 (simple_stmt -> del_stmt .)
    SEMICOLON       reduce using rule 11 (simple_stmt -> del_stmt .)
    ENDMARKER       reduce using rule 11 (simple_stmt -> del_stmt .)
    DEF             reduce using rule 11 (simple_stmt -> del_stmt .)
    IF              reduce using rule 11 (simple_stmt -> del_stmt .)
    CLASS           reduce using rule 11 (simple_stmt -> del_stmt .)
    FOR             reduce using rule 11 (simple_stmt -> del_stmt .)
    WHILE           reduce using rule 11 (simple_stmt -> del_stmt .)
    PASS            reduce using rule 11 (simple_stmt -> del_stmt .)
    BREAK           reduce using rule 11 (simple_stmt -> del_stmt .)
    CONTINUE        reduce using rule 11 (simple_stmt -> del_stmt .)
    IDENTIFIER      reduce using rule 11 (simple_stmt -> del_stmt .)
    RETURN          reduce using rule 11 (simple_stmt -> del_stmt .)
    DEL             reduce using rule 11 (simple_stmt -> del_stmt .)
    GLOBAL          reduce using rule 11 (simple_stmt -> del_stmt .)
    ELIF            reduce using rule 11 (simple_stmt -> del_stmt .)
    ELSE            reduce using rule 11 (simple_stmt -> del_stmt .)
    DEDENT          reduce using rule 11 (simple_stmt -> del_stmt .)


state 22

    (12) simple_stmt -> BREAK .

    NEWLINE         reduce using rule 12 (simple_stmt -> BREAK .)
    SEMICOLON       reduce using rule 12 (simple_stmt -> BREAK .)
    ENDMARKER       reduce using rule 12 (simple_stmt -> BREAK .)
    DEF             reduce using rule 12 (simple_stmt -> BREAK .)
    IF              reduce using rule 12 (simple_stmt -> BREAK .)
    CLASS           reduce using rule 12 (simple_stmt -> BREAK .)
    FOR             reduce using rule 12 (simple_stmt -> BREAK .)
    WHILE           reduce using rule 12 (simple_stmt -> BREAK .)
    PASS            reduce using rule 12 (simple_stmt -> BREAK .)
    BREAK           reduce using rule 12 (simple_stmt -> BREAK .)
    CONTINUE        reduce using rule 12 (simple_stmt -> BREAK .)
    IDENTIFIER      reduce using rule 12 (simple_stmt -> BREAK .)
    RETURN          reduce using rule 12 (simple_stmt -> BREAK .)
    DEL             reduce using rule 12 (simple_stmt -> BREAK .)
    GLOBAL          reduce using rule 12 (simple_stmt -> BREAK .)
    ELIF            reduce using rule 12 (simple_stmt -> BREAK .)
    ELSE            reduce using rule 12 (simple_stmt -> BREAK .)
    DEDENT          reduce using rule 12 (simple_stmt -> BREAK .)


state 23

    (13) simple_stmt -> CONTINUE .

    NEWLINE         reduce using rule 13 (simple_stmt -> CONTINUE .)
    SEMICOLON       reduce using rule 13 (simple_stmt -> CONTINUE .)
    ENDMARKER       reduce using rule 13 (simple_stmt -> CONTINUE .)
    DEF             reduce using rule 13 (simple_stmt -> CONTINUE .)
    IF              reduce using rule 13 (simple_stmt -> CONTINUE .)
    CLASS           reduce using rule 13 (simple_stmt -> CONTINUE .)
    FOR             reduce using rule 13 (simple_stmt -> CONTINUE .)
    WHILE           reduce using rule 13 (simple_stmt -> CONTINUE .)
    PASS            reduce using rule 13 (simple_stmt -> CONTINUE .)
    BREAK           reduce using rule 13 (simple_stmt -> CONTINUE .)
    CONTINUE        reduce using rule 13 (simple_stmt -> CONTINUE .)
    IDENTIFIER      reduce using rule 13 (simple_stmt -> CONTINUE .)
    RETURN          reduce using rule 13 (simple_stmt -> CONTINUE .)
    DEL             reduce using rule 13 (simple_stmt -> CONTINUE .)
    GLOBAL          reduce using rule 13 (simple_stmt -> CONTINUE .)
    ELIF            reduce using rule 13 (simple_stmt -> CONTINUE .)
    ELSE            reduce using rule 13 (simple_stmt -> CONTINUE .)
    DEDENT          reduce using rule 13 (simple_stmt -> CONTINUE .)


state 24

    (14) simple_stmt -> global_stmt .

    NEWLINE         reduce using rule 14 (simple_stmt -> global_stmt .)
    SEMICOLON       reduce using rule 14 (simple_stmt -> global_stmt .)
    ENDMARKER       reduce using rule 14 (simple_stmt -> global_stmt .)
    DEF             reduce using rule 14 (simple_stmt -> global_stmt .)
    IF              reduce using rule 14 (simple_stmt -> global_stmt .)
    CLASS           reduce using rule 14 (simple_stmt -> global_stmt .)
    FOR             reduce using rule 14 (simple_stmt -> global_stmt .)
    WHILE           reduce using rule 14 (simple_stmt -> global_stmt .)
    PASS            reduce using rule 14 (simple_stmt -> global_stmt .)
    BREAK           reduce using rule 14 (simple_stmt -> global_stmt .)
    CONTINUE        reduce using rule 14 (simple_stmt -> global_stmt .)
    IDENTIFIER      reduce using rule 14 (simple_stmt -> global_stmt .)
    RETURN          reduce using rule 14 (simple_stmt -> global_stmt .)
    DEL             reduce using rule 14 (simple_stmt -> global_stmt .)
    GLOBAL          reduce using rule 14 (simple_stmt -> global_stmt .)
    ELIF            reduce using rule 14 (simple_stmt -> global_stmt .)
    ELSE            reduce using rule 14 (simple_stmt -> global_stmt .)
    DEDENT          reduce using rule 14 (simple_stmt -> global_stmt .)


state 25

    (29) return_stmt -> RETURN . expressions
    (53) expressions -> . expressions COMMA expression
    (54) expressions -> . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    expressions                    shift and go to state 62
    expression                     shift and go to state 63
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 26

    (31) del_stmt -> DEL . namelist
    (32) namelist -> . namelist COMMA IDENTIFIER
    (33) namelist -> . IDENTIFIER

    IDENTIFIER      shift and go to state 65

    namelist                       shift and go to state 64

state 27

    (30) global_stmt -> GLOBAL . namelist
    (32) namelist -> . namelist COMMA IDENTIFIER
    (33) namelist -> . IDENTIFIER

    IDENTIFIER      shift and go to state 65

    namelist                       shift and go to state 66

state 28

    (1) file -> statements ENDMARKER .

    $end            reduce using rule 1 (file -> statements ENDMARKER .)


state 29

    (2) statements -> statements statement .

    ENDMARKER       reduce using rule 2 (statements -> statements statement .)
    DEF             reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    CLASS           reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    WHILE           reduce using rule 2 (statements -> statements statement .)
    PASS            reduce using rule 2 (statements -> statements statement .)
    BREAK           reduce using rule 2 (statements -> statements statement .)
    CONTINUE        reduce using rule 2 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 2 (statements -> statements statement .)
    RETURN          reduce using rule 2 (statements -> statements statement .)
    DEL             reduce using rule 2 (statements -> statements statement .)
    GLOBAL          reduce using rule 2 (statements -> statements statement .)
    DEDENT          reduce using rule 2 (statements -> statements statement .)


state 30

    (6) simple_stmts -> simple_stmts SEMICOLON . simple_stmt
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    simple_stmt                    shift and go to state 67
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 31

    (7) simple_stmts -> simple_stmt NEWLINE .

    SEMICOLON       reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ENDMARKER       reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEF             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    IF              reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    CLASS           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    FOR             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    WHILE           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    PASS            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    BREAK           reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    CONTINUE        reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    IDENTIFIER      reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    RETURN          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEL             reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    GLOBAL          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ELIF            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    ELSE            reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)
    DEDENT          reduce using rule 7 (simple_stmts -> simple_stmt NEWLINE .)


state 32

    (39) function_def -> DEF IDENTIFIER . L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> DEF IDENTIFIER . L_PARENTHESIS R_PARENTHESIS COLON block

    L_PARENTHESIS   shift and go to state 68


state 33

    (20) assignment -> IDENTIFIER augmentation_assignment . expressions
    (21) assignment -> IDENTIFIER augmentation_assignment . IDENTIFIER
    (53) expressions -> . expressions COMMA expression
    (54) expressions -> . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 69
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 100 (empty -> .) ]

    expressions                    shift and go to state 70
    expression                     shift and go to state 63
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 34

    (22) augmentation_assignment -> SUM_ASSIGNMENT .

    IDENTIFIER      reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    NOT             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    SUM             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    COMMA           reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    IF              reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    OR              reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    AND             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    BITWISE_OR      reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    EQUALITY        reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    INEQUALITY      reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    GREATER_EQUAL   reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    LESSER_EQUAL    reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    GREATER         reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    LESSER          reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    IS              reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    IN              reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    BITWISE_AND     reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    L_SHIFT         reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    R_SHIFT         reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    PRODUCT         reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    DIVISION        reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    INTEGER_DIVISION reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    MODULUS         reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    NEWLINE         reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    SEMICOLON       reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    ENDMARKER       reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    DEF             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    CLASS           reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    FOR             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    WHILE           reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    PASS            reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    BREAK           reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    CONTINUE        reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    RETURN          reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    DEL             reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    GLOBAL          reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    ELIF            reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    ELSE            reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)
    DEDENT          reduce using rule 22 (augmentation_assignment -> SUM_ASSIGNMENT .)


state 35

    (23) augmentation_assignment -> SUBTRACTION_ASSIGNMENT .

    IDENTIFIER      reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    NOT             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    SUM             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    COMMA           reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    IF              reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    OR              reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    AND             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    BITWISE_OR      reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    EQUALITY        reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    INEQUALITY      reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    GREATER_EQUAL   reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    LESSER_EQUAL    reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    GREATER         reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    LESSER          reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    IS              reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    IN              reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    BITWISE_AND     reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    L_SHIFT         reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    R_SHIFT         reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    PRODUCT         reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    DIVISION        reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    INTEGER_DIVISION reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    MODULUS         reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    NEWLINE         reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    SEMICOLON       reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    ENDMARKER       reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    DEF             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    CLASS           reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    FOR             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    WHILE           reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    PASS            reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    BREAK           reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    CONTINUE        reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    RETURN          reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    DEL             reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    GLOBAL          reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    ELIF            reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    ELSE            reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)
    DEDENT          reduce using rule 23 (augmentation_assignment -> SUBTRACTION_ASSIGNMENT .)


state 36

    (24) augmentation_assignment -> PRODUCT_ASSIGNMENT .

    IDENTIFIER      reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    NOT             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    SUM             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    COMMA           reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    IF              reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    OR              reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    AND             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    BITWISE_OR      reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    EQUALITY        reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    INEQUALITY      reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    GREATER_EQUAL   reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    LESSER_EQUAL    reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    GREATER         reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    LESSER          reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    IS              reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    IN              reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    BITWISE_AND     reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    L_SHIFT         reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    R_SHIFT         reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    PRODUCT         reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    DIVISION        reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    INTEGER_DIVISION reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    MODULUS         reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    NEWLINE         reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    SEMICOLON       reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    ENDMARKER       reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    DEF             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    CLASS           reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    FOR             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    WHILE           reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    PASS            reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    BREAK           reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    CONTINUE        reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    RETURN          reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    DEL             reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    GLOBAL          reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    ELIF            reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    ELSE            reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)
    DEDENT          reduce using rule 24 (augmentation_assignment -> PRODUCT_ASSIGNMENT .)


state 37

    (25) augmentation_assignment -> DIVISION_ASSIGNMENT .

    IDENTIFIER      reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    NOT             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    SUM             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    COMMA           reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    IF              reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    OR              reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    AND             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    BITWISE_OR      reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    EQUALITY        reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    INEQUALITY      reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    GREATER_EQUAL   reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    LESSER_EQUAL    reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    GREATER         reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    LESSER          reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    IS              reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    IN              reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    BITWISE_AND     reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    L_SHIFT         reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    R_SHIFT         reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    PRODUCT         reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    DIVISION        reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    INTEGER_DIVISION reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    MODULUS         reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    NEWLINE         reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    SEMICOLON       reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    ENDMARKER       reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    DEF             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    CLASS           reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    FOR             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    WHILE           reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    PASS            reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    BREAK           reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    CONTINUE        reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    RETURN          reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    DEL             reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    GLOBAL          reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    ELIF            reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    ELSE            reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)
    DEDENT          reduce using rule 25 (augmentation_assignment -> DIVISION_ASSIGNMENT .)


state 38

    (26) augmentation_assignment -> MODULUS_ASSIGNMENT .

    IDENTIFIER      reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    NOT             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    SUM             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    COMMA           reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    IF              reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    OR              reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    AND             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    BITWISE_OR      reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    EQUALITY        reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    INEQUALITY      reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    GREATER_EQUAL   reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    LESSER_EQUAL    reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    GREATER         reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    LESSER          reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    IS              reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    IN              reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    BITWISE_AND     reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    L_SHIFT         reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    R_SHIFT         reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    PRODUCT         reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    DIVISION        reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    INTEGER_DIVISION reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    MODULUS         reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    NEWLINE         reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    SEMICOLON       reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    ENDMARKER       reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    DEF             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    CLASS           reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    FOR             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    WHILE           reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    PASS            reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    BREAK           reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    CONTINUE        reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    RETURN          reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    DEL             reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    GLOBAL          reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    ELIF            reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    ELSE            reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)
    DEDENT          reduce using rule 26 (augmentation_assignment -> MODULUS_ASSIGNMENT .)


state 39

    (27) augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .

    IDENTIFIER      reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    NOT             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    SUM             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    COMMA           reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    IF              reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    OR              reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    AND             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    BITWISE_OR      reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    EQUALITY        reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    INEQUALITY      reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    GREATER_EQUAL   reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    LESSER_EQUAL    reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    GREATER         reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    LESSER          reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    IS              reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    IN              reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    BITWISE_AND     reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    L_SHIFT         reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    R_SHIFT         reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    PRODUCT         reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    DIVISION        reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    INTEGER_DIVISION reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    MODULUS         reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    NEWLINE         reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    SEMICOLON       reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    ENDMARKER       reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    DEF             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    CLASS           reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    FOR             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    WHILE           reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    PASS            reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    BREAK           reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    CONTINUE        reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    RETURN          reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    DEL             reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    GLOBAL          reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    ELIF            reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    ELSE            reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)
    DEDENT          reduce using rule 27 (augmentation_assignment -> EXPONENTIATION_ASSIGNMENT .)


state 40

    (28) augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .

    IDENTIFIER      reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    NOT             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    SUM             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    SUBTRACTION     reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    COMMA           reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    IF              reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    OR              reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    AND             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    BITWISE_OR      reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    EQUALITY        reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    INEQUALITY      reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    GREATER_EQUAL   reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    LESSER_EQUAL    reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    GREATER         reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    LESSER          reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    IS              reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    IN              reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    BITWISE_AND     reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    L_SHIFT         reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    R_SHIFT         reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    PRODUCT         reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    DIVISION        reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    INTEGER_DIVISION reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    MODULUS         reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    NEWLINE         reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    SEMICOLON       reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    ENDMARKER       reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    DEF             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    CLASS           reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    FOR             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    WHILE           reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    PASS            reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    BREAK           reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    CONTINUE        reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    RETURN          reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    DEL             reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    GLOBAL          reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    ELIF            reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    ELSE            reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)
    DEDENT          reduce using rule 28 (augmentation_assignment -> INTEGER_DIVISION_ASSIGNMENT .)


state 41

    (43) if_stmt -> IF named_expression . COLON block elif_stmt
    (44) if_stmt -> IF named_expression . COLON block else_block
    (45) if_stmt -> IF named_expression . COLON block

    COLON           shift and go to state 71


state 42

    (63) named_expression -> expression .

    COLON           reduce using rule 63 (named_expression -> expression .)


state 43

    (55) expression -> disjunction .
    (56) expression -> disjunction . IF disjunction ELSE expression

  ! shift/reduce conflict for IF resolved as shift
    COLON           reduce using rule 55 (expression -> disjunction .)
    COMMA           reduce using rule 55 (expression -> disjunction .)
    NEWLINE         reduce using rule 55 (expression -> disjunction .)
    SEMICOLON       reduce using rule 55 (expression -> disjunction .)
    ENDMARKER       reduce using rule 55 (expression -> disjunction .)
    DEF             reduce using rule 55 (expression -> disjunction .)
    CLASS           reduce using rule 55 (expression -> disjunction .)
    FOR             reduce using rule 55 (expression -> disjunction .)
    WHILE           reduce using rule 55 (expression -> disjunction .)
    PASS            reduce using rule 55 (expression -> disjunction .)
    BREAK           reduce using rule 55 (expression -> disjunction .)
    CONTINUE        reduce using rule 55 (expression -> disjunction .)
    IDENTIFIER      reduce using rule 55 (expression -> disjunction .)
    RETURN          reduce using rule 55 (expression -> disjunction .)
    DEL             reduce using rule 55 (expression -> disjunction .)
    GLOBAL          reduce using rule 55 (expression -> disjunction .)
    ELIF            reduce using rule 55 (expression -> disjunction .)
    ELSE            reduce using rule 55 (expression -> disjunction .)
    DEDENT          reduce using rule 55 (expression -> disjunction .)
    IF              shift and go to state 72

  ! IF              [ reduce using rule 55 (expression -> disjunction .) ]


state 44

    (57) disjunction -> conjunction .
    (58) disjunction -> conjunction . OR disjunction

    IF              reduce using rule 57 (disjunction -> conjunction .)
    COLON           reduce using rule 57 (disjunction -> conjunction .)
    COMMA           reduce using rule 57 (disjunction -> conjunction .)
    NEWLINE         reduce using rule 57 (disjunction -> conjunction .)
    SEMICOLON       reduce using rule 57 (disjunction -> conjunction .)
    ENDMARKER       reduce using rule 57 (disjunction -> conjunction .)
    DEF             reduce using rule 57 (disjunction -> conjunction .)
    CLASS           reduce using rule 57 (disjunction -> conjunction .)
    FOR             reduce using rule 57 (disjunction -> conjunction .)
    WHILE           reduce using rule 57 (disjunction -> conjunction .)
    PASS            reduce using rule 57 (disjunction -> conjunction .)
    BREAK           reduce using rule 57 (disjunction -> conjunction .)
    CONTINUE        reduce using rule 57 (disjunction -> conjunction .)
    IDENTIFIER      reduce using rule 57 (disjunction -> conjunction .)
    RETURN          reduce using rule 57 (disjunction -> conjunction .)
    DEL             reduce using rule 57 (disjunction -> conjunction .)
    GLOBAL          reduce using rule 57 (disjunction -> conjunction .)
    ELIF            reduce using rule 57 (disjunction -> conjunction .)
    ELSE            reduce using rule 57 (disjunction -> conjunction .)
    DEDENT          reduce using rule 57 (disjunction -> conjunction .)
    OR              shift and go to state 73


state 45

    (59) conjunction -> inversion .
    (60) conjunction -> inversion . AND inversion

    OR              reduce using rule 59 (conjunction -> inversion .)
    IF              reduce using rule 59 (conjunction -> inversion .)
    COLON           reduce using rule 59 (conjunction -> inversion .)
    COMMA           reduce using rule 59 (conjunction -> inversion .)
    NEWLINE         reduce using rule 59 (conjunction -> inversion .)
    SEMICOLON       reduce using rule 59 (conjunction -> inversion .)
    ENDMARKER       reduce using rule 59 (conjunction -> inversion .)
    DEF             reduce using rule 59 (conjunction -> inversion .)
    CLASS           reduce using rule 59 (conjunction -> inversion .)
    FOR             reduce using rule 59 (conjunction -> inversion .)
    WHILE           reduce using rule 59 (conjunction -> inversion .)
    PASS            reduce using rule 59 (conjunction -> inversion .)
    BREAK           reduce using rule 59 (conjunction -> inversion .)
    CONTINUE        reduce using rule 59 (conjunction -> inversion .)
    IDENTIFIER      reduce using rule 59 (conjunction -> inversion .)
    RETURN          reduce using rule 59 (conjunction -> inversion .)
    DEL             reduce using rule 59 (conjunction -> inversion .)
    GLOBAL          reduce using rule 59 (conjunction -> inversion .)
    ELIF            reduce using rule 59 (conjunction -> inversion .)
    ELSE            reduce using rule 59 (conjunction -> inversion .)
    DEDENT          reduce using rule 59 (conjunction -> inversion .)
    AND             shift and go to state 74


state 46

    (61) inversion -> NOT . inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    inversion                      shift and go to state 75
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 47

    (62) inversion -> comparison .

    AND             reduce using rule 62 (inversion -> comparison .)
    OR              reduce using rule 62 (inversion -> comparison .)
    IF              reduce using rule 62 (inversion -> comparison .)
    COLON           reduce using rule 62 (inversion -> comparison .)
    COMMA           reduce using rule 62 (inversion -> comparison .)
    NEWLINE         reduce using rule 62 (inversion -> comparison .)
    SEMICOLON       reduce using rule 62 (inversion -> comparison .)
    ENDMARKER       reduce using rule 62 (inversion -> comparison .)
    DEF             reduce using rule 62 (inversion -> comparison .)
    CLASS           reduce using rule 62 (inversion -> comparison .)
    FOR             reduce using rule 62 (inversion -> comparison .)
    WHILE           reduce using rule 62 (inversion -> comparison .)
    PASS            reduce using rule 62 (inversion -> comparison .)
    BREAK           reduce using rule 62 (inversion -> comparison .)
    CONTINUE        reduce using rule 62 (inversion -> comparison .)
    IDENTIFIER      reduce using rule 62 (inversion -> comparison .)
    RETURN          reduce using rule 62 (inversion -> comparison .)
    DEL             reduce using rule 62 (inversion -> comparison .)
    GLOBAL          reduce using rule 62 (inversion -> comparison .)
    ELIF            reduce using rule 62 (inversion -> comparison .)
    ELSE            reduce using rule 62 (inversion -> comparison .)
    DEDENT          reduce using rule 62 (inversion -> comparison .)


state 48

    (64) comparison -> bitwise_or .
    (65) comparison -> bitwise_or . compare_op_list
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor
    (66) compare_op_list -> . compare_op
    (67) compare_op_list -> . compare_op_list compare_op
    (68) compare_op -> . EQUALITY bitwise_or
    (69) compare_op -> . INEQUALITY bitwise_or
    (70) compare_op -> . GREATER_EQUAL bitwise_or
    (71) compare_op -> . LESSER_EQUAL bitwise_or
    (72) compare_op -> . GREATER bitwise_or
    (73) compare_op -> . LESSER bitwise_or
    (74) compare_op -> . NOT IN bitwise_or
    (75) compare_op -> . IS NOT bitwise_or
    (76) compare_op -> . IN bitwise_or
    (77) compare_op -> . IS bitwise_or

    AND             reduce using rule 64 (comparison -> bitwise_or .)
    OR              reduce using rule 64 (comparison -> bitwise_or .)
    IF              reduce using rule 64 (comparison -> bitwise_or .)
    COLON           reduce using rule 64 (comparison -> bitwise_or .)
    COMMA           reduce using rule 64 (comparison -> bitwise_or .)
    NEWLINE         reduce using rule 64 (comparison -> bitwise_or .)
    SEMICOLON       reduce using rule 64 (comparison -> bitwise_or .)
    ENDMARKER       reduce using rule 64 (comparison -> bitwise_or .)
    DEF             reduce using rule 64 (comparison -> bitwise_or .)
    CLASS           reduce using rule 64 (comparison -> bitwise_or .)
    FOR             reduce using rule 64 (comparison -> bitwise_or .)
    WHILE           reduce using rule 64 (comparison -> bitwise_or .)
    PASS            reduce using rule 64 (comparison -> bitwise_or .)
    BREAK           reduce using rule 64 (comparison -> bitwise_or .)
    CONTINUE        reduce using rule 64 (comparison -> bitwise_or .)
    IDENTIFIER      reduce using rule 64 (comparison -> bitwise_or .)
    RETURN          reduce using rule 64 (comparison -> bitwise_or .)
    DEL             reduce using rule 64 (comparison -> bitwise_or .)
    GLOBAL          reduce using rule 64 (comparison -> bitwise_or .)
    ELIF            reduce using rule 64 (comparison -> bitwise_or .)
    ELSE            reduce using rule 64 (comparison -> bitwise_or .)
    DEDENT          reduce using rule 64 (comparison -> bitwise_or .)
    BITWISE_OR      shift and go to state 77
    EQUALITY        shift and go to state 79
    INEQUALITY      shift and go to state 80
    GREATER_EQUAL   shift and go to state 81
    LESSER_EQUAL    shift and go to state 82
    GREATER         shift and go to state 83
    LESSER          shift and go to state 84
    NOT             shift and go to state 85
    IS              shift and go to state 87
    IN              shift and go to state 86

    compare_op_list                shift and go to state 76
    compare_op                     shift and go to state 78

state 49

    (79) bitwise_or -> bitwise_xor .
    (80) bitwise_xor -> bitwise_xor . empty bitwise_and
    (100) empty -> .

  ! reduce/reduce conflict for BITWISE_OR resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for GREATER resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for LESSER resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for NOT resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for IS resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for IN resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for AND resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for OR resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for IF resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for COLON resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for COMMA resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for ENDMARKER resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for DEF resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for CLASS resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for FOR resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for WHILE resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for PASS resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for BREAK resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for RETURN resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for DEL resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for GLOBAL resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for ELIF resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for ELSE resolved using rule 79 (bitwise_or -> bitwise_xor .)
  ! reduce/reduce conflict for DEDENT resolved using rule 79 (bitwise_or -> bitwise_xor .)
    BITWISE_OR      reduce using rule 79 (bitwise_or -> bitwise_xor .)
    EQUALITY        reduce using rule 79 (bitwise_or -> bitwise_xor .)
    INEQUALITY      reduce using rule 79 (bitwise_or -> bitwise_xor .)
    GREATER_EQUAL   reduce using rule 79 (bitwise_or -> bitwise_xor .)
    LESSER_EQUAL    reduce using rule 79 (bitwise_or -> bitwise_xor .)
    GREATER         reduce using rule 79 (bitwise_or -> bitwise_xor .)
    LESSER          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    NOT             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IS              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IN              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    AND             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    OR              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IF              reduce using rule 79 (bitwise_or -> bitwise_xor .)
    COLON           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    COMMA           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    NEWLINE         reduce using rule 79 (bitwise_or -> bitwise_xor .)
    SEMICOLON       reduce using rule 79 (bitwise_or -> bitwise_xor .)
    ENDMARKER       reduce using rule 79 (bitwise_or -> bitwise_xor .)
    DEF             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    CLASS           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    FOR             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    WHILE           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    PASS            reduce using rule 79 (bitwise_or -> bitwise_xor .)
    BREAK           reduce using rule 79 (bitwise_or -> bitwise_xor .)
    CONTINUE        reduce using rule 79 (bitwise_or -> bitwise_xor .)
    IDENTIFIER      reduce using rule 79 (bitwise_or -> bitwise_xor .)
    RETURN          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    DEL             reduce using rule 79 (bitwise_or -> bitwise_xor .)
    GLOBAL          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    ELIF            reduce using rule 79 (bitwise_or -> bitwise_xor .)
    ELSE            reduce using rule 79 (bitwise_or -> bitwise_xor .)
    DEDENT          reduce using rule 79 (bitwise_or -> bitwise_xor .)
    SUM             reduce using rule 100 (empty -> .)
    SUBTRACTION     reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)

  ! BITWISE_OR      [ reduce using rule 100 (empty -> .) ]
  ! EQUALITY        [ reduce using rule 100 (empty -> .) ]
  ! INEQUALITY      [ reduce using rule 100 (empty -> .) ]
  ! GREATER_EQUAL   [ reduce using rule 100 (empty -> .) ]
  ! LESSER_EQUAL    [ reduce using rule 100 (empty -> .) ]
  ! GREATER         [ reduce using rule 100 (empty -> .) ]
  ! LESSER          [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]
  ! IS              [ reduce using rule 100 (empty -> .) ]
  ! IN              [ reduce using rule 100 (empty -> .) ]
  ! AND             [ reduce using rule 100 (empty -> .) ]
  ! OR              [ reduce using rule 100 (empty -> .) ]
  ! IF              [ reduce using rule 100 (empty -> .) ]
  ! COLON           [ reduce using rule 100 (empty -> .) ]
  ! COMMA           [ reduce using rule 100 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 100 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 100 (empty -> .) ]
  ! ENDMARKER       [ reduce using rule 100 (empty -> .) ]
  ! DEF             [ reduce using rule 100 (empty -> .) ]
  ! CLASS           [ reduce using rule 100 (empty -> .) ]
  ! FOR             [ reduce using rule 100 (empty -> .) ]
  ! WHILE           [ reduce using rule 100 (empty -> .) ]
  ! PASS            [ reduce using rule 100 (empty -> .) ]
  ! BREAK           [ reduce using rule 100 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 100 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 100 (empty -> .) ]
  ! RETURN          [ reduce using rule 100 (empty -> .) ]
  ! DEL             [ reduce using rule 100 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 100 (empty -> .) ]
  ! ELIF            [ reduce using rule 100 (empty -> .) ]
  ! ELSE            [ reduce using rule 100 (empty -> .) ]
  ! DEDENT          [ reduce using rule 100 (empty -> .) ]

    empty                          shift and go to state 88

state 50

    (98) power -> empty .

    PRODUCT         reduce using rule 98 (power -> empty .)
    DIVISION        reduce using rule 98 (power -> empty .)
    INTEGER_DIVISION reduce using rule 98 (power -> empty .)
    MODULUS         reduce using rule 98 (power -> empty .)
    SUM             reduce using rule 98 (power -> empty .)
    SUBTRACTION     reduce using rule 98 (power -> empty .)
    L_SHIFT         reduce using rule 98 (power -> empty .)
    R_SHIFT         reduce using rule 98 (power -> empty .)
    BITWISE_AND     reduce using rule 98 (power -> empty .)
    BITWISE_OR      reduce using rule 98 (power -> empty .)
    EQUALITY        reduce using rule 98 (power -> empty .)
    INEQUALITY      reduce using rule 98 (power -> empty .)
    GREATER_EQUAL   reduce using rule 98 (power -> empty .)
    LESSER_EQUAL    reduce using rule 98 (power -> empty .)
    GREATER         reduce using rule 98 (power -> empty .)
    LESSER          reduce using rule 98 (power -> empty .)
    NOT             reduce using rule 98 (power -> empty .)
    IS              reduce using rule 98 (power -> empty .)
    IN              reduce using rule 98 (power -> empty .)
    AND             reduce using rule 98 (power -> empty .)
    OR              reduce using rule 98 (power -> empty .)
    IF              reduce using rule 98 (power -> empty .)
    COLON           reduce using rule 98 (power -> empty .)
    COMMA           reduce using rule 98 (power -> empty .)
    NEWLINE         reduce using rule 98 (power -> empty .)
    SEMICOLON       reduce using rule 98 (power -> empty .)
    ENDMARKER       reduce using rule 98 (power -> empty .)
    DEF             reduce using rule 98 (power -> empty .)
    CLASS           reduce using rule 98 (power -> empty .)
    FOR             reduce using rule 98 (power -> empty .)
    WHILE           reduce using rule 98 (power -> empty .)
    PASS            reduce using rule 98 (power -> empty .)
    BREAK           reduce using rule 98 (power -> empty .)
    CONTINUE        reduce using rule 98 (power -> empty .)
    IDENTIFIER      reduce using rule 98 (power -> empty .)
    RETURN          reduce using rule 98 (power -> empty .)
    DEL             reduce using rule 98 (power -> empty .)
    GLOBAL          reduce using rule 98 (power -> empty .)
    ELIF            reduce using rule 98 (power -> empty .)
    ELSE            reduce using rule 98 (power -> empty .)
    DEDENT          reduce using rule 98 (power -> empty .)


state 51

    (81) bitwise_xor -> bitwise_and .
    (82) bitwise_and -> bitwise_and . BITWISE_AND shift_expr

  ! shift/reduce conflict for BITWISE_AND resolved as shift
    SUM             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    SUBTRACTION     reduce using rule 81 (bitwise_xor -> bitwise_and .)
    L_SHIFT         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    R_SHIFT         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    PRODUCT         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    DIVISION        reduce using rule 81 (bitwise_xor -> bitwise_and .)
    INTEGER_DIVISION reduce using rule 81 (bitwise_xor -> bitwise_and .)
    MODULUS         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    BITWISE_OR      reduce using rule 81 (bitwise_xor -> bitwise_and .)
    EQUALITY        reduce using rule 81 (bitwise_xor -> bitwise_and .)
    INEQUALITY      reduce using rule 81 (bitwise_xor -> bitwise_and .)
    GREATER_EQUAL   reduce using rule 81 (bitwise_xor -> bitwise_and .)
    LESSER_EQUAL    reduce using rule 81 (bitwise_xor -> bitwise_and .)
    GREATER         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    LESSER          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    NOT             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IS              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IN              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    AND             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    OR              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IF              reduce using rule 81 (bitwise_xor -> bitwise_and .)
    COLON           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    COMMA           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    NEWLINE         reduce using rule 81 (bitwise_xor -> bitwise_and .)
    SEMICOLON       reduce using rule 81 (bitwise_xor -> bitwise_and .)
    ENDMARKER       reduce using rule 81 (bitwise_xor -> bitwise_and .)
    DEF             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    CLASS           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    FOR             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    WHILE           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    PASS            reduce using rule 81 (bitwise_xor -> bitwise_and .)
    BREAK           reduce using rule 81 (bitwise_xor -> bitwise_and .)
    CONTINUE        reduce using rule 81 (bitwise_xor -> bitwise_and .)
    IDENTIFIER      reduce using rule 81 (bitwise_xor -> bitwise_and .)
    RETURN          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    DEL             reduce using rule 81 (bitwise_xor -> bitwise_and .)
    GLOBAL          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    ELIF            reduce using rule 81 (bitwise_xor -> bitwise_and .)
    ELSE            reduce using rule 81 (bitwise_xor -> bitwise_and .)
    DEDENT          reduce using rule 81 (bitwise_xor -> bitwise_and .)
    BITWISE_AND     shift and go to state 89

  ! BITWISE_AND     [ reduce using rule 81 (bitwise_xor -> bitwise_and .) ]


state 52

    (83) bitwise_and -> shift_expr .
    (84) shift_expr -> shift_expr . L_SHIFT sum
    (85) shift_expr -> shift_expr . R_SHIFT sum

  ! shift/reduce conflict for L_SHIFT resolved as shift
  ! shift/reduce conflict for R_SHIFT resolved as shift
    BITWISE_AND     reduce using rule 83 (bitwise_and -> shift_expr .)
    SUM             reduce using rule 83 (bitwise_and -> shift_expr .)
    SUBTRACTION     reduce using rule 83 (bitwise_and -> shift_expr .)
    PRODUCT         reduce using rule 83 (bitwise_and -> shift_expr .)
    DIVISION        reduce using rule 83 (bitwise_and -> shift_expr .)
    INTEGER_DIVISION reduce using rule 83 (bitwise_and -> shift_expr .)
    MODULUS         reduce using rule 83 (bitwise_and -> shift_expr .)
    BITWISE_OR      reduce using rule 83 (bitwise_and -> shift_expr .)
    EQUALITY        reduce using rule 83 (bitwise_and -> shift_expr .)
    INEQUALITY      reduce using rule 83 (bitwise_and -> shift_expr .)
    GREATER_EQUAL   reduce using rule 83 (bitwise_and -> shift_expr .)
    LESSER_EQUAL    reduce using rule 83 (bitwise_and -> shift_expr .)
    GREATER         reduce using rule 83 (bitwise_and -> shift_expr .)
    LESSER          reduce using rule 83 (bitwise_and -> shift_expr .)
    NOT             reduce using rule 83 (bitwise_and -> shift_expr .)
    IS              reduce using rule 83 (bitwise_and -> shift_expr .)
    IN              reduce using rule 83 (bitwise_and -> shift_expr .)
    AND             reduce using rule 83 (bitwise_and -> shift_expr .)
    OR              reduce using rule 83 (bitwise_and -> shift_expr .)
    IF              reduce using rule 83 (bitwise_and -> shift_expr .)
    COLON           reduce using rule 83 (bitwise_and -> shift_expr .)
    COMMA           reduce using rule 83 (bitwise_and -> shift_expr .)
    NEWLINE         reduce using rule 83 (bitwise_and -> shift_expr .)
    SEMICOLON       reduce using rule 83 (bitwise_and -> shift_expr .)
    ENDMARKER       reduce using rule 83 (bitwise_and -> shift_expr .)
    DEF             reduce using rule 83 (bitwise_and -> shift_expr .)
    CLASS           reduce using rule 83 (bitwise_and -> shift_expr .)
    FOR             reduce using rule 83 (bitwise_and -> shift_expr .)
    WHILE           reduce using rule 83 (bitwise_and -> shift_expr .)
    PASS            reduce using rule 83 (bitwise_and -> shift_expr .)
    BREAK           reduce using rule 83 (bitwise_and -> shift_expr .)
    CONTINUE        reduce using rule 83 (bitwise_and -> shift_expr .)
    IDENTIFIER      reduce using rule 83 (bitwise_and -> shift_expr .)
    RETURN          reduce using rule 83 (bitwise_and -> shift_expr .)
    DEL             reduce using rule 83 (bitwise_and -> shift_expr .)
    GLOBAL          reduce using rule 83 (bitwise_and -> shift_expr .)
    ELIF            reduce using rule 83 (bitwise_and -> shift_expr .)
    ELSE            reduce using rule 83 (bitwise_and -> shift_expr .)
    DEDENT          reduce using rule 83 (bitwise_and -> shift_expr .)
    L_SHIFT         shift and go to state 90
    R_SHIFT         shift and go to state 91

  ! L_SHIFT         [ reduce using rule 83 (bitwise_and -> shift_expr .) ]
  ! R_SHIFT         [ reduce using rule 83 (bitwise_and -> shift_expr .) ]


state 53

    (86) shift_expr -> sum .
    (87) sum -> sum . SUM term
    (88) sum -> sum . SUBTRACTION term

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    L_SHIFT         reduce using rule 86 (shift_expr -> sum .)
    R_SHIFT         reduce using rule 86 (shift_expr -> sum .)
    BITWISE_AND     reduce using rule 86 (shift_expr -> sum .)
    PRODUCT         reduce using rule 86 (shift_expr -> sum .)
    DIVISION        reduce using rule 86 (shift_expr -> sum .)
    INTEGER_DIVISION reduce using rule 86 (shift_expr -> sum .)
    MODULUS         reduce using rule 86 (shift_expr -> sum .)
    BITWISE_OR      reduce using rule 86 (shift_expr -> sum .)
    EQUALITY        reduce using rule 86 (shift_expr -> sum .)
    INEQUALITY      reduce using rule 86 (shift_expr -> sum .)
    GREATER_EQUAL   reduce using rule 86 (shift_expr -> sum .)
    LESSER_EQUAL    reduce using rule 86 (shift_expr -> sum .)
    GREATER         reduce using rule 86 (shift_expr -> sum .)
    LESSER          reduce using rule 86 (shift_expr -> sum .)
    NOT             reduce using rule 86 (shift_expr -> sum .)
    IS              reduce using rule 86 (shift_expr -> sum .)
    IN              reduce using rule 86 (shift_expr -> sum .)
    AND             reduce using rule 86 (shift_expr -> sum .)
    OR              reduce using rule 86 (shift_expr -> sum .)
    IF              reduce using rule 86 (shift_expr -> sum .)
    COLON           reduce using rule 86 (shift_expr -> sum .)
    COMMA           reduce using rule 86 (shift_expr -> sum .)
    NEWLINE         reduce using rule 86 (shift_expr -> sum .)
    SEMICOLON       reduce using rule 86 (shift_expr -> sum .)
    ENDMARKER       reduce using rule 86 (shift_expr -> sum .)
    DEF             reduce using rule 86 (shift_expr -> sum .)
    CLASS           reduce using rule 86 (shift_expr -> sum .)
    FOR             reduce using rule 86 (shift_expr -> sum .)
    WHILE           reduce using rule 86 (shift_expr -> sum .)
    PASS            reduce using rule 86 (shift_expr -> sum .)
    BREAK           reduce using rule 86 (shift_expr -> sum .)
    CONTINUE        reduce using rule 86 (shift_expr -> sum .)
    IDENTIFIER      reduce using rule 86 (shift_expr -> sum .)
    RETURN          reduce using rule 86 (shift_expr -> sum .)
    DEL             reduce using rule 86 (shift_expr -> sum .)
    GLOBAL          reduce using rule 86 (shift_expr -> sum .)
    ELIF            reduce using rule 86 (shift_expr -> sum .)
    ELSE            reduce using rule 86 (shift_expr -> sum .)
    DEDENT          reduce using rule 86 (shift_expr -> sum .)
    SUM             shift and go to state 92
    SUBTRACTION     shift and go to state 93

  ! SUM             [ reduce using rule 86 (shift_expr -> sum .) ]
  ! SUBTRACTION     [ reduce using rule 86 (shift_expr -> sum .) ]


state 54

    (95) factor -> SUM . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    factor                         shift and go to state 94
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 55

    (89) sum -> term .
    (90) term -> term . PRODUCT factor
    (91) term -> term . DIVISION factor
    (92) term -> term . INTEGER_DIVISION factor
    (93) term -> term . MODULUS factor

  ! shift/reduce conflict for PRODUCT resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for INTEGER_DIVISION resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
    SUM             reduce using rule 89 (sum -> term .)
    SUBTRACTION     reduce using rule 89 (sum -> term .)
    L_SHIFT         reduce using rule 89 (sum -> term .)
    R_SHIFT         reduce using rule 89 (sum -> term .)
    BITWISE_AND     reduce using rule 89 (sum -> term .)
    BITWISE_OR      reduce using rule 89 (sum -> term .)
    EQUALITY        reduce using rule 89 (sum -> term .)
    INEQUALITY      reduce using rule 89 (sum -> term .)
    GREATER_EQUAL   reduce using rule 89 (sum -> term .)
    LESSER_EQUAL    reduce using rule 89 (sum -> term .)
    GREATER         reduce using rule 89 (sum -> term .)
    LESSER          reduce using rule 89 (sum -> term .)
    NOT             reduce using rule 89 (sum -> term .)
    IS              reduce using rule 89 (sum -> term .)
    IN              reduce using rule 89 (sum -> term .)
    AND             reduce using rule 89 (sum -> term .)
    OR              reduce using rule 89 (sum -> term .)
    IF              reduce using rule 89 (sum -> term .)
    COLON           reduce using rule 89 (sum -> term .)
    COMMA           reduce using rule 89 (sum -> term .)
    NEWLINE         reduce using rule 89 (sum -> term .)
    SEMICOLON       reduce using rule 89 (sum -> term .)
    ENDMARKER       reduce using rule 89 (sum -> term .)
    DEF             reduce using rule 89 (sum -> term .)
    CLASS           reduce using rule 89 (sum -> term .)
    FOR             reduce using rule 89 (sum -> term .)
    WHILE           reduce using rule 89 (sum -> term .)
    PASS            reduce using rule 89 (sum -> term .)
    BREAK           reduce using rule 89 (sum -> term .)
    CONTINUE        reduce using rule 89 (sum -> term .)
    IDENTIFIER      reduce using rule 89 (sum -> term .)
    RETURN          reduce using rule 89 (sum -> term .)
    DEL             reduce using rule 89 (sum -> term .)
    GLOBAL          reduce using rule 89 (sum -> term .)
    ELIF            reduce using rule 89 (sum -> term .)
    ELSE            reduce using rule 89 (sum -> term .)
    DEDENT          reduce using rule 89 (sum -> term .)
    PRODUCT         shift and go to state 95
    DIVISION        shift and go to state 96
    INTEGER_DIVISION shift and go to state 97
    MODULUS         shift and go to state 98

  ! PRODUCT         [ reduce using rule 89 (sum -> term .) ]
  ! DIVISION        [ reduce using rule 89 (sum -> term .) ]
  ! INTEGER_DIVISION [ reduce using rule 89 (sum -> term .) ]
  ! MODULUS         [ reduce using rule 89 (sum -> term .) ]


state 56

    (96) factor -> SUBTRACTION . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    factor                         shift and go to state 99
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 57

    (94) term -> factor .

    PRODUCT         reduce using rule 94 (term -> factor .)
    DIVISION        reduce using rule 94 (term -> factor .)
    INTEGER_DIVISION reduce using rule 94 (term -> factor .)
    MODULUS         reduce using rule 94 (term -> factor .)
    SUM             reduce using rule 94 (term -> factor .)
    SUBTRACTION     reduce using rule 94 (term -> factor .)
    L_SHIFT         reduce using rule 94 (term -> factor .)
    R_SHIFT         reduce using rule 94 (term -> factor .)
    BITWISE_AND     reduce using rule 94 (term -> factor .)
    BITWISE_OR      reduce using rule 94 (term -> factor .)
    EQUALITY        reduce using rule 94 (term -> factor .)
    INEQUALITY      reduce using rule 94 (term -> factor .)
    GREATER_EQUAL   reduce using rule 94 (term -> factor .)
    LESSER_EQUAL    reduce using rule 94 (term -> factor .)
    GREATER         reduce using rule 94 (term -> factor .)
    LESSER          reduce using rule 94 (term -> factor .)
    NOT             reduce using rule 94 (term -> factor .)
    IS              reduce using rule 94 (term -> factor .)
    IN              reduce using rule 94 (term -> factor .)
    AND             reduce using rule 94 (term -> factor .)
    OR              reduce using rule 94 (term -> factor .)
    IF              reduce using rule 94 (term -> factor .)
    COLON           reduce using rule 94 (term -> factor .)
    COMMA           reduce using rule 94 (term -> factor .)
    NEWLINE         reduce using rule 94 (term -> factor .)
    SEMICOLON       reduce using rule 94 (term -> factor .)
    ENDMARKER       reduce using rule 94 (term -> factor .)
    DEF             reduce using rule 94 (term -> factor .)
    CLASS           reduce using rule 94 (term -> factor .)
    FOR             reduce using rule 94 (term -> factor .)
    WHILE           reduce using rule 94 (term -> factor .)
    PASS            reduce using rule 94 (term -> factor .)
    BREAK           reduce using rule 94 (term -> factor .)
    CONTINUE        reduce using rule 94 (term -> factor .)
    IDENTIFIER      reduce using rule 94 (term -> factor .)
    RETURN          reduce using rule 94 (term -> factor .)
    DEL             reduce using rule 94 (term -> factor .)
    GLOBAL          reduce using rule 94 (term -> factor .)
    ELIF            reduce using rule 94 (term -> factor .)
    ELSE            reduce using rule 94 (term -> factor .)
    DEDENT          reduce using rule 94 (term -> factor .)


state 58

    (97) factor -> power .

    PRODUCT         reduce using rule 97 (factor -> power .)
    DIVISION        reduce using rule 97 (factor -> power .)
    INTEGER_DIVISION reduce using rule 97 (factor -> power .)
    MODULUS         reduce using rule 97 (factor -> power .)
    SUM             reduce using rule 97 (factor -> power .)
    SUBTRACTION     reduce using rule 97 (factor -> power .)
    L_SHIFT         reduce using rule 97 (factor -> power .)
    R_SHIFT         reduce using rule 97 (factor -> power .)
    BITWISE_AND     reduce using rule 97 (factor -> power .)
    BITWISE_OR      reduce using rule 97 (factor -> power .)
    EQUALITY        reduce using rule 97 (factor -> power .)
    INEQUALITY      reduce using rule 97 (factor -> power .)
    GREATER_EQUAL   reduce using rule 97 (factor -> power .)
    LESSER_EQUAL    reduce using rule 97 (factor -> power .)
    GREATER         reduce using rule 97 (factor -> power .)
    LESSER          reduce using rule 97 (factor -> power .)
    NOT             reduce using rule 97 (factor -> power .)
    IS              reduce using rule 97 (factor -> power .)
    IN              reduce using rule 97 (factor -> power .)
    AND             reduce using rule 97 (factor -> power .)
    OR              reduce using rule 97 (factor -> power .)
    IF              reduce using rule 97 (factor -> power .)
    COLON           reduce using rule 97 (factor -> power .)
    COMMA           reduce using rule 97 (factor -> power .)
    NEWLINE         reduce using rule 97 (factor -> power .)
    SEMICOLON       reduce using rule 97 (factor -> power .)
    ENDMARKER       reduce using rule 97 (factor -> power .)
    DEF             reduce using rule 97 (factor -> power .)
    CLASS           reduce using rule 97 (factor -> power .)
    FOR             reduce using rule 97 (factor -> power .)
    WHILE           reduce using rule 97 (factor -> power .)
    PASS            reduce using rule 97 (factor -> power .)
    BREAK           reduce using rule 97 (factor -> power .)
    CONTINUE        reduce using rule 97 (factor -> power .)
    IDENTIFIER      reduce using rule 97 (factor -> power .)
    RETURN          reduce using rule 97 (factor -> power .)
    DEL             reduce using rule 97 (factor -> power .)
    GLOBAL          reduce using rule 97 (factor -> power .)
    ELIF            reduce using rule 97 (factor -> power .)
    ELSE            reduce using rule 97 (factor -> power .)
    DEDENT          reduce using rule 97 (factor -> power .)


state 59

    (36) class_def -> CLASS IDENTIFIER . COLON block
    (37) class_def -> CLASS IDENTIFIER . L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> CLASS IDENTIFIER . L_PARENTHESIS arguments R_PARENTHESIS COLON block

    COLON           shift and go to state 100
    L_PARENTHESIS   shift and go to state 101


state 60

    (51) for_stmt -> FOR IDENTIFIER . IN expressions COLON else_block
    (52) for_stmt -> FOR IDENTIFIER . IN expressions COLON block

    IN              shift and go to state 102


state 61

    (50) while_stmt -> WHILE named_expression . COLON block

    COLON           shift and go to state 103


state 62

    (29) return_stmt -> RETURN expressions .
    (53) expressions -> expressions . COMMA expression

    NEWLINE         reduce using rule 29 (return_stmt -> RETURN expressions .)
    SEMICOLON       reduce using rule 29 (return_stmt -> RETURN expressions .)
    ENDMARKER       reduce using rule 29 (return_stmt -> RETURN expressions .)
    DEF             reduce using rule 29 (return_stmt -> RETURN expressions .)
    IF              reduce using rule 29 (return_stmt -> RETURN expressions .)
    CLASS           reduce using rule 29 (return_stmt -> RETURN expressions .)
    FOR             reduce using rule 29 (return_stmt -> RETURN expressions .)
    WHILE           reduce using rule 29 (return_stmt -> RETURN expressions .)
    PASS            reduce using rule 29 (return_stmt -> RETURN expressions .)
    BREAK           reduce using rule 29 (return_stmt -> RETURN expressions .)
    CONTINUE        reduce using rule 29 (return_stmt -> RETURN expressions .)
    IDENTIFIER      reduce using rule 29 (return_stmt -> RETURN expressions .)
    RETURN          reduce using rule 29 (return_stmt -> RETURN expressions .)
    DEL             reduce using rule 29 (return_stmt -> RETURN expressions .)
    GLOBAL          reduce using rule 29 (return_stmt -> RETURN expressions .)
    ELIF            reduce using rule 29 (return_stmt -> RETURN expressions .)
    ELSE            reduce using rule 29 (return_stmt -> RETURN expressions .)
    DEDENT          reduce using rule 29 (return_stmt -> RETURN expressions .)
    COMMA           shift and go to state 104


state 63

    (54) expressions -> expression .

    COMMA           reduce using rule 54 (expressions -> expression .)
    NEWLINE         reduce using rule 54 (expressions -> expression .)
    SEMICOLON       reduce using rule 54 (expressions -> expression .)
    ENDMARKER       reduce using rule 54 (expressions -> expression .)
    DEF             reduce using rule 54 (expressions -> expression .)
    IF              reduce using rule 54 (expressions -> expression .)
    CLASS           reduce using rule 54 (expressions -> expression .)
    FOR             reduce using rule 54 (expressions -> expression .)
    WHILE           reduce using rule 54 (expressions -> expression .)
    PASS            reduce using rule 54 (expressions -> expression .)
    BREAK           reduce using rule 54 (expressions -> expression .)
    CONTINUE        reduce using rule 54 (expressions -> expression .)
    IDENTIFIER      reduce using rule 54 (expressions -> expression .)
    RETURN          reduce using rule 54 (expressions -> expression .)
    DEL             reduce using rule 54 (expressions -> expression .)
    GLOBAL          reduce using rule 54 (expressions -> expression .)
    ELIF            reduce using rule 54 (expressions -> expression .)
    ELSE            reduce using rule 54 (expressions -> expression .)
    DEDENT          reduce using rule 54 (expressions -> expression .)
    COLON           reduce using rule 54 (expressions -> expression .)


state 64

    (31) del_stmt -> DEL namelist .
    (32) namelist -> namelist . COMMA IDENTIFIER

    NEWLINE         reduce using rule 31 (del_stmt -> DEL namelist .)
    SEMICOLON       reduce using rule 31 (del_stmt -> DEL namelist .)
    ENDMARKER       reduce using rule 31 (del_stmt -> DEL namelist .)
    DEF             reduce using rule 31 (del_stmt -> DEL namelist .)
    IF              reduce using rule 31 (del_stmt -> DEL namelist .)
    CLASS           reduce using rule 31 (del_stmt -> DEL namelist .)
    FOR             reduce using rule 31 (del_stmt -> DEL namelist .)
    WHILE           reduce using rule 31 (del_stmt -> DEL namelist .)
    PASS            reduce using rule 31 (del_stmt -> DEL namelist .)
    BREAK           reduce using rule 31 (del_stmt -> DEL namelist .)
    CONTINUE        reduce using rule 31 (del_stmt -> DEL namelist .)
    IDENTIFIER      reduce using rule 31 (del_stmt -> DEL namelist .)
    RETURN          reduce using rule 31 (del_stmt -> DEL namelist .)
    DEL             reduce using rule 31 (del_stmt -> DEL namelist .)
    GLOBAL          reduce using rule 31 (del_stmt -> DEL namelist .)
    ELIF            reduce using rule 31 (del_stmt -> DEL namelist .)
    ELSE            reduce using rule 31 (del_stmt -> DEL namelist .)
    DEDENT          reduce using rule 31 (del_stmt -> DEL namelist .)
    COMMA           shift and go to state 105


state 65

    (33) namelist -> IDENTIFIER .

    COMMA           reduce using rule 33 (namelist -> IDENTIFIER .)
    NEWLINE         reduce using rule 33 (namelist -> IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (namelist -> IDENTIFIER .)
    ENDMARKER       reduce using rule 33 (namelist -> IDENTIFIER .)
    DEF             reduce using rule 33 (namelist -> IDENTIFIER .)
    IF              reduce using rule 33 (namelist -> IDENTIFIER .)
    CLASS           reduce using rule 33 (namelist -> IDENTIFIER .)
    FOR             reduce using rule 33 (namelist -> IDENTIFIER .)
    WHILE           reduce using rule 33 (namelist -> IDENTIFIER .)
    PASS            reduce using rule 33 (namelist -> IDENTIFIER .)
    BREAK           reduce using rule 33 (namelist -> IDENTIFIER .)
    CONTINUE        reduce using rule 33 (namelist -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 33 (namelist -> IDENTIFIER .)
    RETURN          reduce using rule 33 (namelist -> IDENTIFIER .)
    DEL             reduce using rule 33 (namelist -> IDENTIFIER .)
    GLOBAL          reduce using rule 33 (namelist -> IDENTIFIER .)
    ELIF            reduce using rule 33 (namelist -> IDENTIFIER .)
    ELSE            reduce using rule 33 (namelist -> IDENTIFIER .)
    DEDENT          reduce using rule 33 (namelist -> IDENTIFIER .)


state 66

    (30) global_stmt -> GLOBAL namelist .
    (32) namelist -> namelist . COMMA IDENTIFIER

    NEWLINE         reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    SEMICOLON       reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    ENDMARKER       reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    DEF             reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    IF              reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    CLASS           reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    FOR             reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    WHILE           reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    PASS            reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    BREAK           reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    CONTINUE        reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    IDENTIFIER      reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    RETURN          reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    DEL             reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    GLOBAL          reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    ELIF            reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    ELSE            reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    DEDENT          reduce using rule 30 (global_stmt -> GLOBAL namelist .)
    COMMA           shift and go to state 105


state 67

    (6) simple_stmts -> simple_stmts SEMICOLON simple_stmt .

    SEMICOLON       reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ENDMARKER       reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEF             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    IF              reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    CLASS           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    FOR             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    WHILE           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    PASS            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    BREAK           reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    CONTINUE        reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    IDENTIFIER      reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    RETURN          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEL             reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    GLOBAL          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ELIF            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    ELSE            reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)
    DEDENT          reduce using rule 6 (simple_stmts -> simple_stmts SEMICOLON simple_stmt .)


state 68

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS . parameters R_PARENTHESIS COLON block
    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS . R_PARENTHESIS COLON block
    (41) parameters -> . parameters COMMA IDENTIFIER
    (42) parameters -> . IDENTIFIER

    R_PARENTHESIS   shift and go to state 108
    IDENTIFIER      shift and go to state 106

    parameters                     shift and go to state 107

state 69

    (21) assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .

    NEWLINE         reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    SEMICOLON       reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    ENDMARKER       reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    DEF             reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    IF              reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    CLASS           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    FOR             reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    WHILE           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    PASS            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    BREAK           reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    CONTINUE        reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    IDENTIFIER      reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    RETURN          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    DEL             reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    GLOBAL          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    ELIF            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    ELSE            reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)
    DEDENT          reduce using rule 21 (assignment -> IDENTIFIER augmentation_assignment IDENTIFIER .)


state 70

    (20) assignment -> IDENTIFIER augmentation_assignment expressions .
    (53) expressions -> expressions . COMMA expression

    NEWLINE         reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    SEMICOLON       reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ENDMARKER       reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEF             reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    IF              reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    CLASS           reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    FOR             reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    WHILE           reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    PASS            reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    BREAK           reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    CONTINUE        reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    IDENTIFIER      reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    RETURN          reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEL             reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    GLOBAL          reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ELIF            reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    ELSE            reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    DEDENT          reduce using rule 20 (assignment -> IDENTIFIER augmentation_assignment expressions .)
    COMMA           shift and go to state 104


state 71

    (43) if_stmt -> IF named_expression COLON . block elif_stmt
    (44) if_stmt -> IF named_expression COLON . block else_block
    (45) if_stmt -> IF named_expression COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 109
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 72

    (56) expression -> disjunction IF . disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    disjunction                    shift and go to state 112
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 73

    (58) disjunction -> conjunction OR . disjunction
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    conjunction                    shift and go to state 44
    disjunction                    shift and go to state 113
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 74

    (60) conjunction -> inversion AND . inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    inversion                      shift and go to state 114
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 75

    (61) inversion -> NOT inversion .

    AND             reduce using rule 61 (inversion -> NOT inversion .)
    OR              reduce using rule 61 (inversion -> NOT inversion .)
    IF              reduce using rule 61 (inversion -> NOT inversion .)
    COLON           reduce using rule 61 (inversion -> NOT inversion .)
    COMMA           reduce using rule 61 (inversion -> NOT inversion .)
    NEWLINE         reduce using rule 61 (inversion -> NOT inversion .)
    SEMICOLON       reduce using rule 61 (inversion -> NOT inversion .)
    ENDMARKER       reduce using rule 61 (inversion -> NOT inversion .)
    DEF             reduce using rule 61 (inversion -> NOT inversion .)
    CLASS           reduce using rule 61 (inversion -> NOT inversion .)
    FOR             reduce using rule 61 (inversion -> NOT inversion .)
    WHILE           reduce using rule 61 (inversion -> NOT inversion .)
    PASS            reduce using rule 61 (inversion -> NOT inversion .)
    BREAK           reduce using rule 61 (inversion -> NOT inversion .)
    CONTINUE        reduce using rule 61 (inversion -> NOT inversion .)
    IDENTIFIER      reduce using rule 61 (inversion -> NOT inversion .)
    RETURN          reduce using rule 61 (inversion -> NOT inversion .)
    DEL             reduce using rule 61 (inversion -> NOT inversion .)
    GLOBAL          reduce using rule 61 (inversion -> NOT inversion .)
    ELIF            reduce using rule 61 (inversion -> NOT inversion .)
    ELSE            reduce using rule 61 (inversion -> NOT inversion .)
    DEDENT          reduce using rule 61 (inversion -> NOT inversion .)


state 76

    (65) comparison -> bitwise_or compare_op_list .
    (67) compare_op_list -> compare_op_list . compare_op
    (68) compare_op -> . EQUALITY bitwise_or
    (69) compare_op -> . INEQUALITY bitwise_or
    (70) compare_op -> . GREATER_EQUAL bitwise_or
    (71) compare_op -> . LESSER_EQUAL bitwise_or
    (72) compare_op -> . GREATER bitwise_or
    (73) compare_op -> . LESSER bitwise_or
    (74) compare_op -> . NOT IN bitwise_or
    (75) compare_op -> . IS NOT bitwise_or
    (76) compare_op -> . IN bitwise_or
    (77) compare_op -> . IS bitwise_or

    AND             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    OR              reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    IF              reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    COLON           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    COMMA           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    NEWLINE         reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    SEMICOLON       reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ENDMARKER       reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEF             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    CLASS           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    FOR             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    WHILE           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    PASS            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    BREAK           reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    CONTINUE        reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    IDENTIFIER      reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    RETURN          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEL             reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    GLOBAL          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ELIF            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    ELSE            reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    DEDENT          reduce using rule 65 (comparison -> bitwise_or compare_op_list .)
    EQUALITY        shift and go to state 79
    INEQUALITY      shift and go to state 80
    GREATER_EQUAL   shift and go to state 81
    LESSER_EQUAL    shift and go to state 82
    GREATER         shift and go to state 83
    LESSER          shift and go to state 84
    NOT             shift and go to state 85
    IS              shift and go to state 87
    IN              shift and go to state 86

    compare_op                     shift and go to state 115

state 77

    (78) bitwise_or -> bitwise_or BITWISE_OR . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_xor                    shift and go to state 116
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 78

    (66) compare_op_list -> compare_op .

    EQUALITY        reduce using rule 66 (compare_op_list -> compare_op .)
    INEQUALITY      reduce using rule 66 (compare_op_list -> compare_op .)
    GREATER_EQUAL   reduce using rule 66 (compare_op_list -> compare_op .)
    LESSER_EQUAL    reduce using rule 66 (compare_op_list -> compare_op .)
    GREATER         reduce using rule 66 (compare_op_list -> compare_op .)
    LESSER          reduce using rule 66 (compare_op_list -> compare_op .)
    NOT             reduce using rule 66 (compare_op_list -> compare_op .)
    IS              reduce using rule 66 (compare_op_list -> compare_op .)
    IN              reduce using rule 66 (compare_op_list -> compare_op .)
    AND             reduce using rule 66 (compare_op_list -> compare_op .)
    OR              reduce using rule 66 (compare_op_list -> compare_op .)
    IF              reduce using rule 66 (compare_op_list -> compare_op .)
    COLON           reduce using rule 66 (compare_op_list -> compare_op .)
    COMMA           reduce using rule 66 (compare_op_list -> compare_op .)
    NEWLINE         reduce using rule 66 (compare_op_list -> compare_op .)
    SEMICOLON       reduce using rule 66 (compare_op_list -> compare_op .)
    ENDMARKER       reduce using rule 66 (compare_op_list -> compare_op .)
    DEF             reduce using rule 66 (compare_op_list -> compare_op .)
    CLASS           reduce using rule 66 (compare_op_list -> compare_op .)
    FOR             reduce using rule 66 (compare_op_list -> compare_op .)
    WHILE           reduce using rule 66 (compare_op_list -> compare_op .)
    PASS            reduce using rule 66 (compare_op_list -> compare_op .)
    BREAK           reduce using rule 66 (compare_op_list -> compare_op .)
    CONTINUE        reduce using rule 66 (compare_op_list -> compare_op .)
    IDENTIFIER      reduce using rule 66 (compare_op_list -> compare_op .)
    RETURN          reduce using rule 66 (compare_op_list -> compare_op .)
    DEL             reduce using rule 66 (compare_op_list -> compare_op .)
    GLOBAL          reduce using rule 66 (compare_op_list -> compare_op .)
    ELIF            reduce using rule 66 (compare_op_list -> compare_op .)
    ELSE            reduce using rule 66 (compare_op_list -> compare_op .)
    DEDENT          reduce using rule 66 (compare_op_list -> compare_op .)


state 79

    (68) compare_op -> EQUALITY . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 117
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 80

    (69) compare_op -> INEQUALITY . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 118
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 81

    (70) compare_op -> GREATER_EQUAL . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 119
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 82

    (71) compare_op -> LESSER_EQUAL . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 120
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 83

    (72) compare_op -> GREATER . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 121
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 84

    (73) compare_op -> LESSER . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 122
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 85

    (74) compare_op -> NOT . IN bitwise_or

    IN              shift and go to state 123


state 86

    (76) compare_op -> IN . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 124
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 87

    (75) compare_op -> IS . NOT bitwise_or
    (77) compare_op -> IS . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 125
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 126
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 88

    (80) bitwise_xor -> bitwise_xor empty . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 127
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 89

    (82) bitwise_and -> bitwise_and BITWISE_AND . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    shift_expr                     shift and go to state 128
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 90

    (84) shift_expr -> shift_expr L_SHIFT . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    sum                            shift and go to state 129
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 91

    (85) shift_expr -> shift_expr R_SHIFT . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    sum                            shift and go to state 130
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 92

    (87) sum -> sum SUM . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    term                           shift and go to state 131
    factor                         shift and go to state 57
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 93

    (88) sum -> sum SUBTRACTION . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    term                           shift and go to state 132
    factor                         shift and go to state 57
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 94

    (95) factor -> SUM factor .

    PRODUCT         reduce using rule 95 (factor -> SUM factor .)
    DIVISION        reduce using rule 95 (factor -> SUM factor .)
    INTEGER_DIVISION reduce using rule 95 (factor -> SUM factor .)
    MODULUS         reduce using rule 95 (factor -> SUM factor .)
    SUM             reduce using rule 95 (factor -> SUM factor .)
    SUBTRACTION     reduce using rule 95 (factor -> SUM factor .)
    L_SHIFT         reduce using rule 95 (factor -> SUM factor .)
    R_SHIFT         reduce using rule 95 (factor -> SUM factor .)
    BITWISE_AND     reduce using rule 95 (factor -> SUM factor .)
    BITWISE_OR      reduce using rule 95 (factor -> SUM factor .)
    EQUALITY        reduce using rule 95 (factor -> SUM factor .)
    INEQUALITY      reduce using rule 95 (factor -> SUM factor .)
    GREATER_EQUAL   reduce using rule 95 (factor -> SUM factor .)
    LESSER_EQUAL    reduce using rule 95 (factor -> SUM factor .)
    GREATER         reduce using rule 95 (factor -> SUM factor .)
    LESSER          reduce using rule 95 (factor -> SUM factor .)
    NOT             reduce using rule 95 (factor -> SUM factor .)
    IS              reduce using rule 95 (factor -> SUM factor .)
    IN              reduce using rule 95 (factor -> SUM factor .)
    AND             reduce using rule 95 (factor -> SUM factor .)
    OR              reduce using rule 95 (factor -> SUM factor .)
    IF              reduce using rule 95 (factor -> SUM factor .)
    COLON           reduce using rule 95 (factor -> SUM factor .)
    COMMA           reduce using rule 95 (factor -> SUM factor .)
    NEWLINE         reduce using rule 95 (factor -> SUM factor .)
    SEMICOLON       reduce using rule 95 (factor -> SUM factor .)
    ENDMARKER       reduce using rule 95 (factor -> SUM factor .)
    DEF             reduce using rule 95 (factor -> SUM factor .)
    CLASS           reduce using rule 95 (factor -> SUM factor .)
    FOR             reduce using rule 95 (factor -> SUM factor .)
    WHILE           reduce using rule 95 (factor -> SUM factor .)
    PASS            reduce using rule 95 (factor -> SUM factor .)
    BREAK           reduce using rule 95 (factor -> SUM factor .)
    CONTINUE        reduce using rule 95 (factor -> SUM factor .)
    IDENTIFIER      reduce using rule 95 (factor -> SUM factor .)
    RETURN          reduce using rule 95 (factor -> SUM factor .)
    DEL             reduce using rule 95 (factor -> SUM factor .)
    GLOBAL          reduce using rule 95 (factor -> SUM factor .)
    ELIF            reduce using rule 95 (factor -> SUM factor .)
    ELSE            reduce using rule 95 (factor -> SUM factor .)
    DEDENT          reduce using rule 95 (factor -> SUM factor .)


state 95

    (90) term -> term PRODUCT . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    factor                         shift and go to state 133
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 96

    (91) term -> term DIVISION . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    factor                         shift and go to state 134
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 97

    (92) term -> term INTEGER_DIVISION . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    factor                         shift and go to state 135
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 98

    (93) term -> term MODULUS . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    factor                         shift and go to state 136
    power                          shift and go to state 58
    empty                          shift and go to state 50

state 99

    (96) factor -> SUBTRACTION factor .

    PRODUCT         reduce using rule 96 (factor -> SUBTRACTION factor .)
    DIVISION        reduce using rule 96 (factor -> SUBTRACTION factor .)
    INTEGER_DIVISION reduce using rule 96 (factor -> SUBTRACTION factor .)
    MODULUS         reduce using rule 96 (factor -> SUBTRACTION factor .)
    SUM             reduce using rule 96 (factor -> SUBTRACTION factor .)
    SUBTRACTION     reduce using rule 96 (factor -> SUBTRACTION factor .)
    L_SHIFT         reduce using rule 96 (factor -> SUBTRACTION factor .)
    R_SHIFT         reduce using rule 96 (factor -> SUBTRACTION factor .)
    BITWISE_AND     reduce using rule 96 (factor -> SUBTRACTION factor .)
    BITWISE_OR      reduce using rule 96 (factor -> SUBTRACTION factor .)
    EQUALITY        reduce using rule 96 (factor -> SUBTRACTION factor .)
    INEQUALITY      reduce using rule 96 (factor -> SUBTRACTION factor .)
    GREATER_EQUAL   reduce using rule 96 (factor -> SUBTRACTION factor .)
    LESSER_EQUAL    reduce using rule 96 (factor -> SUBTRACTION factor .)
    GREATER         reduce using rule 96 (factor -> SUBTRACTION factor .)
    LESSER          reduce using rule 96 (factor -> SUBTRACTION factor .)
    NOT             reduce using rule 96 (factor -> SUBTRACTION factor .)
    IS              reduce using rule 96 (factor -> SUBTRACTION factor .)
    IN              reduce using rule 96 (factor -> SUBTRACTION factor .)
    AND             reduce using rule 96 (factor -> SUBTRACTION factor .)
    OR              reduce using rule 96 (factor -> SUBTRACTION factor .)
    IF              reduce using rule 96 (factor -> SUBTRACTION factor .)
    COLON           reduce using rule 96 (factor -> SUBTRACTION factor .)
    COMMA           reduce using rule 96 (factor -> SUBTRACTION factor .)
    NEWLINE         reduce using rule 96 (factor -> SUBTRACTION factor .)
    SEMICOLON       reduce using rule 96 (factor -> SUBTRACTION factor .)
    ENDMARKER       reduce using rule 96 (factor -> SUBTRACTION factor .)
    DEF             reduce using rule 96 (factor -> SUBTRACTION factor .)
    CLASS           reduce using rule 96 (factor -> SUBTRACTION factor .)
    FOR             reduce using rule 96 (factor -> SUBTRACTION factor .)
    WHILE           reduce using rule 96 (factor -> SUBTRACTION factor .)
    PASS            reduce using rule 96 (factor -> SUBTRACTION factor .)
    BREAK           reduce using rule 96 (factor -> SUBTRACTION factor .)
    CONTINUE        reduce using rule 96 (factor -> SUBTRACTION factor .)
    IDENTIFIER      reduce using rule 96 (factor -> SUBTRACTION factor .)
    RETURN          reduce using rule 96 (factor -> SUBTRACTION factor .)
    DEL             reduce using rule 96 (factor -> SUBTRACTION factor .)
    GLOBAL          reduce using rule 96 (factor -> SUBTRACTION factor .)
    ELIF            reduce using rule 96 (factor -> SUBTRACTION factor .)
    ELSE            reduce using rule 96 (factor -> SUBTRACTION factor .)
    DEDENT          reduce using rule 96 (factor -> SUBTRACTION factor .)


state 100

    (36) class_def -> CLASS IDENTIFIER COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 137
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 101

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS . R_PARENTHESIS COLON block
    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS . arguments R_PARENTHESIS COLON block
    (99) arguments -> .

  ! shift/reduce conflict for R_PARENTHESIS resolved as shift
    R_PARENTHESIS   shift and go to state 138

  ! R_PARENTHESIS   [ reduce using rule 99 (arguments -> .) ]

    arguments                      shift and go to state 139

state 102

    (51) for_stmt -> FOR IDENTIFIER IN . expressions COLON else_block
    (52) for_stmt -> FOR IDENTIFIER IN . expressions COLON block
    (53) expressions -> . expressions COMMA expression
    (54) expressions -> . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    expressions                    shift and go to state 140
    expression                     shift and go to state 63
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 103

    (50) while_stmt -> WHILE named_expression COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 141
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 104

    (53) expressions -> expressions COMMA . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    expression                     shift and go to state 142
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 105

    (32) namelist -> namelist COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 143


state 106

    (42) parameters -> IDENTIFIER .

    R_PARENTHESIS   reduce using rule 42 (parameters -> IDENTIFIER .)
    COMMA           reduce using rule 42 (parameters -> IDENTIFIER .)


state 107

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters . R_PARENTHESIS COLON block
    (41) parameters -> parameters . COMMA IDENTIFIER

    R_PARENTHESIS   shift and go to state 144
    COMMA           shift and go to state 145


state 108

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS . COLON block

    COLON           shift and go to state 146


state 109

    (43) if_stmt -> IF named_expression COLON block . elif_stmt
    (44) if_stmt -> IF named_expression COLON block . else_block
    (45) if_stmt -> IF named_expression COLON block .
    (46) elif_stmt -> . ELIF named_expression COLON block elif_stmt
    (47) elif_stmt -> . ELIF named_expression COLON block else_block
    (48) elif_stmt -> . ELIF named_expression COLON block
    (49) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    DEF             reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    IF              reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    CLASS           reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    FOR             reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    WHILE           reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    PASS            reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    BREAK           reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    CONTINUE        reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    IDENTIFIER      reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    RETURN          reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    DEL             reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    GLOBAL          reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    DEDENT          reduce using rule 45 (if_stmt -> IF named_expression COLON block .)
    ELIF            shift and go to state 149
    ELSE            shift and go to state 150

    elif_stmt                      shift and go to state 147
    else_block                     shift and go to state 148

state 110

    (34) block -> NEWLINE . INDENT statements DEDENT

    INDENT          shift and go to state 151


state 111

    (35) block -> simple_stmts .
    (6) simple_stmts -> simple_stmts . SEMICOLON simple_stmt

    ELIF            reduce using rule 35 (block -> simple_stmts .)
    ELSE            reduce using rule 35 (block -> simple_stmts .)
    ENDMARKER       reduce using rule 35 (block -> simple_stmts .)
    DEF             reduce using rule 35 (block -> simple_stmts .)
    IF              reduce using rule 35 (block -> simple_stmts .)
    CLASS           reduce using rule 35 (block -> simple_stmts .)
    FOR             reduce using rule 35 (block -> simple_stmts .)
    WHILE           reduce using rule 35 (block -> simple_stmts .)
    PASS            reduce using rule 35 (block -> simple_stmts .)
    BREAK           reduce using rule 35 (block -> simple_stmts .)
    CONTINUE        reduce using rule 35 (block -> simple_stmts .)
    IDENTIFIER      reduce using rule 35 (block -> simple_stmts .)
    RETURN          reduce using rule 35 (block -> simple_stmts .)
    DEL             reduce using rule 35 (block -> simple_stmts .)
    GLOBAL          reduce using rule 35 (block -> simple_stmts .)
    DEDENT          reduce using rule 35 (block -> simple_stmts .)
    SEMICOLON       shift and go to state 30


state 112

    (56) expression -> disjunction IF disjunction . ELSE expression

    ELSE            shift and go to state 152


state 113

    (58) disjunction -> conjunction OR disjunction .

    IF              reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    COLON           reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    COMMA           reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    NEWLINE         reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    SEMICOLON       reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    ENDMARKER       reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    DEF             reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    CLASS           reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    FOR             reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    WHILE           reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    PASS            reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    BREAK           reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    CONTINUE        reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    IDENTIFIER      reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    RETURN          reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    DEL             reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    GLOBAL          reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    ELIF            reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    ELSE            reduce using rule 58 (disjunction -> conjunction OR disjunction .)
    DEDENT          reduce using rule 58 (disjunction -> conjunction OR disjunction .)


state 114

    (60) conjunction -> inversion AND inversion .

    OR              reduce using rule 60 (conjunction -> inversion AND inversion .)
    IF              reduce using rule 60 (conjunction -> inversion AND inversion .)
    COLON           reduce using rule 60 (conjunction -> inversion AND inversion .)
    COMMA           reduce using rule 60 (conjunction -> inversion AND inversion .)
    NEWLINE         reduce using rule 60 (conjunction -> inversion AND inversion .)
    SEMICOLON       reduce using rule 60 (conjunction -> inversion AND inversion .)
    ENDMARKER       reduce using rule 60 (conjunction -> inversion AND inversion .)
    DEF             reduce using rule 60 (conjunction -> inversion AND inversion .)
    CLASS           reduce using rule 60 (conjunction -> inversion AND inversion .)
    FOR             reduce using rule 60 (conjunction -> inversion AND inversion .)
    WHILE           reduce using rule 60 (conjunction -> inversion AND inversion .)
    PASS            reduce using rule 60 (conjunction -> inversion AND inversion .)
    BREAK           reduce using rule 60 (conjunction -> inversion AND inversion .)
    CONTINUE        reduce using rule 60 (conjunction -> inversion AND inversion .)
    IDENTIFIER      reduce using rule 60 (conjunction -> inversion AND inversion .)
    RETURN          reduce using rule 60 (conjunction -> inversion AND inversion .)
    DEL             reduce using rule 60 (conjunction -> inversion AND inversion .)
    GLOBAL          reduce using rule 60 (conjunction -> inversion AND inversion .)
    ELIF            reduce using rule 60 (conjunction -> inversion AND inversion .)
    ELSE            reduce using rule 60 (conjunction -> inversion AND inversion .)
    DEDENT          reduce using rule 60 (conjunction -> inversion AND inversion .)


state 115

    (67) compare_op_list -> compare_op_list compare_op .

    EQUALITY        reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    INEQUALITY      reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GREATER_EQUAL   reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    LESSER_EQUAL    reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GREATER         reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    LESSER          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NOT             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IS              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IN              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    AND             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    OR              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IF              reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    COLON           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    COMMA           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    NEWLINE         reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    SEMICOLON       reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ENDMARKER       reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEF             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    CLASS           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    FOR             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    WHILE           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    PASS            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    BREAK           reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    CONTINUE        reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    IDENTIFIER      reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    RETURN          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEL             reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    GLOBAL          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ELIF            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    ELSE            reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)
    DEDENT          reduce using rule 67 (compare_op_list -> compare_op_list compare_op .)


state 116

    (78) bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .
    (80) bitwise_xor -> bitwise_xor . empty bitwise_and
    (100) empty -> .

  ! reduce/reduce conflict for BITWISE_OR resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for GREATER resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for LESSER resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for NOT resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for IS resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for IN resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for AND resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for OR resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for IF resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for COLON resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for COMMA resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for ENDMARKER resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for DEF resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for CLASS resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for FOR resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for WHILE resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for PASS resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for BREAK resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for RETURN resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for DEL resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for GLOBAL resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for ELIF resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for ELSE resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
  ! reduce/reduce conflict for DEDENT resolved using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    BITWISE_OR      reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    EQUALITY        reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    INEQUALITY      reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GREATER_EQUAL   reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    LESSER_EQUAL    reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GREATER         reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    LESSER          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NOT             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IS              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IN              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    AND             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    OR              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IF              reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    COLON           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    COMMA           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    NEWLINE         reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    SEMICOLON       reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ENDMARKER       reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEF             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    CLASS           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    FOR             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    WHILE           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    PASS            reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    BREAK           reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    CONTINUE        reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    IDENTIFIER      reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    RETURN          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEL             reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    GLOBAL          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ELIF            reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    ELSE            reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    DEDENT          reduce using rule 78 (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor .)
    SUM             reduce using rule 100 (empty -> .)
    SUBTRACTION     reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)

  ! BITWISE_OR      [ reduce using rule 100 (empty -> .) ]
  ! EQUALITY        [ reduce using rule 100 (empty -> .) ]
  ! INEQUALITY      [ reduce using rule 100 (empty -> .) ]
  ! GREATER_EQUAL   [ reduce using rule 100 (empty -> .) ]
  ! LESSER_EQUAL    [ reduce using rule 100 (empty -> .) ]
  ! GREATER         [ reduce using rule 100 (empty -> .) ]
  ! LESSER          [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]
  ! IS              [ reduce using rule 100 (empty -> .) ]
  ! IN              [ reduce using rule 100 (empty -> .) ]
  ! AND             [ reduce using rule 100 (empty -> .) ]
  ! OR              [ reduce using rule 100 (empty -> .) ]
  ! IF              [ reduce using rule 100 (empty -> .) ]
  ! COLON           [ reduce using rule 100 (empty -> .) ]
  ! COMMA           [ reduce using rule 100 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 100 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 100 (empty -> .) ]
  ! ENDMARKER       [ reduce using rule 100 (empty -> .) ]
  ! DEF             [ reduce using rule 100 (empty -> .) ]
  ! CLASS           [ reduce using rule 100 (empty -> .) ]
  ! FOR             [ reduce using rule 100 (empty -> .) ]
  ! WHILE           [ reduce using rule 100 (empty -> .) ]
  ! PASS            [ reduce using rule 100 (empty -> .) ]
  ! BREAK           [ reduce using rule 100 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 100 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 100 (empty -> .) ]
  ! RETURN          [ reduce using rule 100 (empty -> .) ]
  ! DEL             [ reduce using rule 100 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 100 (empty -> .) ]
  ! ELIF            [ reduce using rule 100 (empty -> .) ]
  ! ELSE            [ reduce using rule 100 (empty -> .) ]
  ! DEDENT          [ reduce using rule 100 (empty -> .) ]

    empty                          shift and go to state 88

state 117

    (68) compare_op -> EQUALITY bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    INEQUALITY      reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    GREATER_EQUAL   reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    LESSER_EQUAL    reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    GREATER         reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    LESSER          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    NOT             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IS              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IN              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    AND             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    OR              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IF              reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    COLON           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    COMMA           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    NEWLINE         reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    SEMICOLON       reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    ENDMARKER       reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    DEF             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    CLASS           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    FOR             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    WHILE           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    PASS            reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    BREAK           reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    CONTINUE        reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    IDENTIFIER      reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    RETURN          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    DEL             reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    GLOBAL          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    ELIF            reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    ELSE            reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    DEDENT          reduce using rule 68 (compare_op -> EQUALITY bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 118

    (69) compare_op -> INEQUALITY bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    INEQUALITY      reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    GREATER_EQUAL   reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    LESSER_EQUAL    reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    GREATER         reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    LESSER          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    NOT             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IS              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IN              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    AND             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    OR              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IF              reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    COLON           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    COMMA           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    NEWLINE         reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    SEMICOLON       reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    ENDMARKER       reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    DEF             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    CLASS           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    FOR             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    WHILE           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    PASS            reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    BREAK           reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    CONTINUE        reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    IDENTIFIER      reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    RETURN          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    DEL             reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    GLOBAL          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    ELIF            reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    ELSE            reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    DEDENT          reduce using rule 69 (compare_op -> INEQUALITY bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 119

    (70) compare_op -> GREATER_EQUAL bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    INEQUALITY      reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    GREATER_EQUAL   reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    LESSER_EQUAL    reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    GREATER         reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    LESSER          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    NOT             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IS              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IN              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    AND             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    OR              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IF              reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    COLON           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    COMMA           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    NEWLINE         reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    SEMICOLON       reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    ENDMARKER       reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEF             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    CLASS           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    FOR             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    WHILE           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    PASS            reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    BREAK           reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    CONTINUE        reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    IDENTIFIER      reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    RETURN          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEL             reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    GLOBAL          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    ELIF            reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    ELSE            reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    DEDENT          reduce using rule 70 (compare_op -> GREATER_EQUAL bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 120

    (71) compare_op -> LESSER_EQUAL bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    INEQUALITY      reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    GREATER_EQUAL   reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    LESSER_EQUAL    reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    GREATER         reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    LESSER          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    NOT             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IS              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IN              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    AND             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    OR              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IF              reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    COLON           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    COMMA           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    NEWLINE         reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    SEMICOLON       reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    ENDMARKER       reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEF             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    CLASS           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    FOR             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    WHILE           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    PASS            reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    BREAK           reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    CONTINUE        reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    IDENTIFIER      reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    RETURN          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEL             reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    GLOBAL          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    ELIF            reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    ELSE            reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    DEDENT          reduce using rule 71 (compare_op -> LESSER_EQUAL bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 121

    (72) compare_op -> GREATER bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    INEQUALITY      reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    GREATER_EQUAL   reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    LESSER_EQUAL    reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    GREATER         reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    LESSER          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    NOT             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IS              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IN              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    AND             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    OR              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IF              reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    COLON           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    COMMA           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    NEWLINE         reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    SEMICOLON       reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    ENDMARKER       reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    DEF             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    CLASS           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    FOR             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    WHILE           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    PASS            reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    BREAK           reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    CONTINUE        reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    IDENTIFIER      reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    RETURN          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    DEL             reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    GLOBAL          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    ELIF            reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    ELSE            reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    DEDENT          reduce using rule 72 (compare_op -> GREATER bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 122

    (73) compare_op -> LESSER bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    INEQUALITY      reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    GREATER_EQUAL   reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    LESSER_EQUAL    reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    GREATER         reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    LESSER          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    NOT             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IS              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IN              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    AND             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    OR              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IF              reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    COLON           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    COMMA           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    NEWLINE         reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    SEMICOLON       reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    ENDMARKER       reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    DEF             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    CLASS           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    FOR             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    WHILE           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    PASS            reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    BREAK           reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    CONTINUE        reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    IDENTIFIER      reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    RETURN          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    DEL             reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    GLOBAL          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    ELIF            reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    ELSE            reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    DEDENT          reduce using rule 73 (compare_op -> LESSER bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 123

    (74) compare_op -> NOT IN . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 153
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 124

    (76) compare_op -> IN bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 76 (compare_op -> IN bitwise_or .)
    INEQUALITY      reduce using rule 76 (compare_op -> IN bitwise_or .)
    GREATER_EQUAL   reduce using rule 76 (compare_op -> IN bitwise_or .)
    LESSER_EQUAL    reduce using rule 76 (compare_op -> IN bitwise_or .)
    GREATER         reduce using rule 76 (compare_op -> IN bitwise_or .)
    LESSER          reduce using rule 76 (compare_op -> IN bitwise_or .)
    NOT             reduce using rule 76 (compare_op -> IN bitwise_or .)
    IS              reduce using rule 76 (compare_op -> IN bitwise_or .)
    IN              reduce using rule 76 (compare_op -> IN bitwise_or .)
    AND             reduce using rule 76 (compare_op -> IN bitwise_or .)
    OR              reduce using rule 76 (compare_op -> IN bitwise_or .)
    IF              reduce using rule 76 (compare_op -> IN bitwise_or .)
    COLON           reduce using rule 76 (compare_op -> IN bitwise_or .)
    COMMA           reduce using rule 76 (compare_op -> IN bitwise_or .)
    NEWLINE         reduce using rule 76 (compare_op -> IN bitwise_or .)
    SEMICOLON       reduce using rule 76 (compare_op -> IN bitwise_or .)
    ENDMARKER       reduce using rule 76 (compare_op -> IN bitwise_or .)
    DEF             reduce using rule 76 (compare_op -> IN bitwise_or .)
    CLASS           reduce using rule 76 (compare_op -> IN bitwise_or .)
    FOR             reduce using rule 76 (compare_op -> IN bitwise_or .)
    WHILE           reduce using rule 76 (compare_op -> IN bitwise_or .)
    PASS            reduce using rule 76 (compare_op -> IN bitwise_or .)
    BREAK           reduce using rule 76 (compare_op -> IN bitwise_or .)
    CONTINUE        reduce using rule 76 (compare_op -> IN bitwise_or .)
    IDENTIFIER      reduce using rule 76 (compare_op -> IN bitwise_or .)
    RETURN          reduce using rule 76 (compare_op -> IN bitwise_or .)
    DEL             reduce using rule 76 (compare_op -> IN bitwise_or .)
    GLOBAL          reduce using rule 76 (compare_op -> IN bitwise_or .)
    ELIF            reduce using rule 76 (compare_op -> IN bitwise_or .)
    ELSE            reduce using rule 76 (compare_op -> IN bitwise_or .)
    DEDENT          reduce using rule 76 (compare_op -> IN bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 125

    (75) compare_op -> IS NOT . bitwise_or
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    NOT             reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]

    bitwise_or                     shift and go to state 154
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 126

    (77) compare_op -> IS bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 77 (compare_op -> IS bitwise_or .)
    INEQUALITY      reduce using rule 77 (compare_op -> IS bitwise_or .)
    GREATER_EQUAL   reduce using rule 77 (compare_op -> IS bitwise_or .)
    LESSER_EQUAL    reduce using rule 77 (compare_op -> IS bitwise_or .)
    GREATER         reduce using rule 77 (compare_op -> IS bitwise_or .)
    LESSER          reduce using rule 77 (compare_op -> IS bitwise_or .)
    NOT             reduce using rule 77 (compare_op -> IS bitwise_or .)
    IS              reduce using rule 77 (compare_op -> IS bitwise_or .)
    IN              reduce using rule 77 (compare_op -> IS bitwise_or .)
    AND             reduce using rule 77 (compare_op -> IS bitwise_or .)
    OR              reduce using rule 77 (compare_op -> IS bitwise_or .)
    IF              reduce using rule 77 (compare_op -> IS bitwise_or .)
    COLON           reduce using rule 77 (compare_op -> IS bitwise_or .)
    COMMA           reduce using rule 77 (compare_op -> IS bitwise_or .)
    NEWLINE         reduce using rule 77 (compare_op -> IS bitwise_or .)
    SEMICOLON       reduce using rule 77 (compare_op -> IS bitwise_or .)
    ENDMARKER       reduce using rule 77 (compare_op -> IS bitwise_or .)
    DEF             reduce using rule 77 (compare_op -> IS bitwise_or .)
    CLASS           reduce using rule 77 (compare_op -> IS bitwise_or .)
    FOR             reduce using rule 77 (compare_op -> IS bitwise_or .)
    WHILE           reduce using rule 77 (compare_op -> IS bitwise_or .)
    PASS            reduce using rule 77 (compare_op -> IS bitwise_or .)
    BREAK           reduce using rule 77 (compare_op -> IS bitwise_or .)
    CONTINUE        reduce using rule 77 (compare_op -> IS bitwise_or .)
    IDENTIFIER      reduce using rule 77 (compare_op -> IS bitwise_or .)
    RETURN          reduce using rule 77 (compare_op -> IS bitwise_or .)
    DEL             reduce using rule 77 (compare_op -> IS bitwise_or .)
    GLOBAL          reduce using rule 77 (compare_op -> IS bitwise_or .)
    ELIF            reduce using rule 77 (compare_op -> IS bitwise_or .)
    ELSE            reduce using rule 77 (compare_op -> IS bitwise_or .)
    DEDENT          reduce using rule 77 (compare_op -> IS bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 127

    (80) bitwise_xor -> bitwise_xor empty bitwise_and .
    (82) bitwise_and -> bitwise_and . BITWISE_AND shift_expr

  ! shift/reduce conflict for BITWISE_AND resolved as shift
    SUM             reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    SUBTRACTION     reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    L_SHIFT         reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    R_SHIFT         reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    PRODUCT         reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    DIVISION        reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    INTEGER_DIVISION reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    MODULUS         reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    BITWISE_OR      reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    EQUALITY        reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    INEQUALITY      reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    GREATER_EQUAL   reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    LESSER_EQUAL    reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    GREATER         reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    LESSER          reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    NOT             reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    IS              reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    IN              reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    AND             reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    OR              reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    IF              reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    COLON           reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    COMMA           reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    NEWLINE         reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    SEMICOLON       reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    ENDMARKER       reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    DEF             reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    CLASS           reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    FOR             reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    WHILE           reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    PASS            reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    BREAK           reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    CONTINUE        reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    IDENTIFIER      reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    RETURN          reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    DEL             reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    GLOBAL          reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    ELIF            reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    ELSE            reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    DEDENT          reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .)
    BITWISE_AND     shift and go to state 89

  ! BITWISE_AND     [ reduce using rule 80 (bitwise_xor -> bitwise_xor empty bitwise_and .) ]


state 128

    (82) bitwise_and -> bitwise_and BITWISE_AND shift_expr .
    (84) shift_expr -> shift_expr . L_SHIFT sum
    (85) shift_expr -> shift_expr . R_SHIFT sum

  ! shift/reduce conflict for L_SHIFT resolved as shift
  ! shift/reduce conflict for R_SHIFT resolved as shift
    BITWISE_AND     reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    SUM             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    SUBTRACTION     reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    PRODUCT         reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DIVISION        reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    INTEGER_DIVISION reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    MODULUS         reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BITWISE_OR      reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    EQUALITY        reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    INEQUALITY      reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GREATER_EQUAL   reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    LESSER_EQUAL    reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GREATER         reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    LESSER          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NOT             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IS              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IN              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    AND             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    OR              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IF              reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    COLON           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    COMMA           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    NEWLINE         reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    SEMICOLON       reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ENDMARKER       reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEF             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    CLASS           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    FOR             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    WHILE           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    PASS            reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    BREAK           reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    CONTINUE        reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    IDENTIFIER      reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    RETURN          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEL             reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    GLOBAL          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ELIF            reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    ELSE            reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    DEDENT          reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .)
    L_SHIFT         shift and go to state 90
    R_SHIFT         shift and go to state 91

  ! L_SHIFT         [ reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .) ]
  ! R_SHIFT         [ reduce using rule 82 (bitwise_and -> bitwise_and BITWISE_AND shift_expr .) ]


state 129

    (84) shift_expr -> shift_expr L_SHIFT sum .
    (87) sum -> sum . SUM term
    (88) sum -> sum . SUBTRACTION term

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    L_SHIFT         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    R_SHIFT         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_AND     reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    PRODUCT         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    DIVISION        reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    INTEGER_DIVISION reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    MODULUS         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    BITWISE_OR      reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    EQUALITY        reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    INEQUALITY      reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    GREATER_EQUAL   reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    LESSER_EQUAL    reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    GREATER         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    LESSER          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    NOT             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IS              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IN              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    AND             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    OR              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IF              reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    COLON           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    COMMA           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    NEWLINE         reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    SEMICOLON       reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    ENDMARKER       reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    DEF             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    CLASS           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    FOR             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    WHILE           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    PASS            reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    BREAK           reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    CONTINUE        reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    IDENTIFIER      reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    RETURN          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    DEL             reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    GLOBAL          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    ELIF            reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    ELSE            reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    DEDENT          reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .)
    SUM             shift and go to state 92
    SUBTRACTION     shift and go to state 93

  ! SUM             [ reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .) ]
  ! SUBTRACTION     [ reduce using rule 84 (shift_expr -> shift_expr L_SHIFT sum .) ]


state 130

    (85) shift_expr -> shift_expr R_SHIFT sum .
    (87) sum -> sum . SUM term
    (88) sum -> sum . SUBTRACTION term

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
    L_SHIFT         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    R_SHIFT         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_AND     reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    PRODUCT         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    DIVISION        reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    INTEGER_DIVISION reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    MODULUS         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    BITWISE_OR      reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    EQUALITY        reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    INEQUALITY      reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    GREATER_EQUAL   reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    LESSER_EQUAL    reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    GREATER         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    LESSER          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    NOT             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IS              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IN              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    AND             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    OR              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IF              reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    COLON           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    COMMA           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    NEWLINE         reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    SEMICOLON       reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    ENDMARKER       reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    DEF             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    CLASS           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    FOR             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    WHILE           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    PASS            reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    BREAK           reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    CONTINUE        reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    IDENTIFIER      reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    RETURN          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    DEL             reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    GLOBAL          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    ELIF            reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    ELSE            reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    DEDENT          reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .)
    SUM             shift and go to state 92
    SUBTRACTION     shift and go to state 93

  ! SUM             [ reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .) ]
  ! SUBTRACTION     [ reduce using rule 85 (shift_expr -> shift_expr R_SHIFT sum .) ]


state 131

    (87) sum -> sum SUM term .
    (90) term -> term . PRODUCT factor
    (91) term -> term . DIVISION factor
    (92) term -> term . INTEGER_DIVISION factor
    (93) term -> term . MODULUS factor

  ! shift/reduce conflict for PRODUCT resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for INTEGER_DIVISION resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
    SUM             reduce using rule 87 (sum -> sum SUM term .)
    SUBTRACTION     reduce using rule 87 (sum -> sum SUM term .)
    L_SHIFT         reduce using rule 87 (sum -> sum SUM term .)
    R_SHIFT         reduce using rule 87 (sum -> sum SUM term .)
    BITWISE_AND     reduce using rule 87 (sum -> sum SUM term .)
    BITWISE_OR      reduce using rule 87 (sum -> sum SUM term .)
    EQUALITY        reduce using rule 87 (sum -> sum SUM term .)
    INEQUALITY      reduce using rule 87 (sum -> sum SUM term .)
    GREATER_EQUAL   reduce using rule 87 (sum -> sum SUM term .)
    LESSER_EQUAL    reduce using rule 87 (sum -> sum SUM term .)
    GREATER         reduce using rule 87 (sum -> sum SUM term .)
    LESSER          reduce using rule 87 (sum -> sum SUM term .)
    NOT             reduce using rule 87 (sum -> sum SUM term .)
    IS              reduce using rule 87 (sum -> sum SUM term .)
    IN              reduce using rule 87 (sum -> sum SUM term .)
    AND             reduce using rule 87 (sum -> sum SUM term .)
    OR              reduce using rule 87 (sum -> sum SUM term .)
    IF              reduce using rule 87 (sum -> sum SUM term .)
    COLON           reduce using rule 87 (sum -> sum SUM term .)
    COMMA           reduce using rule 87 (sum -> sum SUM term .)
    NEWLINE         reduce using rule 87 (sum -> sum SUM term .)
    SEMICOLON       reduce using rule 87 (sum -> sum SUM term .)
    ENDMARKER       reduce using rule 87 (sum -> sum SUM term .)
    DEF             reduce using rule 87 (sum -> sum SUM term .)
    CLASS           reduce using rule 87 (sum -> sum SUM term .)
    FOR             reduce using rule 87 (sum -> sum SUM term .)
    WHILE           reduce using rule 87 (sum -> sum SUM term .)
    PASS            reduce using rule 87 (sum -> sum SUM term .)
    BREAK           reduce using rule 87 (sum -> sum SUM term .)
    CONTINUE        reduce using rule 87 (sum -> sum SUM term .)
    IDENTIFIER      reduce using rule 87 (sum -> sum SUM term .)
    RETURN          reduce using rule 87 (sum -> sum SUM term .)
    DEL             reduce using rule 87 (sum -> sum SUM term .)
    GLOBAL          reduce using rule 87 (sum -> sum SUM term .)
    ELIF            reduce using rule 87 (sum -> sum SUM term .)
    ELSE            reduce using rule 87 (sum -> sum SUM term .)
    DEDENT          reduce using rule 87 (sum -> sum SUM term .)
    PRODUCT         shift and go to state 95
    DIVISION        shift and go to state 96
    INTEGER_DIVISION shift and go to state 97
    MODULUS         shift and go to state 98

  ! PRODUCT         [ reduce using rule 87 (sum -> sum SUM term .) ]
  ! DIVISION        [ reduce using rule 87 (sum -> sum SUM term .) ]
  ! INTEGER_DIVISION [ reduce using rule 87 (sum -> sum SUM term .) ]
  ! MODULUS         [ reduce using rule 87 (sum -> sum SUM term .) ]


state 132

    (88) sum -> sum SUBTRACTION term .
    (90) term -> term . PRODUCT factor
    (91) term -> term . DIVISION factor
    (92) term -> term . INTEGER_DIVISION factor
    (93) term -> term . MODULUS factor

  ! shift/reduce conflict for PRODUCT resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for INTEGER_DIVISION resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
    SUM             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    SUBTRACTION     reduce using rule 88 (sum -> sum SUBTRACTION term .)
    L_SHIFT         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    R_SHIFT         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    BITWISE_AND     reduce using rule 88 (sum -> sum SUBTRACTION term .)
    BITWISE_OR      reduce using rule 88 (sum -> sum SUBTRACTION term .)
    EQUALITY        reduce using rule 88 (sum -> sum SUBTRACTION term .)
    INEQUALITY      reduce using rule 88 (sum -> sum SUBTRACTION term .)
    GREATER_EQUAL   reduce using rule 88 (sum -> sum SUBTRACTION term .)
    LESSER_EQUAL    reduce using rule 88 (sum -> sum SUBTRACTION term .)
    GREATER         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    LESSER          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    NOT             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IS              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IN              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    AND             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    OR              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IF              reduce using rule 88 (sum -> sum SUBTRACTION term .)
    COLON           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    COMMA           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    NEWLINE         reduce using rule 88 (sum -> sum SUBTRACTION term .)
    SEMICOLON       reduce using rule 88 (sum -> sum SUBTRACTION term .)
    ENDMARKER       reduce using rule 88 (sum -> sum SUBTRACTION term .)
    DEF             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    CLASS           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    FOR             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    WHILE           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    PASS            reduce using rule 88 (sum -> sum SUBTRACTION term .)
    BREAK           reduce using rule 88 (sum -> sum SUBTRACTION term .)
    CONTINUE        reduce using rule 88 (sum -> sum SUBTRACTION term .)
    IDENTIFIER      reduce using rule 88 (sum -> sum SUBTRACTION term .)
    RETURN          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    DEL             reduce using rule 88 (sum -> sum SUBTRACTION term .)
    GLOBAL          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    ELIF            reduce using rule 88 (sum -> sum SUBTRACTION term .)
    ELSE            reduce using rule 88 (sum -> sum SUBTRACTION term .)
    DEDENT          reduce using rule 88 (sum -> sum SUBTRACTION term .)
    PRODUCT         shift and go to state 95
    DIVISION        shift and go to state 96
    INTEGER_DIVISION shift and go to state 97
    MODULUS         shift and go to state 98

  ! PRODUCT         [ reduce using rule 88 (sum -> sum SUBTRACTION term .) ]
  ! DIVISION        [ reduce using rule 88 (sum -> sum SUBTRACTION term .) ]
  ! INTEGER_DIVISION [ reduce using rule 88 (sum -> sum SUBTRACTION term .) ]
  ! MODULUS         [ reduce using rule 88 (sum -> sum SUBTRACTION term .) ]


state 133

    (90) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 90 (term -> term PRODUCT factor .)
    DIVISION        reduce using rule 90 (term -> term PRODUCT factor .)
    INTEGER_DIVISION reduce using rule 90 (term -> term PRODUCT factor .)
    MODULUS         reduce using rule 90 (term -> term PRODUCT factor .)
    SUM             reduce using rule 90 (term -> term PRODUCT factor .)
    SUBTRACTION     reduce using rule 90 (term -> term PRODUCT factor .)
    L_SHIFT         reduce using rule 90 (term -> term PRODUCT factor .)
    R_SHIFT         reduce using rule 90 (term -> term PRODUCT factor .)
    BITWISE_AND     reduce using rule 90 (term -> term PRODUCT factor .)
    BITWISE_OR      reduce using rule 90 (term -> term PRODUCT factor .)
    EQUALITY        reduce using rule 90 (term -> term PRODUCT factor .)
    INEQUALITY      reduce using rule 90 (term -> term PRODUCT factor .)
    GREATER_EQUAL   reduce using rule 90 (term -> term PRODUCT factor .)
    LESSER_EQUAL    reduce using rule 90 (term -> term PRODUCT factor .)
    GREATER         reduce using rule 90 (term -> term PRODUCT factor .)
    LESSER          reduce using rule 90 (term -> term PRODUCT factor .)
    NOT             reduce using rule 90 (term -> term PRODUCT factor .)
    IS              reduce using rule 90 (term -> term PRODUCT factor .)
    IN              reduce using rule 90 (term -> term PRODUCT factor .)
    AND             reduce using rule 90 (term -> term PRODUCT factor .)
    OR              reduce using rule 90 (term -> term PRODUCT factor .)
    IF              reduce using rule 90 (term -> term PRODUCT factor .)
    COLON           reduce using rule 90 (term -> term PRODUCT factor .)
    COMMA           reduce using rule 90 (term -> term PRODUCT factor .)
    NEWLINE         reduce using rule 90 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 90 (term -> term PRODUCT factor .)
    ENDMARKER       reduce using rule 90 (term -> term PRODUCT factor .)
    DEF             reduce using rule 90 (term -> term PRODUCT factor .)
    CLASS           reduce using rule 90 (term -> term PRODUCT factor .)
    FOR             reduce using rule 90 (term -> term PRODUCT factor .)
    WHILE           reduce using rule 90 (term -> term PRODUCT factor .)
    PASS            reduce using rule 90 (term -> term PRODUCT factor .)
    BREAK           reduce using rule 90 (term -> term PRODUCT factor .)
    CONTINUE        reduce using rule 90 (term -> term PRODUCT factor .)
    IDENTIFIER      reduce using rule 90 (term -> term PRODUCT factor .)
    RETURN          reduce using rule 90 (term -> term PRODUCT factor .)
    DEL             reduce using rule 90 (term -> term PRODUCT factor .)
    GLOBAL          reduce using rule 90 (term -> term PRODUCT factor .)
    ELIF            reduce using rule 90 (term -> term PRODUCT factor .)
    ELSE            reduce using rule 90 (term -> term PRODUCT factor .)
    DEDENT          reduce using rule 90 (term -> term PRODUCT factor .)


state 134

    (91) term -> term DIVISION factor .

    PRODUCT         reduce using rule 91 (term -> term DIVISION factor .)
    DIVISION        reduce using rule 91 (term -> term DIVISION factor .)
    INTEGER_DIVISION reduce using rule 91 (term -> term DIVISION factor .)
    MODULUS         reduce using rule 91 (term -> term DIVISION factor .)
    SUM             reduce using rule 91 (term -> term DIVISION factor .)
    SUBTRACTION     reduce using rule 91 (term -> term DIVISION factor .)
    L_SHIFT         reduce using rule 91 (term -> term DIVISION factor .)
    R_SHIFT         reduce using rule 91 (term -> term DIVISION factor .)
    BITWISE_AND     reduce using rule 91 (term -> term DIVISION factor .)
    BITWISE_OR      reduce using rule 91 (term -> term DIVISION factor .)
    EQUALITY        reduce using rule 91 (term -> term DIVISION factor .)
    INEQUALITY      reduce using rule 91 (term -> term DIVISION factor .)
    GREATER_EQUAL   reduce using rule 91 (term -> term DIVISION factor .)
    LESSER_EQUAL    reduce using rule 91 (term -> term DIVISION factor .)
    GREATER         reduce using rule 91 (term -> term DIVISION factor .)
    LESSER          reduce using rule 91 (term -> term DIVISION factor .)
    NOT             reduce using rule 91 (term -> term DIVISION factor .)
    IS              reduce using rule 91 (term -> term DIVISION factor .)
    IN              reduce using rule 91 (term -> term DIVISION factor .)
    AND             reduce using rule 91 (term -> term DIVISION factor .)
    OR              reduce using rule 91 (term -> term DIVISION factor .)
    IF              reduce using rule 91 (term -> term DIVISION factor .)
    COLON           reduce using rule 91 (term -> term DIVISION factor .)
    COMMA           reduce using rule 91 (term -> term DIVISION factor .)
    NEWLINE         reduce using rule 91 (term -> term DIVISION factor .)
    SEMICOLON       reduce using rule 91 (term -> term DIVISION factor .)
    ENDMARKER       reduce using rule 91 (term -> term DIVISION factor .)
    DEF             reduce using rule 91 (term -> term DIVISION factor .)
    CLASS           reduce using rule 91 (term -> term DIVISION factor .)
    FOR             reduce using rule 91 (term -> term DIVISION factor .)
    WHILE           reduce using rule 91 (term -> term DIVISION factor .)
    PASS            reduce using rule 91 (term -> term DIVISION factor .)
    BREAK           reduce using rule 91 (term -> term DIVISION factor .)
    CONTINUE        reduce using rule 91 (term -> term DIVISION factor .)
    IDENTIFIER      reduce using rule 91 (term -> term DIVISION factor .)
    RETURN          reduce using rule 91 (term -> term DIVISION factor .)
    DEL             reduce using rule 91 (term -> term DIVISION factor .)
    GLOBAL          reduce using rule 91 (term -> term DIVISION factor .)
    ELIF            reduce using rule 91 (term -> term DIVISION factor .)
    ELSE            reduce using rule 91 (term -> term DIVISION factor .)
    DEDENT          reduce using rule 91 (term -> term DIVISION factor .)


state 135

    (92) term -> term INTEGER_DIVISION factor .

    PRODUCT         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DIVISION        reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    INTEGER_DIVISION reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    MODULUS         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    SUM             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    SUBTRACTION     reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    L_SHIFT         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    R_SHIFT         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    BITWISE_AND     reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    BITWISE_OR      reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    EQUALITY        reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    INEQUALITY      reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    GREATER_EQUAL   reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    LESSER_EQUAL    reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    GREATER         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    LESSER          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    NOT             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IS              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IN              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    AND             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    OR              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IF              reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    COLON           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    COMMA           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    NEWLINE         reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    SEMICOLON       reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    ENDMARKER       reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DEF             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    CLASS           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    FOR             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    WHILE           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    PASS            reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    BREAK           reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    CONTINUE        reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    IDENTIFIER      reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    RETURN          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DEL             reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    GLOBAL          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    ELIF            reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    ELSE            reduce using rule 92 (term -> term INTEGER_DIVISION factor .)
    DEDENT          reduce using rule 92 (term -> term INTEGER_DIVISION factor .)


state 136

    (93) term -> term MODULUS factor .

    PRODUCT         reduce using rule 93 (term -> term MODULUS factor .)
    DIVISION        reduce using rule 93 (term -> term MODULUS factor .)
    INTEGER_DIVISION reduce using rule 93 (term -> term MODULUS factor .)
    MODULUS         reduce using rule 93 (term -> term MODULUS factor .)
    SUM             reduce using rule 93 (term -> term MODULUS factor .)
    SUBTRACTION     reduce using rule 93 (term -> term MODULUS factor .)
    L_SHIFT         reduce using rule 93 (term -> term MODULUS factor .)
    R_SHIFT         reduce using rule 93 (term -> term MODULUS factor .)
    BITWISE_AND     reduce using rule 93 (term -> term MODULUS factor .)
    BITWISE_OR      reduce using rule 93 (term -> term MODULUS factor .)
    EQUALITY        reduce using rule 93 (term -> term MODULUS factor .)
    INEQUALITY      reduce using rule 93 (term -> term MODULUS factor .)
    GREATER_EQUAL   reduce using rule 93 (term -> term MODULUS factor .)
    LESSER_EQUAL    reduce using rule 93 (term -> term MODULUS factor .)
    GREATER         reduce using rule 93 (term -> term MODULUS factor .)
    LESSER          reduce using rule 93 (term -> term MODULUS factor .)
    NOT             reduce using rule 93 (term -> term MODULUS factor .)
    IS              reduce using rule 93 (term -> term MODULUS factor .)
    IN              reduce using rule 93 (term -> term MODULUS factor .)
    AND             reduce using rule 93 (term -> term MODULUS factor .)
    OR              reduce using rule 93 (term -> term MODULUS factor .)
    IF              reduce using rule 93 (term -> term MODULUS factor .)
    COLON           reduce using rule 93 (term -> term MODULUS factor .)
    COMMA           reduce using rule 93 (term -> term MODULUS factor .)
    NEWLINE         reduce using rule 93 (term -> term MODULUS factor .)
    SEMICOLON       reduce using rule 93 (term -> term MODULUS factor .)
    ENDMARKER       reduce using rule 93 (term -> term MODULUS factor .)
    DEF             reduce using rule 93 (term -> term MODULUS factor .)
    CLASS           reduce using rule 93 (term -> term MODULUS factor .)
    FOR             reduce using rule 93 (term -> term MODULUS factor .)
    WHILE           reduce using rule 93 (term -> term MODULUS factor .)
    PASS            reduce using rule 93 (term -> term MODULUS factor .)
    BREAK           reduce using rule 93 (term -> term MODULUS factor .)
    CONTINUE        reduce using rule 93 (term -> term MODULUS factor .)
    IDENTIFIER      reduce using rule 93 (term -> term MODULUS factor .)
    RETURN          reduce using rule 93 (term -> term MODULUS factor .)
    DEL             reduce using rule 93 (term -> term MODULUS factor .)
    GLOBAL          reduce using rule 93 (term -> term MODULUS factor .)
    ELIF            reduce using rule 93 (term -> term MODULUS factor .)
    ELSE            reduce using rule 93 (term -> term MODULUS factor .)
    DEDENT          reduce using rule 93 (term -> term MODULUS factor .)


state 137

    (36) class_def -> CLASS IDENTIFIER COLON block .

    ENDMARKER       reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    DEF             reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    IF              reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    CLASS           reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    FOR             reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    WHILE           reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    PASS            reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    BREAK           reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    CONTINUE        reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    IDENTIFIER      reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    RETURN          reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    DEL             reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    GLOBAL          reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)
    DEDENT          reduce using rule 36 (class_def -> CLASS IDENTIFIER COLON block .)


state 138

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS . COLON block

    COLON           shift and go to state 155


state 139

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments . R_PARENTHESIS COLON block

    R_PARENTHESIS   shift and go to state 156


state 140

    (51) for_stmt -> FOR IDENTIFIER IN expressions . COLON else_block
    (52) for_stmt -> FOR IDENTIFIER IN expressions . COLON block
    (53) expressions -> expressions . COMMA expression

    COLON           shift and go to state 157
    COMMA           shift and go to state 104


state 141

    (50) while_stmt -> WHILE named_expression COLON block .

    ENDMARKER       reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    DEF             reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    IF              reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    CLASS           reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    FOR             reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    WHILE           reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    PASS            reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    BREAK           reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    CONTINUE        reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    IDENTIFIER      reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    RETURN          reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    DEL             reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    GLOBAL          reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)
    DEDENT          reduce using rule 50 (while_stmt -> WHILE named_expression COLON block .)


state 142

    (53) expressions -> expressions COMMA expression .

    COMMA           reduce using rule 53 (expressions -> expressions COMMA expression .)
    NEWLINE         reduce using rule 53 (expressions -> expressions COMMA expression .)
    SEMICOLON       reduce using rule 53 (expressions -> expressions COMMA expression .)
    ENDMARKER       reduce using rule 53 (expressions -> expressions COMMA expression .)
    DEF             reduce using rule 53 (expressions -> expressions COMMA expression .)
    IF              reduce using rule 53 (expressions -> expressions COMMA expression .)
    CLASS           reduce using rule 53 (expressions -> expressions COMMA expression .)
    FOR             reduce using rule 53 (expressions -> expressions COMMA expression .)
    WHILE           reduce using rule 53 (expressions -> expressions COMMA expression .)
    PASS            reduce using rule 53 (expressions -> expressions COMMA expression .)
    BREAK           reduce using rule 53 (expressions -> expressions COMMA expression .)
    CONTINUE        reduce using rule 53 (expressions -> expressions COMMA expression .)
    IDENTIFIER      reduce using rule 53 (expressions -> expressions COMMA expression .)
    RETURN          reduce using rule 53 (expressions -> expressions COMMA expression .)
    DEL             reduce using rule 53 (expressions -> expressions COMMA expression .)
    GLOBAL          reduce using rule 53 (expressions -> expressions COMMA expression .)
    ELIF            reduce using rule 53 (expressions -> expressions COMMA expression .)
    ELSE            reduce using rule 53 (expressions -> expressions COMMA expression .)
    DEDENT          reduce using rule 53 (expressions -> expressions COMMA expression .)
    COLON           reduce using rule 53 (expressions -> expressions COMMA expression .)


state 143

    (32) namelist -> namelist COMMA IDENTIFIER .

    COMMA           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    NEWLINE         reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    SEMICOLON       reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    ENDMARKER       reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    DEF             reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    IF              reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    CLASS           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    FOR             reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    WHILE           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    PASS            reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    BREAK           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    CONTINUE        reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    IDENTIFIER      reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    RETURN          reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    DEL             reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    GLOBAL          reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    ELIF            reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    ELSE            reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    DEDENT          reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)


state 144

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS . COLON block

    COLON           shift and go to state 158


state 145

    (41) parameters -> parameters COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 159


state 146

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 160
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 147

    (43) if_stmt -> IF named_expression COLON block elif_stmt .

    ENDMARKER       reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    DEF             reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    IF              reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    CLASS           reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    FOR             reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    WHILE           reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    PASS            reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    BREAK           reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    CONTINUE        reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    IDENTIFIER      reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    RETURN          reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    DEL             reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    GLOBAL          reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)
    DEDENT          reduce using rule 43 (if_stmt -> IF named_expression COLON block elif_stmt .)


state 148

    (44) if_stmt -> IF named_expression COLON block else_block .

    ENDMARKER       reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    DEF             reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    IF              reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    CLASS           reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    FOR             reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    WHILE           reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    PASS            reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    BREAK           reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    CONTINUE        reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    IDENTIFIER      reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    RETURN          reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    DEL             reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    GLOBAL          reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)
    DEDENT          reduce using rule 44 (if_stmt -> IF named_expression COLON block else_block .)


state 149

    (46) elif_stmt -> ELIF . named_expression COLON block elif_stmt
    (47) elif_stmt -> ELIF . named_expression COLON block else_block
    (48) elif_stmt -> ELIF . named_expression COLON block
    (63) named_expression -> . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    named_expression               shift and go to state 161
    expression                     shift and go to state 42
    disjunction                    shift and go to state 43
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 150

    (49) else_block -> ELSE . COLON block

    COLON           shift and go to state 162


state 151

    (34) block -> NEWLINE INDENT . statements DEDENT
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF named_expression COLON block elif_stmt
    (44) if_stmt -> . IF named_expression COLON block else_block
    (45) if_stmt -> . IF named_expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (51) for_stmt -> . FOR IDENTIFIER IN expressions COLON else_block
    (52) for_stmt -> . FOR IDENTIFIER IN expressions COLON block
    (50) while_stmt -> . WHILE named_expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    statements                     shift and go to state 163
    statement                      shift and go to state 3
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 152

    (56) expression -> disjunction IF disjunction ELSE . expression
    (55) expression -> . disjunction
    (56) expression -> . disjunction IF disjunction ELSE expression
    (57) disjunction -> . conjunction
    (58) disjunction -> . conjunction OR disjunction
    (59) conjunction -> . inversion
    (60) conjunction -> . inversion AND inversion
    (61) inversion -> . NOT inversion
    (62) inversion -> . comparison
    (64) comparison -> . bitwise_or
    (65) comparison -> . bitwise_or compare_op_list
    (78) bitwise_or -> . bitwise_or BITWISE_OR bitwise_xor
    (79) bitwise_or -> . bitwise_xor
    (80) bitwise_xor -> . bitwise_xor empty bitwise_and
    (81) bitwise_xor -> . bitwise_and
    (82) bitwise_and -> . bitwise_and BITWISE_AND shift_expr
    (83) bitwise_and -> . shift_expr
    (84) shift_expr -> . shift_expr L_SHIFT sum
    (85) shift_expr -> . shift_expr R_SHIFT sum
    (86) shift_expr -> . sum
    (87) sum -> . sum SUM term
    (88) sum -> . sum SUBTRACTION term
    (89) sum -> . term
    (90) term -> . term PRODUCT factor
    (91) term -> . term DIVISION factor
    (92) term -> . term INTEGER_DIVISION factor
    (93) term -> . term MODULUS factor
    (94) term -> . factor
    (95) factor -> . SUM factor
    (96) factor -> . SUBTRACTION factor
    (97) factor -> . power
    (98) power -> . empty
    (100) empty -> .

  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUBTRACTION resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    NOT             shift and go to state 46
    SUM             shift and go to state 54
    SUBTRACTION     shift and go to state 56
    PRODUCT         reduce using rule 100 (empty -> .)
    DIVISION        reduce using rule 100 (empty -> .)
    INTEGER_DIVISION reduce using rule 100 (empty -> .)
    MODULUS         reduce using rule 100 (empty -> .)
    L_SHIFT         reduce using rule 100 (empty -> .)
    R_SHIFT         reduce using rule 100 (empty -> .)
    BITWISE_AND     reduce using rule 100 (empty -> .)
    BITWISE_OR      reduce using rule 100 (empty -> .)
    EQUALITY        reduce using rule 100 (empty -> .)
    INEQUALITY      reduce using rule 100 (empty -> .)
    GREATER_EQUAL   reduce using rule 100 (empty -> .)
    LESSER_EQUAL    reduce using rule 100 (empty -> .)
    GREATER         reduce using rule 100 (empty -> .)
    LESSER          reduce using rule 100 (empty -> .)
    IS              reduce using rule 100 (empty -> .)
    IN              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    COLON           reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    NEWLINE         reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    ENDMARKER       reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    CLASS           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    BREAK           reduce using rule 100 (empty -> .)
    CONTINUE        reduce using rule 100 (empty -> .)
    IDENTIFIER      reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    DEL             reduce using rule 100 (empty -> .)
    GLOBAL          reduce using rule 100 (empty -> .)
    ELIF            reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

  ! SUM             [ reduce using rule 100 (empty -> .) ]
  ! SUBTRACTION     [ reduce using rule 100 (empty -> .) ]
  ! NOT             [ reduce using rule 100 (empty -> .) ]

    disjunction                    shift and go to state 43
    expression                     shift and go to state 164
    conjunction                    shift and go to state 44
    inversion                      shift and go to state 45
    comparison                     shift and go to state 47
    bitwise_or                     shift and go to state 48
    bitwise_xor                    shift and go to state 49
    empty                          shift and go to state 50
    bitwise_and                    shift and go to state 51
    shift_expr                     shift and go to state 52
    sum                            shift and go to state 53
    term                           shift and go to state 55
    factor                         shift and go to state 57
    power                          shift and go to state 58

state 153

    (74) compare_op -> NOT IN bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    INEQUALITY      reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    GREATER_EQUAL   reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    LESSER_EQUAL    reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    GREATER         reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    LESSER          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    NOT             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IS              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IN              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    AND             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    OR              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IF              reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    COLON           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    COMMA           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    NEWLINE         reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    SEMICOLON       reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    ENDMARKER       reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    DEF             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    CLASS           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    FOR             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    WHILE           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    PASS            reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    BREAK           reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    CONTINUE        reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    IDENTIFIER      reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    RETURN          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    DEL             reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    GLOBAL          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    ELIF            reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    ELSE            reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    DEDENT          reduce using rule 74 (compare_op -> NOT IN bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 154

    (75) compare_op -> IS NOT bitwise_or .
    (78) bitwise_or -> bitwise_or . BITWISE_OR bitwise_xor

    EQUALITY        reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    INEQUALITY      reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    GREATER_EQUAL   reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    LESSER_EQUAL    reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    GREATER         reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    LESSER          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    NOT             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IS              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IN              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    AND             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    OR              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IF              reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    COLON           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    COMMA           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    NEWLINE         reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    SEMICOLON       reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    ENDMARKER       reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    DEF             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    CLASS           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    FOR             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    WHILE           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    PASS            reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    BREAK           reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    CONTINUE        reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    IDENTIFIER      reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    RETURN          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    DEL             reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    GLOBAL          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    ELIF            reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    ELSE            reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    DEDENT          reduce using rule 75 (compare_op -> IS NOT bitwise_or .)
    BITWISE_OR      shift and go to state 77


state 155

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 165
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 156

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS . COLON block

    COLON           shift and go to state 166


state 157

    (51) for_stmt -> FOR IDENTIFIER IN expressions COLON . else_block
    (52) for_stmt -> FOR IDENTIFIER IN expressions COLON . block
    (49) else_block -> . ELSE COLON block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    ELSE            shift and go to state 150
    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    else_block                     shift and go to state 167
    block                          shift and go to state 168
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 158

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 169
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 159

    (41) parameters -> parameters COMMA IDENTIFIER .

    R_PARENTHESIS   reduce using rule 41 (parameters -> parameters COMMA IDENTIFIER .)
    COMMA           reduce using rule 41 (parameters -> parameters COMMA IDENTIFIER .)


state 160

    (40) function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEF             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IF              reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FOR             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PASS            reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEL             reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 40 (function_def -> DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)


state 161

    (46) elif_stmt -> ELIF named_expression . COLON block elif_stmt
    (47) elif_stmt -> ELIF named_expression . COLON block else_block
    (48) elif_stmt -> ELIF named_expression . COLON block

    COLON           shift and go to state 170


state 162

    (49) else_block -> ELSE COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 171
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 163

    (34) block -> NEWLINE INDENT statements . DEDENT
    (2) statements -> statements . statement
    (4) statement -> . compound_stmt
    (5) statement -> . simple_stmts
    (15) compound_stmt -> . function_def
    (16) compound_stmt -> . if_stmt
    (17) compound_stmt -> . class_def
    (18) compound_stmt -> . for_stmt
    (19) compound_stmt -> . while_stmt
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (39) function_def -> . DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block
    (40) function_def -> . DEF IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (43) if_stmt -> . IF named_expression COLON block elif_stmt
    (44) if_stmt -> . IF named_expression COLON block else_block
    (45) if_stmt -> . IF named_expression COLON block
    (36) class_def -> . CLASS IDENTIFIER COLON block
    (37) class_def -> . CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block
    (38) class_def -> . CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block
    (51) for_stmt -> . FOR IDENTIFIER IN expressions COLON else_block
    (52) for_stmt -> . FOR IDENTIFIER IN expressions COLON block
    (50) while_stmt -> . WHILE named_expression COLON block
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    DEDENT          shift and go to state 172
    DEF             shift and go to state 12
    IF              shift and go to state 14
    CLASS           shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    statement                      shift and go to state 29
    compound_stmt                  shift and go to state 4
    simple_stmts                   shift and go to state 5
    function_def                   shift and go to state 6
    if_stmt                        shift and go to state 7
    class_def                      shift and go to state 8
    for_stmt                       shift and go to state 9
    while_stmt                     shift and go to state 10
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 164

    (56) expression -> disjunction IF disjunction ELSE expression .

    COLON           reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    COMMA           reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    NEWLINE         reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    SEMICOLON       reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    ENDMARKER       reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    DEF             reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    IF              reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    CLASS           reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    FOR             reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    WHILE           reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    PASS            reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    BREAK           reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    CONTINUE        reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    IDENTIFIER      reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    RETURN          reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    DEL             reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    GLOBAL          reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    ELIF            reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    ELSE            reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)
    DEDENT          reduce using rule 56 (expression -> disjunction IF disjunction ELSE expression .)


state 165

    (37) class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEF             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IF              reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    FOR             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    PASS            reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEL             reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 37 (class_def -> CLASS IDENTIFIER L_PARENTHESIS R_PARENTHESIS COLON block .)


state 166

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 173
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 167

    (51) for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .

    ENDMARKER       reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    DEF             reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    IF              reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    CLASS           reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    FOR             reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    WHILE           reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    PASS            reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    BREAK           reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    CONTINUE        reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    IDENTIFIER      reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    RETURN          reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    DEL             reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    GLOBAL          reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)
    DEDENT          reduce using rule 51 (for_stmt -> FOR IDENTIFIER IN expressions COLON else_block .)


state 168

    (52) for_stmt -> FOR IDENTIFIER IN expressions COLON block .

    ENDMARKER       reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    DEF             reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    IF              reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    CLASS           reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    FOR             reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    WHILE           reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    PASS            reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    BREAK           reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    CONTINUE        reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    IDENTIFIER      reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    RETURN          reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    DEL             reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    GLOBAL          reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)
    DEDENT          reduce using rule 52 (for_stmt -> FOR IDENTIFIER IN expressions COLON block .)


state 169

    (39) function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEF             reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    IF              reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    FOR             reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    PASS            reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEL             reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 39 (function_def -> DEF IDENTIFIER L_PARENTHESIS parameters R_PARENTHESIS COLON block .)


state 170

    (46) elif_stmt -> ELIF named_expression COLON . block elif_stmt
    (47) elif_stmt -> ELIF named_expression COLON . block else_block
    (48) elif_stmt -> ELIF named_expression COLON . block
    (34) block -> . NEWLINE INDENT statements DEDENT
    (35) block -> . simple_stmts
    (6) simple_stmts -> . simple_stmts SEMICOLON simple_stmt
    (7) simple_stmts -> . simple_stmt NEWLINE
    (8) simple_stmt -> . assignment
    (9) simple_stmt -> . return_stmt
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . del_stmt
    (12) simple_stmt -> . BREAK
    (13) simple_stmt -> . CONTINUE
    (14) simple_stmt -> . global_stmt
    (20) assignment -> . IDENTIFIER augmentation_assignment expressions
    (21) assignment -> . IDENTIFIER augmentation_assignment IDENTIFIER
    (29) return_stmt -> . RETURN expressions
    (31) del_stmt -> . DEL namelist
    (30) global_stmt -> . GLOBAL namelist

    NEWLINE         shift and go to state 110
    PASS            shift and go to state 20
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    RETURN          shift and go to state 25
    DEL             shift and go to state 26
    GLOBAL          shift and go to state 27

    block                          shift and go to state 174
    simple_stmts                   shift and go to state 111
    simple_stmt                    shift and go to state 11
    assignment                     shift and go to state 18
    return_stmt                    shift and go to state 19
    del_stmt                       shift and go to state 21
    global_stmt                    shift and go to state 24

state 171

    (49) else_block -> ELSE COLON block .

    ENDMARKER       reduce using rule 49 (else_block -> ELSE COLON block .)
    DEF             reduce using rule 49 (else_block -> ELSE COLON block .)
    IF              reduce using rule 49 (else_block -> ELSE COLON block .)
    CLASS           reduce using rule 49 (else_block -> ELSE COLON block .)
    FOR             reduce using rule 49 (else_block -> ELSE COLON block .)
    WHILE           reduce using rule 49 (else_block -> ELSE COLON block .)
    PASS            reduce using rule 49 (else_block -> ELSE COLON block .)
    BREAK           reduce using rule 49 (else_block -> ELSE COLON block .)
    CONTINUE        reduce using rule 49 (else_block -> ELSE COLON block .)
    IDENTIFIER      reduce using rule 49 (else_block -> ELSE COLON block .)
    RETURN          reduce using rule 49 (else_block -> ELSE COLON block .)
    DEL             reduce using rule 49 (else_block -> ELSE COLON block .)
    GLOBAL          reduce using rule 49 (else_block -> ELSE COLON block .)
    DEDENT          reduce using rule 49 (else_block -> ELSE COLON block .)


state 172

    (34) block -> NEWLINE INDENT statements DEDENT .

    ELIF            reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    ELSE            reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    ENDMARKER       reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    DEF             reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    IF              reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    CLASS           reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    FOR             reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    WHILE           reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    PASS            reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    BREAK           reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    CONTINUE        reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    IDENTIFIER      reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    RETURN          reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    DEL             reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    GLOBAL          reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)
    DEDENT          reduce using rule 34 (block -> NEWLINE INDENT statements DEDENT .)


state 173

    (38) class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .

    ENDMARKER       reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEF             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    IF              reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    CLASS           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    FOR             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    WHILE           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    PASS            reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    BREAK           reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    CONTINUE        reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    IDENTIFIER      reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    RETURN          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEL             reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    GLOBAL          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)
    DEDENT          reduce using rule 38 (class_def -> CLASS IDENTIFIER L_PARENTHESIS arguments R_PARENTHESIS COLON block .)


state 174

    (46) elif_stmt -> ELIF named_expression COLON block . elif_stmt
    (47) elif_stmt -> ELIF named_expression COLON block . else_block
    (48) elif_stmt -> ELIF named_expression COLON block .
    (46) elif_stmt -> . ELIF named_expression COLON block elif_stmt
    (47) elif_stmt -> . ELIF named_expression COLON block else_block
    (48) elif_stmt -> . ELIF named_expression COLON block
    (49) else_block -> . ELSE COLON block

    ENDMARKER       reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    DEF             reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    IF              reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    CLASS           reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    FOR             reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    WHILE           reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    PASS            reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    BREAK           reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    CONTINUE        reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    IDENTIFIER      reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    RETURN          reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    DEL             reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    GLOBAL          reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    DEDENT          reduce using rule 48 (elif_stmt -> ELIF named_expression COLON block .)
    ELIF            shift and go to state 149
    ELSE            shift and go to state 150

    elif_stmt                      shift and go to state 175
    else_block                     shift and go to state 176

state 175

    (46) elif_stmt -> ELIF named_expression COLON block elif_stmt .

    ENDMARKER       reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    DEF             reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    IF              reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    CLASS           reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    FOR             reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    WHILE           reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    PASS            reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    BREAK           reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    CONTINUE        reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    IDENTIFIER      reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    RETURN          reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    DEL             reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    GLOBAL          reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)
    DEDENT          reduce using rule 46 (elif_stmt -> ELIF named_expression COLON block elif_stmt .)


state 176

    (47) elif_stmt -> ELIF named_expression COLON block else_block .

    ENDMARKER       reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    DEF             reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    IF              reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    CLASS           reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    FOR             reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    WHILE           reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    PASS            reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    BREAK           reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    CONTINUE        reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    IDENTIFIER      reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    RETURN          reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    DEL             reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    GLOBAL          reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)
    DEDENT          reduce using rule 47 (elif_stmt -> ELIF named_expression COLON block else_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SUM in state 14 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 14 resolved as shift
WARNING: shift/reduce conflict for NOT in state 14 resolved as shift
WARNING: shift/reduce conflict for SUM in state 17 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 17 resolved as shift
WARNING: shift/reduce conflict for NOT in state 17 resolved as shift
WARNING: shift/reduce conflict for SUM in state 25 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 25 resolved as shift
WARNING: shift/reduce conflict for NOT in state 25 resolved as shift
WARNING: shift/reduce conflict for SUM in state 33 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 33 resolved as shift
WARNING: shift/reduce conflict for NOT in state 33 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 33 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for SUM in state 46 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 46 resolved as shift
WARNING: shift/reduce conflict for NOT in state 46 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 51 resolved as shift
WARNING: shift/reduce conflict for L_SHIFT in state 52 resolved as shift
WARNING: shift/reduce conflict for R_SHIFT in state 52 resolved as shift
WARNING: shift/reduce conflict for SUM in state 53 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 53 resolved as shift
WARNING: shift/reduce conflict for SUM in state 54 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 54 resolved as shift
WARNING: shift/reduce conflict for PRODUCT in state 55 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 55 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVISION in state 55 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 55 resolved as shift
WARNING: shift/reduce conflict for SUM in state 56 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 56 resolved as shift
WARNING: shift/reduce conflict for SUM in state 72 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 72 resolved as shift
WARNING: shift/reduce conflict for NOT in state 72 resolved as shift
WARNING: shift/reduce conflict for SUM in state 73 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 73 resolved as shift
WARNING: shift/reduce conflict for NOT in state 73 resolved as shift
WARNING: shift/reduce conflict for SUM in state 74 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 74 resolved as shift
WARNING: shift/reduce conflict for NOT in state 74 resolved as shift
WARNING: shift/reduce conflict for SUM in state 77 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 77 resolved as shift
WARNING: shift/reduce conflict for SUM in state 79 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 79 resolved as shift
WARNING: shift/reduce conflict for SUM in state 80 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 80 resolved as shift
WARNING: shift/reduce conflict for SUM in state 81 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 81 resolved as shift
WARNING: shift/reduce conflict for SUM in state 82 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 82 resolved as shift
WARNING: shift/reduce conflict for SUM in state 83 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 83 resolved as shift
WARNING: shift/reduce conflict for SUM in state 84 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 84 resolved as shift
WARNING: shift/reduce conflict for SUM in state 86 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 86 resolved as shift
WARNING: shift/reduce conflict for SUM in state 87 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 87 resolved as shift
WARNING: shift/reduce conflict for NOT in state 87 resolved as shift
WARNING: shift/reduce conflict for SUM in state 88 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 88 resolved as shift
WARNING: shift/reduce conflict for SUM in state 89 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 89 resolved as shift
WARNING: shift/reduce conflict for SUM in state 90 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 90 resolved as shift
WARNING: shift/reduce conflict for SUM in state 91 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 91 resolved as shift
WARNING: shift/reduce conflict for SUM in state 92 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 92 resolved as shift
WARNING: shift/reduce conflict for SUM in state 93 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 93 resolved as shift
WARNING: shift/reduce conflict for SUM in state 95 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 95 resolved as shift
WARNING: shift/reduce conflict for SUM in state 96 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 96 resolved as shift
WARNING: shift/reduce conflict for SUM in state 97 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 97 resolved as shift
WARNING: shift/reduce conflict for SUM in state 98 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 98 resolved as shift
WARNING: shift/reduce conflict for R_PARENTHESIS in state 101 resolved as shift
WARNING: shift/reduce conflict for SUM in state 102 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 102 resolved as shift
WARNING: shift/reduce conflict for NOT in state 102 resolved as shift
WARNING: shift/reduce conflict for SUM in state 104 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT in state 104 resolved as shift
WARNING: shift/reduce conflict for SUM in state 123 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 123 resolved as shift
WARNING: shift/reduce conflict for SUM in state 125 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 125 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 127 resolved as shift
WARNING: shift/reduce conflict for L_SHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for R_SHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for SUM in state 129 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 129 resolved as shift
WARNING: shift/reduce conflict for SUM in state 130 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 130 resolved as shift
WARNING: shift/reduce conflict for PRODUCT in state 131 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 131 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVISION in state 131 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 131 resolved as shift
WARNING: shift/reduce conflict for PRODUCT in state 132 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 132 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVISION in state 132 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 132 resolved as shift
WARNING: shift/reduce conflict for SUM in state 149 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 149 resolved as shift
WARNING: shift/reduce conflict for NOT in state 149 resolved as shift
WARNING: shift/reduce conflict for SUM in state 152 resolved as shift
WARNING: shift/reduce conflict for SUBTRACTION in state 152 resolved as shift
WARNING: shift/reduce conflict for NOT in state 152 resolved as shift
WARNING: reduce/reduce conflict in state 49 resolved using rule (bitwise_or -> bitwise_xor)
WARNING: rejected rule (empty -> <empty>) in state 49
WARNING: reduce/reduce conflict in state 116 resolved using rule (bitwise_or -> bitwise_or BITWISE_OR bitwise_xor)
WARNING: rejected rule (empty -> <empty>) in state 116
