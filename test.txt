#  Oscar Mario Fernandez Jimenez - C12840
#  ref: https://en.wikipedia.org/wiki/DFA_minimization

states = {0, 1, 2, 3, 4, 5} 
alphabet = {'a', 'b'} 
transitions = { 0: {'a': 1, 'b': 2}, 1: {'a': 0, 'b': 3}, 2: {'a': 4, 'b': 5},
               3: {'a':4, 'b': 5}, 4: {'a': 4, 'b': 5}, 5: {'a': 5, 'b': 5} } 
accepting_states = {1, 3, 5}

#  Defining main function
def main():
    result = hopcroft(states, alphabet, transitions, accepting_states)
    print(result)

def hopcroft(states, alphabet, transitions, accepting_states):
    min_states = minimizer(states, alphabet, transitions, accepting_states)
    min_accepting_states = new_accepting_states(min_states, accepting_states)
    min_transitions = new_transitions(min_states, transitions)

    # Create the result string
    result = "States: " + str(min_states) + "\n" + "Alphabet: " + str(alphabet)\
          + "\n" + "Transitions: " + str(min_transitions) + "\n"\
              + "Accepting states: " + str(min_accepting_states)
    
    # Remove the frozenset string to improve readability
    result = result.replace('frozenset', '')
    return result

def minimizer(states, alphabet, transitions, accepting_states):
    non_accepting_states = states - accepting_states
    minimized = [accepting_states, non_accepting_states]
    available_sets = [accepting_states]

    while available_sets:
        current_set = available_sets.pop(0)
        for symbol in alphabet:
            # Create a list of states that are reachable using the symbol
            transition_states = []
            for state in states:
                if transitions[state][symbol] in current_set:
                    transition_states.append(state)
            for check_set in minimized:
                #Add the intersection and difference of the two sets to the minimized list
                if check_set.intersection(transition_states) and check_set.difference(transition_states):
                    replace_set(minimized, check_set, transition_states)
                    if check_set in available_sets:
                        replace_set(available_sets, check_set, transition_states)
                    else:
                        if len(check_set.intersection(transition_states)) <= len(check_set.difference(transition_states)):
                            available_sets.append(check_set.intersection(transition_states))
                        else:
                            available_sets.append(check_set.difference(transition_states))
    return minimized

def replace_set(replace, check_set, transition_states):
    replace.remove(check_set)
    replace.append(check_set.intersection(transition_states))
    replace.append(check_set.difference(transition_states))

def new_accepting_states(minimized, accepting_states):
    new_accepting_states = []
    for set in minimized:
        if set.intersection(accepting_states):
            new_accepting_states.append(set)
    return new_accepting_states

def new_transitions(minimized, transitions):
    new_transitions = {}
    for set in minimized:
        immutable_set = frozenset(set)
        new_transitions[immutable_set] = {}
        representative = next(iter(set))
        for symbol in alphabet:
            check_transitions = transitions[representative][symbol]
            if check_transitions is not None:
                for set2 in minimized:
                    if check_transitions in set2:
                        new_transitions[immutable_set][symbol] = set2
    return new_transitions

# Using the special variable 
# __name__
if __name__=="__main__":
    main()
